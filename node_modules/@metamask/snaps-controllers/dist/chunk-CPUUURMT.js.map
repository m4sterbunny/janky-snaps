{"version":3,"sources":["../src/snaps/registry/json.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\nconst SNAP_REGISTRY_URL =\n  'https://acl.execution.metamask.io/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://acl.execution.metamask.io/latest/signature.json';\n\nconst DEFAULT_PUBLIC_KEY =\n  '0x025b65308f0f0fb8bc7f7ff87bfc296e0330eee5d3c1d1ee4a048b2fd6a86fa0a6';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryActions =\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryEvents = never;\n\nexport type SnapsRegistryMessenger = RestrictedControllerMessenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents,\n  SnapsRegistryActions['type'],\n  SnapsRegistryEvents['type']\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n  databaseUnavailable: boolean;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n  databaseUnavailable: false,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  #url: JsonSnapsRegistryUrl;\n\n  #publicKey: Hex;\n\n  #fetchFunction: typeof fetch;\n\n  #recentFetchThreshold: number;\n\n  #refetchOnAllowlistMiss: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey = DEFAULT_PUBLIC_KEY,\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: { persist: true, anonymous: false },\n        lastUpdated: { persist: true, anonymous: false },\n        databaseUnavailable: { persist: true, anonymous: false },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#currentUpdate = null;\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:get',\n      async (...args) => this.#get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      async (...args) => this.#getMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:update',\n      async () => this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const database = await this.#safeFetch(this.#url.registry);\n\n      const signature = await this.#safeFetch(this.#url.signature);\n      this.#verifySignature(database, signature);\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n        state.databaseUnavailable = false;\n      });\n    } catch {\n      // Ignore\n      this.update((state) => {\n        state.databaseUnavailable = true;\n      });\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return {\n      status: this.state.databaseUnavailable\n        ? SnapsRegistryStatus.Unavailable\n        : SnapsRegistryStatus.Unverified,\n    };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range. Otherwise return the version range itself.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range if available otherwise returns the input version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!versions) {\n      return versionRange;\n    }\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!targetVersion) {\n      return versionRange;\n    }\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  async #getMetadata(snapId: string): Promise<SnapsRegistryMetadata | null> {\n    const database = await this.#getDatabase();\n    return database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"]}