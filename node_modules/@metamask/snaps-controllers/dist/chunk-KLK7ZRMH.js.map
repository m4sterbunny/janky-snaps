{"version":3,"sources":["../src/interface/utils.ts"],"names":[],"mappings":";AAAA,SAAS,UAAU,cAAc;AAe1B,IAAM,sBAAsB,CACjC,OACA,cACG;AACH,SAAO,UAAU,SAAS,MAAM,UAAU,IAAI,KAAK;AACrD;AAYO,IAAM,0BAA0B,CACrC,OACA,WACA,SACG;AACH,QAAM,eAAe,MAAM,IAAI;AAC/B,QAAM,gBAAgB,eAAe,UAAU,IAAI;AACnD,SAAO,UAAU,SAAS,iBAAiB;AAC7C;AAQO,IAAM,qBAAqB,CAAC,OAAuB,SAAiB;AACzE;AAAA,IACE,MAAM,IAAI,MAAM;AAAA,IAChB,4EAA4E,IAAI;AAAA,EAClF;AACF;AAUO,IAAM,iBAAiB,CAC5B,UACA,WACA,WAA2B,CAAC,MACT;AACnB,QAAM,EAAE,KAAK,IAAI;AACjB,MAAI,SAAS,SAAS,OAAO;AAC3B,WAAO,UAAU,SAAS;AAAA,MACxB,CAAC,KAAK,SAAS,eAAe,UAAU,MAAM,GAAG;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS,SAAS,MAAM;AAC1B,uBAAmB,UAAU,UAAU,IAAI;AAC3C,aAAS,UAAU,IAAI,IAAI,UAAU,SAAS;AAAA,MAC5C,CAAC,KAAK,SAAS;AACb,YAAI,KAAK,SAAS,SAAS,OAAO;AAChC,6BAAmB,KAAK,KAAK,IAAI;AACjC,cAAI,KAAK,IAAI,IAAI;AAAA,YACf;AAAA,YACA;AAAA,YACA,UAAU;AAAA,UACZ;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI,SAAS,SAAS,OAAO;AAC3B,uBAAmB,UAAU,UAAU,IAAI;AAC3C,aAAS,UAAU,IAAI,IAAI,oBAAoB,UAAU,SAAS;AAAA,EACpE;AAEA,SAAO;AACT","sourcesContent":["import { NodeType, assert } from '@metamask/snaps-sdk';\nimport type {\n  Component,\n  Input,\n  FormState,\n  InterfaceState,\n} from '@metamask/snaps-sdk';\n\n/**\n * Construct the state for a stray input (not enclosed in a form).\n *\n * @param state - The interface state.\n * @param component - The Input component.\n * @returns The input state.\n */\nexport const constructInputState = (\n  state: InterfaceState,\n  component: Input,\n) => {\n  return component.value ?? state[component.name] ?? null;\n};\n\n/**\n * Construct the state for a form input.\n *\n * Sets the state to either the specified component value, the previous value from the old state or null.\n *\n * @param state - The interface state.\n * @param component - The Input component.\n * @param form - The parent form name of the input.\n * @returns The input state.\n */\nexport const constructFormInputState = (\n  state: InterfaceState,\n  component: Input,\n  form: string,\n) => {\n  const oldFormState = state[form] as FormState;\n  const oldInputState = oldFormState?.[component.name];\n  return component.value ?? oldInputState ?? null;\n};\n\n/**\n * Assert that the component name is unique in state.\n *\n * @param state - The interface state to verify against.\n * @param name - The component name to verify.\n */\nexport const assertNameIsUnique = (state: InterfaceState, name: string) => {\n  assert(\n    state[name] === undefined,\n    `Duplicate component names are not allowed, found multiple instances of: \"${name}\".`,\n  );\n};\n\n/**\n * Construct the interface state for a given component tree while preserving values for matching stateful components in the old state.\n *\n * @param oldState - The previous state.\n * @param component - The UI component to construct state from.\n * @param newState - The state that is being constructed.\n * @returns The interface state of the passed component.\n */\nexport const constructState = (\n  oldState: InterfaceState,\n  component: Component,\n  newState: InterfaceState = {},\n): InterfaceState => {\n  const { type } = component;\n  if (type === NodeType.Panel) {\n    return component.children.reduce(\n      (acc, node) => constructState(oldState, node, acc),\n      newState,\n    );\n  }\n\n  if (type === NodeType.Form) {\n    assertNameIsUnique(newState, component.name);\n    newState[component.name] = component.children.reduce<FormState>(\n      (acc, node) => {\n        if (node.type === NodeType.Input) {\n          assertNameIsUnique(acc, node.name);\n          acc[node.name] = constructFormInputState(\n            oldState,\n            node,\n            component.name,\n          );\n        }\n\n        return acc;\n      },\n      {},\n    );\n  }\n\n  if (type === NodeType.Input) {\n    assertNameIsUnique(newState, component.name);\n    newState[component.name] = constructInputState(oldState, component);\n  }\n\n  return newState;\n};\n"]}