{"version":3,"sources":["../src/services/AbstractExecutionService.ts"],"names":[],"mappings":"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","sourcesContent":["import { JsonRpcEngine } from '@metamask/json-rpc-engine';\nimport { createStreamMiddleware } from '@metamask/json-rpc-middleware-stream';\nimport ObjectMultiplex from '@metamask/object-multiplex';\nimport type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport { JsonRpcError } from '@metamask/rpc-errors';\nimport type { SnapRpcHook, SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { SNAP_STREAM_NAMES, logError } from '@metamask/snaps-utils';\nimport type {\n  Json,\n  JsonRpcNotification,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\nimport {\n  Duration,\n  assertIsJsonRpcRequest,\n  inMilliseconds,\n  isJsonRpcNotification,\n  isObject,\n} from '@metamask/utils';\nimport { nanoid } from 'nanoid';\nimport { pipeline } from 'readable-stream';\nimport type { Duplex } from 'readable-stream';\n\nimport { log } from '../logging';\nimport { hasTimedOut, withTimeout } from '../utils';\nimport type {\n  ExecutionService,\n  ExecutionServiceMessenger,\n  SnapErrorJson,\n  SnapExecutionData,\n} from './ExecutionService';\n\nconst controllerName = 'ExecutionService';\n\nexport type SetupSnapProvider = (snapId: string, stream: Duplex) => void;\n\nexport type ExecutionServiceArgs = {\n  setupSnapProvider: SetupSnapProvider;\n  messenger: ExecutionServiceMessenger;\n  pingTimeout?: number;\n  terminationTimeout?: number;\n};\n\nexport type JobStreams = {\n  command: Duplex;\n  rpc: Duplex;\n  _connection: BasePostMessageStream;\n};\n\nexport type Job<WorkerType> = {\n  id: string;\n  streams: JobStreams;\n  rpcEngine: JsonRpcEngine;\n  worker: WorkerType;\n};\n\nexport abstract class AbstractExecutionService<WorkerType>\n  implements ExecutionService\n{\n  #snapRpcHooks: Map<string, SnapRpcHook>;\n\n  // Cannot be hash private yet because of tests.\n  protected jobs: Map<string, Job<WorkerType>>;\n\n  // Cannot be hash private yet because of tests.\n  private readonly setupSnapProvider: SetupSnapProvider;\n\n  #snapToJobMap: Map<string, string>;\n\n  #jobToSnapMap: Map<string, string>;\n\n  #messenger: ExecutionServiceMessenger;\n\n  #pingTimeout: number;\n\n  #terminationTimeout: number;\n\n  constructor({\n    setupSnapProvider,\n    messenger,\n    pingTimeout = inMilliseconds(2, Duration.Second),\n    terminationTimeout = inMilliseconds(1, Duration.Second),\n  }: ExecutionServiceArgs) {\n    this.#snapRpcHooks = new Map();\n    this.jobs = new Map();\n    this.setupSnapProvider = setupSnapProvider;\n    this.#snapToJobMap = new Map();\n    this.#jobToSnapMap = new Map();\n    this.#messenger = messenger;\n    this.#pingTimeout = pingTimeout;\n    this.#terminationTimeout = terminationTimeout;\n\n    this.registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  private registerMessageHandlers(): void {\n    this.#messenger.registerActionHandler(\n      `${controllerName}:handleRpcRequest`,\n      async (snapId: string, options: SnapRpcHookArgs) =>\n        this.handleRpcRequest(snapId, options),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:executeSnap`,\n      async (snapData: SnapExecutionData) => this.executeSnap(snapData),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateSnap`,\n      async (snapId: string) => this.terminateSnap(snapId),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${controllerName}:terminateAllSnaps`,\n      async () => this.terminateAllSnaps(),\n    );\n  }\n\n  /**\n   * Performs additional necessary work during job termination. **MUST** be\n   * implemented by concrete implementations. See\n   * {@link AbstractExecutionService.terminate} for details.\n   *\n   * @param job - The object corresponding to the job to be terminated.\n   */\n  protected abstract terminateJob(job: Job<WorkerType>): void;\n\n  /**\n   * Terminates the job with the specified ID and deletes all its associated\n   * data. Any subsequent messages targeting the job will fail with an error.\n   * Throws an error if the specified job does not exist, or if termination\n   * fails unexpectedly.\n   *\n   * @param jobId - The id of the job to be terminated.\n   */\n  public async terminate(jobId: string): Promise<void> {\n    const jobWrapper = this.jobs.get(jobId);\n    if (!jobWrapper) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    // Ping worker and tell it to run teardown, continue with termination if it takes too long\n    const result = await withTimeout(\n      this.command(jobId, {\n        jsonrpc: '2.0',\n        method: 'terminate',\n        params: [],\n        id: nanoid(),\n      }),\n      this.#terminationTimeout,\n    );\n\n    if (result === hasTimedOut || result !== 'OK') {\n      // We tried to shutdown gracefully but failed. This probably means the Snap is in infinite loop and\n      // hogging down the whole JS process.\n      // TODO(ritave): It might be doing weird things such as posting a lot of setTimeouts. Add a test to ensure that this behaviour\n      //               doesn't leak into other workers. Especially important in IframeExecutionEnvironment since they all share the same\n      //               JS process.\n      logError(`Job \"${jobId}\" failed to terminate gracefully.`, result);\n    }\n\n    Object.values(jobWrapper.streams).forEach((stream) => {\n      try {\n        !stream.destroyed && stream.destroy();\n        stream.removeAllListeners();\n      } catch (error) {\n        logError('Error while destroying stream', error);\n      }\n    });\n\n    this.terminateJob(jobWrapper);\n\n    this.#removeSnapAndJobMapping(jobId);\n    this.jobs.delete(jobId);\n    log(`Job \"${jobId}\" terminated.`);\n  }\n\n  /**\n   * Initiates a job for a snap.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @returns Information regarding the created job.\n   */\n  protected async initJob(): Promise<Job<WorkerType>> {\n    const jobId = nanoid();\n    const { streams, worker } = await this.initStreams(jobId);\n    const rpcEngine = new JsonRpcEngine();\n\n    const jsonRpcConnection = createStreamMiddleware();\n\n    pipeline(\n      jsonRpcConnection.stream,\n      streams.command,\n      jsonRpcConnection.stream,\n      (error) => {\n        if (error) {\n          logError(`Command stream failure.`, error);\n        }\n      },\n    );\n\n    rpcEngine.push(jsonRpcConnection.middleware);\n\n    const envMetadata = {\n      id: jobId,\n      streams,\n      rpcEngine,\n      worker,\n    };\n    this.jobs.set(jobId, envMetadata);\n\n    return envMetadata;\n  }\n\n  /**\n   * Sets up the streams for an initiated job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param jobId - The id of the job.\n   * @returns The streams to communicate with the worker and the worker itself.\n   */\n  protected async initStreams(\n    jobId: string,\n  ): Promise<{ streams: JobStreams; worker: WorkerType }> {\n    const { worker, stream: envStream } = await this.initEnvStream(jobId);\n    const mux = setupMultiplex(envStream, `Job: \"${jobId}\"`);\n    const commandStream = mux.createStream(SNAP_STREAM_NAMES.COMMAND);\n\n    // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.\n    // Also keep track of outbound request/responses\n    const notificationHandler = (\n      message:\n        | JsonRpcRequest\n        | JsonRpcNotification<Json[] | Record<string, Json>>,\n    ) => {\n      if (!isJsonRpcNotification(message)) {\n        return;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const snapId = this.#jobToSnapMap.get(jobId)!;\n      if (message.method === 'OutboundRequest') {\n        this.#messenger.publish('ExecutionService:outboundRequest', snapId);\n      } else if (message.method === 'OutboundResponse') {\n        this.#messenger.publish('ExecutionService:outboundResponse', snapId);\n      } else if (message.method === 'UnhandledError') {\n        if (isObject(message.params) && message.params.error) {\n          this.#messenger.publish(\n            'ExecutionService:unhandledError',\n            snapId,\n            message.params.error as SnapErrorJson,\n          );\n          commandStream.removeListener('data', notificationHandler);\n        } else {\n          logError(\n            new Error(\n              `Received malformed \"${message.method}\" command stream notification.`,\n            ),\n          );\n        }\n      } else {\n        logError(\n          new Error(\n            `Received unexpected command stream notification \"${message.method}\".`,\n          ),\n        );\n      }\n    };\n\n    commandStream.on('data', notificationHandler);\n    const rpcStream = mux.createStream(SNAP_STREAM_NAMES.JSON_RPC);\n\n    // Typecast: stream type mismatch\n    return {\n      streams: {\n        command: commandStream,\n        rpc: rpcStream,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        _connection: envStream,\n      },\n      worker,\n    };\n  }\n\n  /**\n   * Abstract function implemented by implementing class that spins up a new worker for a job.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   */\n  protected abstract initEnvStream(jobId: string): Promise<{\n    worker: WorkerType;\n    stream: BasePostMessageStream;\n  }>;\n\n  /**\n   * Terminates the Snap with the specified ID. May throw an error if\n   * termination unexpectedly fails, but will not fail if no job for the snap\n   * with the specified ID is found.\n   *\n   * @param snapId - The ID of the snap to terminate.\n   */\n  async terminateSnap(snapId: string) {\n    const jobId = this.#snapToJobMap.get(snapId);\n    if (jobId) {\n      await this.terminate(jobId);\n    }\n  }\n\n  async terminateAllSnaps() {\n    await Promise.all(\n      [...this.jobs.keys()].map(async (jobId) => this.terminate(jobId)),\n    );\n    this.#snapRpcHooks.clear();\n  }\n\n  /**\n   * Gets the RPC request handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC request handler for the snap.\n   */\n  private getRpcRequestHandler(snapId: string) {\n    return this.#snapRpcHooks.get(snapId);\n  }\n\n  /**\n   * Initializes and executes a snap, setting up the communication channels to the snap etc.\n   *\n   * Depending on the execution environment, this may run forever if the Snap fails to start up properly, therefore any call to this function should be wrapped in a timeout.\n   *\n   * @param snapData - Data needed for Snap execution.\n   * @returns A string `OK` if execution succeeded.\n   * @throws If the execution service returns an error.\n   */\n  async executeSnap(snapData: SnapExecutionData): Promise<string> {\n    if (this.#snapToJobMap.has(snapData.snapId)) {\n      throw new Error(`Snap \"${snapData.snapId}\" is already being executed.`);\n    }\n\n    // This may resolve even if the environment has failed to start up fully\n    const job = await this.initJob();\n    this.#mapSnapAndJob(snapData.snapId, job.id);\n\n    // Ping the worker to ensure that it started up\n    const pingResult = await withTimeout(\n      this.command(job.id, {\n        jsonrpc: '2.0',\n        method: 'ping',\n        id: nanoid(),\n      }),\n      this.#pingTimeout,\n    );\n\n    if (pingResult === hasTimedOut) {\n      throw new Error('The Snaps execution environment failed to start.');\n    }\n\n    const rpcStream = job.streams.rpc;\n\n    this.setupSnapProvider(snapData.snapId, rpcStream);\n\n    const result = await this.command(job.id, {\n      jsonrpc: '2.0',\n      method: 'executeSnap',\n      params: snapData,\n      id: nanoid(),\n    });\n    this.#createSnapHooks(snapData.snapId, job.id);\n    return result as string;\n  }\n\n  // Cannot be hash private yet because of tests.\n  private async command(\n    jobId: string,\n    message: JsonRpcRequest,\n  ): Promise<Json | undefined> {\n    assertIsJsonRpcRequest(message);\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new Error(`Job with id \"${jobId}\" not found.`);\n    }\n\n    log('Parent: Sending Command', message);\n    const response: PendingJsonRpcResponse<Json> = await job.rpcEngine.handle(\n      message,\n    );\n\n    if (response.error) {\n      throw new JsonRpcError(\n        response.error.code,\n        response.error.message,\n        response.error.data,\n      );\n    }\n\n    return response.result;\n  }\n\n  #removeSnapHooks(snapId: string) {\n    this.#snapRpcHooks.delete(snapId);\n  }\n\n  #createSnapHooks(snapId: string, workerId: string) {\n    const rpcHook = async ({ origin, handler, request }: SnapRpcHookArgs) => {\n      return await this.command(workerId, {\n        id: nanoid(),\n        jsonrpc: '2.0',\n        method: 'snapRpc',\n        params: {\n          origin,\n          handler,\n          request: request as JsonRpcRequest,\n          target: snapId,\n        },\n      });\n    };\n\n    this.#snapRpcHooks.set(snapId, rpcHook);\n  }\n\n  #mapSnapAndJob(snapId: string, jobId: string): void {\n    this.#snapToJobMap.set(snapId, jobId);\n    this.#jobToSnapMap.set(jobId, snapId);\n  }\n\n  #removeSnapAndJobMapping(jobId: string): void {\n    const snapId = this.#jobToSnapMap.get(jobId);\n    if (!snapId) {\n      throw new Error(`job: \"${jobId}\" has no mapped snap.`);\n    }\n\n    this.#jobToSnapMap.delete(jobId);\n    this.#snapToJobMap.delete(snapId);\n    this.#removeSnapHooks(snapId);\n  }\n\n  /**\n   * Handle RPC request.\n   *\n   * @param snapId - The ID of the recipient snap.\n   * @param options - Bag of options to pass to the RPC handler.\n   * @returns Promise that can handle the request.\n   */\n  public async handleRpcRequest(\n    snapId: string,\n    options: SnapRpcHookArgs,\n  ): Promise<unknown> {\n    const rpcRequestHandler = this.getRpcRequestHandler(snapId);\n\n    if (!rpcRequestHandler) {\n      throw new Error(\n        `Snap execution service returned no RPC handler for running snap \"${snapId}\".`,\n      );\n    }\n\n    return rpcRequestHandler(options);\n  }\n}\n\n/**\n * Sets up stream multiplexing for the given stream.\n *\n * @param connectionStream - The stream to mux.\n * @param streamName - The name of the stream, for identification in errors.\n * @returns The multiplexed stream.\n */\nexport function setupMultiplex(\n  connectionStream: Duplex,\n  streamName: string,\n): ObjectMultiplex {\n  const mux = new ObjectMultiplex();\n  pipeline(connectionStream, mux, connectionStream, (error) => {\n    if (error) {\n      streamName\n        ? logError(`\"${streamName}\" stream failure.`, error)\n        : logError(error);\n    }\n  });\n  return mux;\n}\n"]}