{"version":3,"sources":["../src/snaps/location/http.ts"],"names":["vfile"],"mappings":";AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,QAAQ,oBAAoB;AAY9B,IAAM,eAAN,MAA2C;AAAA,EAoBhD,YAAY,KAAU,OAAoB,CAAC,GAAG;AAb9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAiB,QAAQ,oBAAI,IAG3B;AAWA,iBAAa,IAAI,SAAS,GAAG,kBAAkB,mBAAmB;AAClE,SAAK,UAAU,KAAK,SAAS,WAAW,MAAM,KAAK,UAAU;AAC7D,SAAK,eAAe,KAAK;AACzB,SAAK,MAAM;AAAA,EACb;AAAA,EAEA,MAAM,WAA+C;AACnD,QAAI,KAAK,mBAAmB;AAC1B,aAAO,KAAK,kBAAkB,MAAM;AAAA,IACtC;AAGA,UAAM,gBAAgB,IAAI;AAAA,MACxB,iBAAiB;AAAA,MACjB,KAAK;AAAA,IACP,EAAE,SAAS;AAEX,UAAM,WAAW,MAAM,KAAK,QAAQ,eAAe,KAAK,YAAY;AACpE,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI;AAAA,QACR,oBAAoB,aAAa,mBAAmB,SAAS,MAAM;AAAA,MACrE;AAAA,IACF;AACA,UAAM,WAAW,MAAM,SAAS,KAAK;AACrC,UAAM,WAAW,UAAU,QAAQ;AACnC,UAAM,QAAQ,IAAI,YAA0B;AAAA,MAC1C,OAAO;AAAA,MACP,QAAQ,mBAAmB,QAAQ;AAAA,MACnC,MAAM,iBAAiB;AAAA,MACvB,MAAM,EAAE,cAAc;AAAA,IACxB,CAAC;AACD,SAAK,oBAAoB;AAEzB,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,MAAM,MAAM,MAAoC;AAC9C,UAAM,eAAe,kBAAkB,IAAI;AAC3C,UAAM,SAAS,KAAK,MAAM,IAAI,YAAY;AAC1C,QAAI,WAAW,QAAW;AACxB,YAAM,EAAE,MAAM,SAAS,IAAI;AAC3B,YAAM,QAAQ,IAAI,WAAW,MAAM,SAAS,YAAY,CAAC;AACzD,YAAMA,SAAQ,KAAK,MAAM;AACzB,MAAAA,OAAM,QAAQ;AACd,aAAOA;AAAA,IACT;AAEA,UAAM,gBAAgB,KAAK,YAAY,YAAY,EAAE,SAAS;AAC9D,UAAM,WAAW,MAAM,KAAK,QAAQ,eAAe,KAAK,YAAY;AACpE,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI;AAAA,QACR,oBAAoB,aAAa,mBAAmB,SAAS,MAAM;AAAA,MACrE;AAAA,IACF;AACA,UAAM,QAAQ,IAAI,YAAY;AAAA,MAC5B,OAAO;AAAA,MACP,MAAM;AAAA,MACN,MAAM,EAAE,cAAc;AAAA,IACxB,CAAC;AACD,UAAM,OAAO,MAAM,SAAS,KAAK;AACjC;AAAA,MACE,CAAC,KAAK,MAAM,IAAI,YAAY;AAAA,MAC5B;AAAA,IACF;AACA,SAAK,MAAM,IAAI,cAAc,EAAE,MAAM,OAAO,UAAU,KAAK,CAAC;AAE5D,WAAO,KAAK,MAAM,YAAY;AAAA,EAChC;AAAA,EAEA,IAAI,OAAY;AACd,WAAO,IAAI,IAAI,KAAK,GAAG;AAAA,EACzB;AAAA,EAEQ,YAAY,MAAmB;AACrC,WAAO,CAAC,KAAK,WAAW,GAAG,GAAG,+BAA+B;AAC7D,WAAO,IAAI,IAAI,MAAM,KAAK,GAAG;AAAA,EAC/B;AACF","sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  VirtualFile,\n  HttpSnapIdStruct,\n  NpmSnapFileNames,\n  createSnapManifest,\n  normalizeRelative,\n  parseJson,\n} from '@metamask/snaps-utils';\nimport { assert, assertStruct } from '@metamask/utils';\n\nimport type { SnapLocation } from './location';\n\nexport interface HttpOptions {\n  /**\n   * @default fetch\n   */\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit;\n}\n\nexport class HttpLocation implements SnapLocation {\n  // We keep contents separate because then we can use only one Blob in cache,\n  // which we convert to Uint8Array when actually returning the file.\n  //\n  // That avoids deepCloning file contents.\n  // I imagine ArrayBuffers are copy-on-write optimized, meaning\n  // in most often case we'll only have one file contents in common case.\n  private readonly cache = new Map<\n    string,\n    { file: VirtualFile; contents: Blob }\n  >();\n\n  private validatedManifest?: VirtualFile<SnapManifest>;\n\n  private readonly url: URL;\n\n  private readonly fetchFn: typeof fetch;\n\n  private readonly fetchOptions?: RequestInit;\n\n  constructor(url: URL, opts: HttpOptions = {}) {\n    assertStruct(url.toString(), HttpSnapIdStruct, 'Invalid Snap Id: ');\n    this.fetchFn = opts.fetch ?? globalThis.fetch.bind(globalThis);\n    this.fetchOptions = opts.fetchOptions;\n    this.url = url;\n  }\n\n  async manifest(): Promise<VirtualFile<SnapManifest>> {\n    if (this.validatedManifest) {\n      return this.validatedManifest.clone();\n    }\n\n    // jest-fetch-mock doesn't handle new URL(), we need to convert .toString()\n    const canonicalPath = new URL(\n      NpmSnapFileNames.Manifest,\n      this.url,\n    ).toString();\n\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const contents = await response.text();\n    const manifest = parseJson(contents);\n    const vfile = new VirtualFile<SnapManifest>({\n      value: contents,\n      result: createSnapManifest(manifest),\n      path: NpmSnapFileNames.Manifest,\n      data: { canonicalPath },\n    });\n    this.validatedManifest = vfile;\n\n    return this.manifest();\n  }\n\n  async fetch(path: string): Promise<VirtualFile> {\n    const relativePath = normalizeRelative(path);\n    const cached = this.cache.get(relativePath);\n    if (cached !== undefined) {\n      const { file, contents } = cached;\n      const value = new Uint8Array(await contents.arrayBuffer());\n      const vfile = file.clone();\n      vfile.value = value;\n      return vfile;\n    }\n\n    const canonicalPath = this.toCanonical(relativePath).toString();\n    const response = await this.fetchFn(canonicalPath, this.fetchOptions);\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch \"${canonicalPath}\". Status code: ${response.status}.`,\n      );\n    }\n    const vfile = new VirtualFile({\n      value: '',\n      path: relativePath,\n      data: { canonicalPath },\n    });\n    const blob = await response.blob();\n    assert(\n      !this.cache.has(relativePath),\n      'Corrupted cache, multiple files with same path.',\n    );\n    this.cache.set(relativePath, { file: vfile, contents: blob });\n\n    return this.fetch(relativePath);\n  }\n\n  get root(): URL {\n    return new URL(this.url);\n  }\n\n  private toCanonical(path: string): URL {\n    assert(!path.startsWith('/'), 'Tried to parse absolute path.');\n    return new URL(path, this.url);\n  }\n}\n"]}