{"version":3,"sources":["../src/fsm.ts"],"sourcesContent":["import { assert } from '@metamask/utils';\nimport type { EventObject, StateMachine, Typestate } from '@xstate/fsm';\nimport { InterpreterStatus } from '@xstate/fsm';\n\n/**\n * Validates the set-up of a @xstate/fsm machine.\n *\n * 1. Ensures that all named actions in the config have a provided implementation.\n *\n * @param machine - The machine to validate.\n * @throws {@link AssertionError}. If the validation fails.\n */\nexport function validateMachine<\n  TContext extends object,\n  TEvent extends EventObject,\n  TState extends Typestate<TContext>,\n>(machine: StateMachine.Machine<TContext, TEvent, TState>) {\n  assert('_options' in machine, 'The machine is not an @xstate/fsm machine');\n  const typed = machine as StateMachine.Machine<TContext, TEvent, TState> & {\n    _options: { actions?: StateMachine.ActionMap<TContext, TEvent> };\n  };\n\n  // 1.\n  const toArray = <Type>(obj: Type | Type[]): Type[] => {\n    if (Array.isArray(obj)) {\n      return obj;\n    } else if (obj === undefined || obj === null) {\n      return [];\n    }\n    return [obj];\n  };\n\n  const allActions = new Set<string>();\n  const addActions = (actions: any) =>\n    toArray(actions)\n      .flatMap((action) => {\n        if (typeof action === 'string') {\n          return [action];\n        }\n        assert(typeof action === 'function');\n        return [];\n      })\n      .forEach(allActions.add.bind(allActions));\n\n  for (const state of Object.values<(typeof typed.config.states)[string]>(\n    typed.config.states,\n  )) {\n    addActions(state.entry);\n    addActions(state.exit);\n    for (const transition of Object.values<any>(state.on ?? {})) {\n      addActions(transition.actions);\n    }\n  }\n\n  allActions.forEach((action) =>\n    assert(\n      typed._options.actions !== undefined && action in typed._options.actions,\n      `Action \"${action}\" doesn't have an implementation`,\n    ),\n  );\n}\n\n/**\n * Ensure that the interpreter is strict.\n * Strict means that the transition must occur.\n * The event must exist in .on {} state config and it's guard must succeed.\n *\n * The error will be thrown when an invalid `interpreter.send()` is called\n * and will be bubbled there.\n *\n * TODO(ritave): Doesn't support self transitions.\n *\n * @param interpreter - The interpreter that will be force into strict mode.\n * @throws {@link Error} Thrown when the transition is invalid.\n */\nexport function forceStrict(interpreter: StateMachine.Service<any, any, any>) {\n  // As soon as a listener subscribes, it is called. It might be called in\n  // an initial state which doesn't have the .changed property\n  let onInitialCalled = false;\n  interpreter.subscribe((state) => {\n    assert(!onInitialCalled || state.changed, 'Invalid state transition');\n    onInitialCalled = true;\n  });\n\n  const ogSend = interpreter.send.bind(interpreter);\n  interpreter.send = (...args) => {\n    assert(\n      interpreter.status === InterpreterStatus.Running,\n      'Interpreter is stopped',\n    );\n    return ogSend(...args);\n  };\n}\n"],"mappings":";AAAA,SAAS,cAAc;AAEvB,SAAS,yBAAyB;AAU3B,SAAS,gBAId,SAAyD;AACzD,SAAO,cAAc,SAAS,2CAA2C;AACzE,QAAM,QAAQ;AAKd,QAAM,UAAU,CAAO,QAA+B;AACpD,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO;AAAA,IACT,WAAW,QAAQ,UAAa,QAAQ,MAAM;AAC5C,aAAO,CAAC;AAAA,IACV;AACA,WAAO,CAAC,GAAG;AAAA,EACb;AAEA,QAAM,aAAa,oBAAI,IAAY;AACnC,QAAM,aAAa,CAAC,YAClB,QAAQ,OAAO,EACZ,QAAQ,CAAC,WAAW;AACnB,QAAI,OAAO,WAAW,UAAU;AAC9B,aAAO,CAAC,MAAM;AAAA,IAChB;AACA,WAAO,OAAO,WAAW,UAAU;AACnC,WAAO,CAAC;AAAA,EACV,CAAC,EACA,QAAQ,WAAW,IAAI,KAAK,UAAU,CAAC;AAE5C,aAAW,SAAS,OAAO;AAAA,IACzB,MAAM,OAAO;AAAA,EACf,GAAG;AACD,eAAW,MAAM,KAAK;AACtB,eAAW,MAAM,IAAI;AACrB,eAAW,cAAc,OAAO,OAAY,MAAM,MAAM,CAAC,CAAC,GAAG;AAC3D,iBAAW,WAAW,OAAO;AAAA,IAC/B;AAAA,EACF;AAEA,aAAW;AAAA,IAAQ,CAAC,WAClB;AAAA,MACE,MAAM,SAAS,YAAY,UAAa,UAAU,MAAM,SAAS;AAAA,MACjE,WAAW,MAAM;AAAA,IACnB;AAAA,EACF;AACF;AAeO,SAAS,YAAY,aAAkD;AAG5E,MAAI,kBAAkB;AACtB,cAAY,UAAU,CAAC,UAAU;AAC/B,WAAO,CAAC,mBAAmB,MAAM,SAAS,0BAA0B;AACpE,sBAAkB;AAAA,EACpB,CAAC;AAED,QAAM,SAAS,YAAY,KAAK,KAAK,WAAW;AAChD,cAAY,OAAO,IAAI,SAAS;AAC9B;AAAA,MACE,YAAY,WAAW,kBAAkB;AAAA,MACzC;AAAA,IACF;AACA,WAAO,OAAO,GAAG,IAAI;AAAA,EACvB;AACF;","names":[]}