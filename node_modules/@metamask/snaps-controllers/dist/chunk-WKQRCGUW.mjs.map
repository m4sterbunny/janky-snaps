{"version":3,"sources":["../src/snaps/location/npm.ts"],"sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  createSnapManifest,\n  DEFAULT_REQUESTED_SNAP_VERSION,\n  getTargetVersion,\n  isValidUrl,\n  NpmSnapIdStruct,\n  VirtualFile,\n  normalizeRelative,\n  parseJson,\n} from '@metamask/snaps-utils';\nimport type { SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerVersion,\n  assertStruct,\n  isObject,\n  isValidSemVerVersion,\n} from '@metamask/utils';\nimport { createGunzip } from 'browserify-zlib';\nimport concat from 'concat-stream';\nimport getNpmTarballUrl from 'get-npm-tarball-url';\nimport { pipeline } from 'readable-stream';\nimport type { Readable, Writable } from 'readable-stream';\nimport { ReadableWebToNodeStream } from 'readable-web-to-node-stream';\nimport { extract as tarExtract } from 'tar-stream';\n\nimport type { DetectSnapLocationOptions, SnapLocation } from './location';\n\nexport const DEFAULT_NPM_REGISTRY = new URL('https://registry.npmjs.org');\n\ninterface NpmMeta {\n  registry: URL;\n  packageName: string;\n  requestedRange: SemVerRange;\n  version?: string;\n  fetch: typeof fetch;\n  resolveVersion: (range: SemVerRange) => Promise<SemVerRange>;\n}\nexport interface NpmOptions {\n  /**\n   * @default DEFAULT_REQUESTED_SNAP_VERSION\n   */\n  versionRange?: SemVerRange;\n  /**\n   * Whether to allow custom NPM registries outside of {@link DEFAULT_NPM_REGISTRY}.\n   *\n   * @default false\n   */\n  allowCustomRegistries?: boolean;\n}\n\n// Base class for NPM implementation, useful for extending with custom NPM fetching logic\nexport abstract class BaseNpmLocation implements SnapLocation {\n  protected readonly meta: NpmMeta;\n\n  #validatedManifest?: VirtualFile<SnapManifest>;\n\n  #files?: Map<string, VirtualFile>;\n\n  constructor(url: URL, opts: DetectSnapLocationOptions = {}) {\n    const allowCustomRegistries = opts.allowCustomRegistries ?? false;\n    const fetchFunction = opts.fetch ?? globalThis.fetch.bind(globalThis);\n    const requestedRange = opts.versionRange ?? DEFAULT_REQUESTED_SNAP_VERSION;\n    const defaultResolve = async (range: SemVerRange) => range;\n    const resolveVersion = opts.resolveVersion ?? defaultResolve;\n\n    assertStruct(url.toString(), NpmSnapIdStruct, 'Invalid Snap Id: ');\n\n    let registry: string | URL;\n    if (\n      url.host === '' &&\n      url.port === '' &&\n      url.username === '' &&\n      url.password === ''\n    ) {\n      registry = DEFAULT_NPM_REGISTRY;\n    } else {\n      registry = 'https://';\n      if (url.username) {\n        registry += url.username;\n        if (url.password) {\n          registry += `:${url.password}`;\n        }\n        registry += '@';\n      }\n      registry += url.host;\n      registry = new URL(registry);\n      assert(\n        allowCustomRegistries,\n        new TypeError(\n          `Custom NPM registries are disabled, tried to use \"${registry.toString()}\".`,\n        ),\n      );\n    }\n\n    assert(\n      registry.pathname === '/' &&\n        registry.search === '' &&\n        registry.hash === '',\n    );\n\n    assert(\n      url.pathname !== '' && url.pathname !== '/',\n      new TypeError('The package name in NPM location is empty.'),\n    );\n    let packageName = url.pathname;\n    if (packageName.startsWith('/')) {\n      packageName = packageName.slice(1);\n    }\n\n    this.meta = {\n      requestedRange,\n      registry,\n      packageName,\n      fetch: fetchFunction,\n      resolveVersion,\n    };\n  }\n\n  async manifest(): Promise<VirtualFile<SnapManifest>> {\n    if (this.#validatedManifest) {\n      return this.#validatedManifest.clone();\n    }\n\n    const vfile = await this.fetch('snap.manifest.json');\n    const result = parseJson(vfile.toString());\n    vfile.result = createSnapManifest(result);\n    this.#validatedManifest = vfile as VirtualFile<SnapManifest>;\n\n    return this.manifest();\n  }\n\n  async fetch(path: string): Promise<VirtualFile> {\n    const relativePath = normalizeRelative(path);\n    if (!this.#files) {\n      await this.#lazyInit();\n      assert(this.#files !== undefined);\n    }\n    const vfile = this.#files.get(relativePath);\n    assert(\n      vfile !== undefined,\n      new TypeError(`File \"${path}\" not found in package.`),\n    );\n    return vfile.clone();\n  }\n\n  get packageName(): string {\n    return this.meta.packageName;\n  }\n\n  get version(): string {\n    assert(\n      this.meta.version !== undefined,\n      'Tried to access version without first fetching NPM package.',\n    );\n    return this.meta.version;\n  }\n\n  get registry(): URL {\n    return this.meta.registry;\n  }\n\n  get versionRange(): SemVerRange {\n    return this.meta.requestedRange;\n  }\n\n  async #lazyInit() {\n    assert(this.#files === undefined);\n    const resolvedVersion = await this.meta.resolveVersion(\n      this.meta.requestedRange,\n    );\n\n    const { tarballURL, targetVersion } = await resolveNpmVersion(\n      this.meta.packageName,\n      resolvedVersion,\n      this.meta.registry,\n      this.meta.fetch,\n    );\n\n    if (!isValidUrl(tarballURL) || !tarballURL.toString().endsWith('.tgz')) {\n      throw new Error(\n        `Failed to find valid tarball URL in NPM metadata for package \"${this.meta.packageName}\".`,\n      );\n    }\n\n    // Override the tarball hostname/protocol with registryUrl hostname/protocol\n    const newTarballUrl = new URL(tarballURL);\n    newTarballUrl.hostname = this.meta.registry.hostname;\n    newTarballUrl.protocol = this.meta.registry.protocol;\n\n    const files = await this.fetchNpmTarball(newTarballUrl);\n\n    this.#files = files;\n    this.meta.version = targetVersion;\n  }\n\n  /**\n   * Fetches and unpacks the tarball (`.tgz` file) from the specified URL.\n   *\n   * @param tarballUrl - The tarball URL to fetch and unpack.\n   * @returns A the files for the package tarball.\n   * @throws If fetching the tarball fails.\n   */\n  abstract fetchNpmTarball(tarballUrl: URL): Promise<Map<string, VirtualFile>>;\n}\n\n// Safety limit for tarballs, 250 MB in bytes\nexport const TARBALL_SIZE_SAFETY_LIMIT = 262144000;\n\n// Main NPM implementation, contains a browser tarball fetching implementation.\nexport class NpmLocation extends BaseNpmLocation {\n  /**\n   * Fetches and unpacks the tarball (`.tgz` file) from the specified URL.\n   *\n   * @param tarballUrl - The tarball URL to fetch and unpack.\n   * @returns A the files for the package tarball.\n   * @throws If fetching the tarball fails.\n   */\n  async fetchNpmTarball(\n    tarballUrl: URL,\n  ): Promise<Map<string, VirtualFile<unknown>>> {\n    // Perform a raw fetch because we want the Response object itself.\n    const tarballResponse = await this.meta.fetch(tarballUrl.toString());\n    if (!tarballResponse.ok || !tarballResponse.body) {\n      throw new Error(\n        `Failed to fetch tarball for package \"${this.meta.packageName}\".`,\n      );\n    }\n\n    // We assume that NPM is a good actor and provides us with a valid `content-length` header.\n    const tarballSizeString = tarballResponse.headers.get('content-length');\n    assert(tarballSizeString, 'Snap tarball has invalid content-length');\n    const tarballSize = parseInt(tarballSizeString, 10);\n    assert(\n      tarballSize <= TARBALL_SIZE_SAFETY_LIMIT,\n      'Snap tarball exceeds size limit',\n    );\n    return new Promise((resolve, reject) => {\n      const files = new Map();\n\n      const tarballStream = createTarballStream(\n        getNpmCanonicalBasePath(this.meta.registry, this.meta.packageName),\n        files,\n      );\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const body = tarballResponse.body!;\n\n      // The \"gz\" in \"tgz\" stands for \"gzip\". The tarball needs to be decompressed\n      // before we can actually grab any files from it.\n      // To prevent recursion-based zip bombs, we should not allow recursion here.\n\n      // If native decompression stream is available we use that, otherwise fallback to zlib.\n      if ('pipeThrough' in body && 'DecompressionStream' in globalThis) {\n        const decompressionStream = new DecompressionStream('gzip');\n        const decompressedStream = body.pipeThrough(decompressionStream);\n\n        pipeline(\n          getNodeStream(decompressedStream),\n          tarballStream,\n          (error: unknown) => {\n            error ? reject(error) : resolve(files);\n          },\n        );\n        return;\n      }\n\n      pipeline(\n        getNodeStream(body),\n        createGunzip(),\n        tarballStream,\n        (error: unknown) => {\n          error ? reject(error) : resolve(files);\n        },\n      );\n    });\n  }\n}\n\n// Incomplete type\nexport type PartialNpmMetadata = {\n  versions: Record<string, { dist: { tarball: string } }>;\n};\n\n/**\n * Fetches the NPM metadata of the specified package from\n * the public npm registry.\n *\n * @param packageName - The name of the package whose metadata to fetch.\n * @param registryUrl - The URL of the npm registry to fetch the metadata from.\n * @param fetchFunction - The fetch function to use. Defaults to the global\n * {@link fetch}. Useful for Node.js compatibility.\n * @returns The NPM metadata object.\n * @throws If fetching the metadata fails.\n */\nexport async function fetchNpmMetadata(\n  packageName: string,\n  registryUrl: URL,\n  fetchFunction: typeof fetch,\n): Promise<PartialNpmMetadata> {\n  const packageResponse = await fetchFunction(\n    new URL(packageName, registryUrl).toString(),\n    {\n      headers: {\n        // Corgi format is slightly smaller: https://github.com/npm/pacote/blob/main/lib/registry.js#L71\n        accept: isNPM(registryUrl)\n          ? 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\n          : 'application/json',\n      },\n    },\n  );\n  if (!packageResponse.ok) {\n    throw new Error(\n      `Failed to fetch NPM registry entry. Status code: ${packageResponse.status}.`,\n    );\n  }\n  const packageMetadata = await packageResponse.json();\n\n  if (!isObject(packageMetadata)) {\n    throw new Error(\n      `Failed to fetch package \"${packageName}\" metadata from npm.`,\n    );\n  }\n\n  return packageMetadata as PartialNpmMetadata;\n}\n\n/**\n * Gets the canonical base path for an NPM snap.\n *\n * @param registryUrl - A registry URL.\n * @param packageName - A package name.\n * @returns The canonical base path.\n */\nexport function getNpmCanonicalBasePath(registryUrl: URL, packageName: string) {\n  let canonicalBase = 'npm://';\n  if (registryUrl.username !== '') {\n    canonicalBase += registryUrl.username;\n    if (registryUrl.password !== '') {\n      canonicalBase += `:${registryUrl.password}`;\n    }\n    canonicalBase += '@';\n  }\n  return `${canonicalBase}${registryUrl.host}/${packageName}/`;\n}\n\n/**\n * Determine if a registry URL is NPM.\n *\n * @param registryUrl - A registry url.\n * @returns True if the registry is the NPM registry, otherwise false.\n */\nfunction isNPM(registryUrl: URL) {\n  return registryUrl.toString() === DEFAULT_NPM_REGISTRY.toString();\n}\n\n/**\n * Resolves a version range to a version using the NPM registry.\n *\n * Unless the version range is already a version, then the NPM registry is skipped.\n *\n * @param packageName - The name of the package whose metadata to fetch.\n * @param versionRange - The version range of the package.\n * @param registryUrl - The URL of the npm registry to fetch the metadata from.\n * @param fetchFunction - The fetch function to use. Defaults to the global\n * {@link fetch}. Useful for Node.js compatibility.\n * @returns An object containing the resolved version and a URL for its tarball.\n * @throws If fetching the metadata fails.\n */\nasync function resolveNpmVersion(\n  packageName: string,\n  versionRange: SemVerRange,\n  registryUrl: URL,\n  fetchFunction: typeof fetch,\n): Promise<{ tarballURL: string; targetVersion: SemVerVersion }> {\n  // If the version range is already a static version we don't need to look for the metadata.\n  if (isNPM(registryUrl) && isValidSemVerVersion(versionRange)) {\n    return {\n      tarballURL: getNpmTarballUrl(packageName, versionRange),\n      targetVersion: versionRange,\n    };\n  }\n\n  const packageMetadata = await fetchNpmMetadata(\n    packageName,\n    registryUrl,\n    fetchFunction,\n  );\n\n  const versions = Object.keys(packageMetadata?.versions ?? {}).map(\n    (version) => {\n      assertIsSemVerVersion(version);\n      return version;\n    },\n  );\n\n  const targetVersion = getTargetVersion(versions, versionRange);\n\n  if (targetVersion === null) {\n    throw new Error(\n      `Failed to find a matching version in npm metadata for package \"${packageName}\" and requested semver range \"${versionRange}\".`,\n    );\n  }\n\n  const tarballURL = packageMetadata?.versions?.[targetVersion]?.dist?.tarball;\n\n  return { tarballURL, targetVersion };\n}\n\n/**\n * The paths of files within npm tarballs appear to always be prefixed with\n * \"package/\".\n */\nconst NPM_TARBALL_PATH_PREFIX = /^package\\//u;\n\n/**\n * Converts a {@link ReadableStream} to a Node.js {@link Readable}\n * stream. Returns the stream directly if it is already a Node.js stream.\n * We can't use the native Web {@link ReadableStream} directly because the\n * other stream libraries we use expect Node.js streams.\n *\n * @param stream - The stream to convert.\n * @returns The given stream as a Node.js Readable stream.\n */\nfunction getNodeStream(stream: ReadableStream): Readable {\n  if (typeof stream.getReader !== 'function') {\n    return stream as unknown as Readable;\n  }\n\n  return new ReadableWebToNodeStream(stream);\n}\n\n/**\n * Creates a `tar-stream` that will get the necessary files from an npm Snap\n * package tarball (`.tgz` file).\n *\n * @param canonicalBase - A base URI as specified in {@link https://github.com/MetaMask/SIPs/blob/main/SIPS/sip-8.md SIP-8}. Starting with 'npm:'. Will be used for canonicalPath vfile argument.\n * @param files - An object to write target file contents to.\n * @returns The {@link Writable} tarball extraction stream.\n */\nfunction createTarballStream(\n  canonicalBase: string,\n  files: Map<string, VirtualFile>,\n): Writable {\n  assert(\n    canonicalBase.endsWith('/'),\n    \"Base needs to end with '/' for relative paths to be added as children instead of siblings.\",\n  );\n\n  assert(\n    canonicalBase.startsWith('npm:'),\n    'Protocol mismatch, expected \"npm:\".',\n  );\n  // `tar-stream` is pretty old-school, so we create it first and then\n  // instrument it by adding event listeners.\n  const extractStream = tarExtract();\n\n  let totalSize = 0;\n\n  // \"entry\" is fired for every discreet entity in the tarball. This includes\n  // files and folders.\n  extractStream.on('entry', (header, entryStream, next) => {\n    const { name: headerName, type: headerType } = header;\n    if (headerType === 'file') {\n      // The name is a path if the header type is \"file\".\n      const path = headerName.replace(NPM_TARBALL_PATH_PREFIX, '');\n      return entryStream.pipe(\n        concat({ encoding: 'uint8array' }, (data) => {\n          try {\n            totalSize += data.byteLength;\n            // To prevent zip bombs, we set a safety limit for the total size of tarballs.\n            assert(\n              totalSize < TARBALL_SIZE_SAFETY_LIMIT,\n              `Snap tarball exceeds limit of ${TARBALL_SIZE_SAFETY_LIMIT} bytes.`,\n            );\n            const vfile = new VirtualFile({\n              value: data,\n              path,\n              data: {\n                canonicalPath: new URL(path, canonicalBase).toString(),\n              },\n            });\n            // We disallow files having identical paths as it may confuse our checksum calculations.\n            assert(\n              !files.has(path),\n              'Malformed tarball, multiple files with the same path.',\n            );\n            files.set(path, vfile);\n            return next();\n          } catch (error) {\n            return extractStream.destroy(error);\n          }\n        }),\n      );\n    }\n\n    // If we get here, the entry is not a file, and we want to ignore. The entry\n    // stream must be drained, or the extractStream will stop reading. This is\n    // effectively a no-op for the current entry.\n    entryStream.on('end', () => next());\n    return entryStream.resume();\n  });\n  return extractStream;\n}\n"],"mappings":"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","names":[]}