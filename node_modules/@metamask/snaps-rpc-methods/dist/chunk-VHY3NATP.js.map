{"version":3,"sources":["../src/restricted/caveats/permittedDerivationPaths.ts"],"names":[],"mappings":";AAKA,SAAS,gBAAgB,iBAAiB;AAE1C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,oBAAoB;AAC7B,SAAS,OAAO,MAAM,YAAY;AAU3B,SAAS,qCACd,OACuC;AACvC,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM,eAAe;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAWO,SAAS,kBACd,OAC+B;AAC/B;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ;AACF;AASO,SAAS,yBACd,QACkD;AAClD;AAAA,IACE;AAAA,IACA,KAAK,EAAE,OAAO,KAAK,MAAM,kBAAkB,GAAG,GAAG,QAAQ,EAAE,CAAC;AAAA,IAC5D;AAAA,IACA,UAAU;AAAA,EACZ;AACF;AAEO,IAAM,8CAGT;AAAA,EACF,CAAC,eAAe,wBAAwB,GAAG,OAAO,OAAO;AAAA,IACvD,MAAM,eAAe;AAAA,IACrB,WAAW,CACT,QACA,WACG;AACH,aAAO,OAAO,SAAS;AACrB,cAAM,EAAE,OAAO,IAAI;AACnB,0BAAkB,MAAM;AAExB,cAAM,OAAO,OAAO,MAAM;AAAA,UACxB,CAAC,eACC;AAAA,YACE,OAAO,KAAK,MAAM,GAAG,WAAW,KAAK,MAAM;AAAA,YAC3C,WAAW;AAAA,UACb,KAAK,WAAW,UAAU,OAAO;AAAA,QACrC;AAEA,YAAI,CAAC,MAAM;AACT,gBAAM,eAAe,aAAa;AAAA,YAChC,SACE;AAAA,UACJ,CAAC;AAAA,QACH;AAEA,eAAO,MAAM,OAAO,IAAI;AAAA,MAC1B;AAAA,IACF;AAAA,IACA,WAAW,CAAC,WAAW,yBAAyB,MAAM;AAAA,EACxD,CAAC;AACH","sourcesContent":["import type {\n  Caveat,\n  PermissionConstraint,\n  RestrictedMethodCaveatSpecificationConstraint,\n} from '@metamask/permission-controller';\nimport { providerErrors, rpcErrors } from '@metamask/rpc-errors';\nimport type { Bip32Entropy } from '@metamask/snaps-utils';\nimport {\n  SnapCaveatType,\n  Bip32EntropyStruct,\n  isEqual,\n} from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\nimport { assertStruct } from '@metamask/utils';\nimport { array, size, type } from 'superstruct';\n\n/**\n * Map a raw value from the `initialPermissions` to a caveat specification.\n * Note that this function does not do any validation, that's handled by the\n * PermissionsController when the permission is requested.\n *\n * @param value - The raw value from the `initialPermissions`.\n * @returns The caveat specification.\n */\nexport function permittedDerivationPathsCaveatMapper(\n  value: Json,\n): Pick<PermissionConstraint, 'caveats'> {\n  return {\n    caveats: [\n      {\n        type: SnapCaveatType.PermittedDerivationPaths,\n        value,\n      },\n    ],\n  };\n}\n\n/**\n * Validate a caveat path object. The object must consist of a `path` array and\n * a `curve` string. Paths must start with `m`, and must contain at\n * least two indices. If `ed25519` is used, this checks if all the path indices\n * are hardened.\n *\n * @param value - The value to validate.\n * @throws If the value is invalid.\n */\nexport function validateBIP32Path(\n  value: unknown,\n): asserts value is Bip32Entropy {\n  assertStruct(\n    value,\n    Bip32EntropyStruct,\n    'Invalid BIP-32 entropy path definition',\n    rpcErrors.invalidParams,\n  );\n}\n\n/**\n * Validate the path values associated with a caveat. This validates that the\n * value is a non-empty array with valid derivation paths and curves.\n *\n * @param caveat - The caveat to validate.\n * @throws If the value is invalid.\n */\nexport function validateBIP32CaveatPaths(\n  caveat: Caveat<string, any>,\n): asserts caveat is Caveat<string, Bip32Entropy[]> {\n  assertStruct(\n    caveat,\n    type({ value: size(array(Bip32EntropyStruct), 1, Infinity) }),\n    'Invalid BIP-32 entropy caveat',\n    rpcErrors.internal,\n  );\n}\n\nexport const PermittedDerivationPathsCaveatSpecification: Record<\n  SnapCaveatType.PermittedDerivationPaths,\n  RestrictedMethodCaveatSpecificationConstraint\n> = {\n  [SnapCaveatType.PermittedDerivationPaths]: Object.freeze({\n    type: SnapCaveatType.PermittedDerivationPaths,\n    decorator: (\n      method,\n      caveat: Caveat<SnapCaveatType.PermittedDerivationPaths, Bip32Entropy[]>,\n    ) => {\n      return async (args) => {\n        const { params } = args;\n        validateBIP32Path(params);\n\n        const path = caveat.value.find(\n          (caveatPath) =>\n            isEqual(\n              params.path.slice(0, caveatPath.path.length),\n              caveatPath.path,\n            ) && caveatPath.curve === params.curve,\n        );\n\n        if (!path) {\n          throw providerErrors.unauthorized({\n            message:\n              'The requested path is not permitted. Allowed paths must be specified in the snap manifest.',\n          });\n        }\n\n        return await method(args);\n      };\n    },\n    validator: (caveat) => validateBIP32CaveatPaths(caveat),\n  }),\n};\n"]}