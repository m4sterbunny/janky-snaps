{"version":3,"sources":["../src/restricted/caveats/snapIds.ts"],"names":[],"mappings":";AAOA,SAAS,iBAAiB;AAE1B,SAAS,gBAAgB,qBAAqB;AAE9C,SAAS,aAAa,oBAAoB;AAC1C,SAAS,YAAY;AAYd,SAAS,oBACd,OACuC;AACvC,SAAO;AAAA,IACL,SAAS;AAAA,MACP;AAAA,QACE,MAAM,eAAe;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAQO,SAAS,sBACd,QAC2C;AAC3C;AAAA,IACE;AAAA,IACA,KAAK;AAAA,MACH,OAAO;AAAA,IACT,CAAC;AAAA,IACD;AAAA,IACA,UAAU;AAAA,EACZ;AACF;AAEO,IAAM,6BAGT;AAAA,EACF,CAAC,eAAe,OAAO,GAAG,OAAO,OAAO;AAAA,IACtC,MAAM,eAAe;AAAA,IACrB,WAAW,CAAC,WAAW,sBAAsB,MAAM;AAAA,IACnD,WAAW,CAAC,QAAQ,WAAW;AAC7B,aAAO,OAAO,SAAS;AACrB,cAAM;AAAA,UACJ;AAAA,UACA,SAAS,EAAE,OAAO;AAAA,QACpB,IAAyD;AACzD,cAAM,UAAU,OAAO;AACvB,cAAM,EAAE,OAAO,IAAI;AACnB,YAAI,CAAC,YAAY,SAAS,MAAM,GAAG;AACjC,gBAAM,IAAI;AAAA,YACR,GAAG,MAAM,uCAAuC,MAAM;AAAA,UACxD;AAAA,QACF;AACA,eAAO,MAAM,OAAO,IAAI;AAAA,MAC1B;AAAA,IACF;AAAA,EACF,CAAC;AACH","sourcesContent":["import type {\n  Caveat,\n  RestrictedMethodOptions,\n  RestrictedMethodParameters,\n  RestrictedMethodCaveatSpecificationConstraint,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { SnapIds } from '@metamask/snaps-utils';\nimport { SnapCaveatType, SnapIdsStruct } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\nimport { hasProperty, assertStruct } from '@metamask/utils';\nimport { type } from 'superstruct';\n\nimport type { InvokeSnapParams } from '../invokeSnap';\n\n/**\n * Map a raw value from the `initialPermissions` to a caveat specification.\n * Note that this function does not do any validation, that's handled by the\n * PermissionsController when the permission is requested.\n *\n * @param value - The raw value from the `initialPermissions`.\n * @returns The caveat specification.\n */\nexport function snapIdsCaveatMapper(\n  value: Json,\n): Pick<PermissionConstraint, 'caveats'> {\n  return {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds,\n        value,\n      },\n    ],\n  };\n}\n\n/**\n * Validates that the caveat value exists and is a non-empty object.\n *\n * @param caveat - The caveat to validate.\n * @throws If the caveat is invalid.\n */\nexport function validateSnapIdsCaveat(\n  caveat: Caveat<string, any>,\n): asserts caveat is Caveat<string, SnapIds> {\n  assertStruct(\n    caveat,\n    type({\n      value: SnapIdsStruct,\n    }),\n    'Expected caveat to have a value property of a non-empty object of snap IDs.',\n    rpcErrors.invalidParams,\n  );\n}\n\nexport const SnapIdsCaveatSpecification: Record<\n  SnapCaveatType.SnapIds,\n  RestrictedMethodCaveatSpecificationConstraint\n> = {\n  [SnapCaveatType.SnapIds]: Object.freeze({\n    type: SnapCaveatType.SnapIds,\n    validator: (caveat) => validateSnapIdsCaveat(caveat),\n    decorator: (method, caveat) => {\n      return async (args) => {\n        const {\n          params,\n          context: { origin },\n        }: RestrictedMethodOptions<RestrictedMethodParameters> = args;\n        const snapIds = caveat.value;\n        const { snapId } = params as InvokeSnapParams;\n        if (!hasProperty(snapIds, snapId)) {\n          throw new Error(\n            `${origin} does not have permission to invoke ${snapId} snap.`,\n          );\n        }\n        return await method(args);\n      };\n    },\n  }),\n};\n"]}