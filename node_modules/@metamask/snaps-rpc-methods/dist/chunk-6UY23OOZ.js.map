{"version":3,"sources":["../src/permitted/middleware.ts"],"names":[],"mappings":";;;;;;;;AACA,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AAalB,SAAS,4BACd,QACA,OACwC;AAGxC,SAAO,eAAe,iBAAiB,SAAS,UAAU,MAAM,KAAK;AACnE,UAAM,UACJ,eAAe,QAAQ,MAAqC;AAC9D,QAAI,SAAS;AACX,UACE,OAAO,UAAU,WAAW,KAAK,QAAQ,QAAQ,OAAO,KACxD,CAAC,QACD;AACA,eAAO,IAAI,UAAU,eAAe,CAAC;AAAA,MACvC;AAGA,YAAM,EAAE,gBAAgB,UAAU,IAAI;AACtC,UAAI;AAEF,eAAO,MAAM;AAAA,UACX;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,YAAY,OAAO,SAAS;AAAA,QAC9B;AAAA,MACF,SAAS,OAAO;AACd,iBAAS,KAAK;AACd,eAAO,IAAI,KAAK;AAAA,MAClB;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AACF","sourcesContent":["import type { JsonRpcMiddleware } from '@metamask/json-rpc-engine';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport { logError } from '@metamask/snaps-utils';\nimport type { Json, JsonRpcParams } from '@metamask/utils';\n\nimport { selectHooks } from '../utils';\nimport { methodHandlers } from './handlers';\n\n/**\n * Creates a middleware that handles permitted snap RPC methods.\n *\n * @param isSnap - A flag that should indicate whether the requesting origin is a snap or not.\n * @param hooks - An object containing the hooks made available to the permitted RPC methods.\n * @returns The middleware.\n */\nexport function createSnapsMethodMiddleware(\n  isSnap: boolean,\n  hooks: Record<string, unknown>,\n): JsonRpcMiddleware<JsonRpcParams, Json> {\n  // This is not actually a misused promise, the type is just wrong\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return async function methodMiddleware(request, response, next, end) {\n    const handler =\n      methodHandlers[request.method as keyof typeof methodHandlers];\n    if (handler) {\n      if (\n        String.prototype.startsWith.call(request.method, 'snap_') &&\n        !isSnap\n      ) {\n        return end(rpcErrors.methodNotFound());\n      }\n\n      // TODO: Once json-rpc-engine types are up to date, we should type this correctly\n      const { implementation, hookNames } = handler as any;\n      try {\n        // Implementations may or may not be async, so we must await them.\n        return await implementation(\n          request,\n          response,\n          next,\n          end,\n          selectHooks(hooks, hookNames),\n        );\n      } catch (error) {\n        logError(error);\n        return end(error);\n      }\n    }\n\n    return next();\n  };\n}\n"]}