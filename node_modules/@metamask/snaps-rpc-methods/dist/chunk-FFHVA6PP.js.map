{"version":3,"sources":["../src/restricted/invokeSnap.ts"],"names":["methodHooks"],"mappings":";AAOA,SAAS,sBAAsB;AAC/B,SAAS,iBAAiB;AAO1B,SAAS,aAAa,sBAAsB;AAKrC,IAAM,6BAA6B;AAwDnC,IAAM,oBAGM,OAAO,EAAE,aAAa,gBAAgB,MAAM;AAC7D,QAAM,QAAQ,YAAY,YAAY,0BAA0B,EAAE,UAAU,CAAC,EAC1E;AAEH,QAAM,iBAAiB,gBAAgB;AAAA,IACrC;AAAA,IACA,YAAY,SAAS;AAAA,EACvB;AAEA,QAAM,eAAe,OAAO,KAAK,KAAK,EAAE;AAAA,IACtC,CAAC,eAAe,SAAS;AACvB,UAAI,CAAC,eAAe,IAAI,GAAG;AACzB,sBAAc,IAAI,IAAI,MAAM,IAAI;AAAA,MAClC;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO,gBAAgB;AAAA,IACrB;AAAA,IACA,YAAY,SAAS;AAAA,IACrB;AAAA,EACF;AACF;AAaA,IAAM,uBAIF,CAAC,EAAE,aAAAA,aAAY,MAA6C;AAC9D,SAAO;AAAA,IACL,gBAAgB,eAAe;AAAA,IAC/B,YAAY;AAAA,IACZ,gBAAgB,CAAC,eAAe,OAAO;AAAA,IACvC,sBAAsB,4BAA4BA,YAAW;AAAA,IAC7D,WAAW,CAAC,EAAE,QAAQ,MAAM;AAC1B,UAAI,SAAS,WAAW,KAAK,QAAQ,CAAC,EAAE,SAAS,eAAe,SAAS;AACvE,cAAM,UAAU,cAAc;AAAA,UAC5B,SAAS,sBAAsB,eAAe,OAAO;AAAA,QACvD,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,YAAY;AAAA,MACV,aAAa;AAAA,IACf;AAAA,EACF;AACF;AAEA,IAAM,cAAwD;AAAA,EAC5D,SAAS;AAAA,EACT,sBAAsB;AACxB;AAEO,IAAM,oBAAoB,OAAO,OAAO;AAAA,EAC7C,YAAY;AAAA,EACZ;AAAA,EACA;AACF,CAAU;AAWH,SAAS,4BAA4B;AAAA,EAC1C;AAAA,EACA;AACF,GAA0B;AACxB,SAAO,eAAe,WACpB,SAC2B;AAC3B,UAAM,EAAE,SAAS,CAAC,GAAG,QAAQ,IAAI;AAEjC,UAAM,EAAE,QAAQ,QAAQ,IAAI;AAE5B,QAAI,CAAC,QAAQ,MAAM,GAAG;AACpB,YAAM,UAAU,eAAe;AAAA,QAC7B,SAAS,aAAa,MAAM;AAAA,MAC9B,CAAC;AAAA,IACH;AAEA,UAAM,EAAE,OAAO,IAAI;AAEnB,WAAQ,MAAM,qBAAqB;AAAA,MACjC;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,YAAY;AAAA,IACvB,CAAC;AAAA,EACH;AACF","sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport { PermissionType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  InvokeSnapResult,\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { Snap, SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { HandlerType, SnapCaveatType } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => RequestSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  getSnap: (snapId: string) => Snap | undefined;\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: string }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, Json>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messagingSystem - The messenger to call an action.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messagingSystem }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestSnapsParams;\n\n  const permittedSnaps = messagingSystem.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestSnapsParams>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messagingSystem.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  getSnap: true,\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.getSnap - A function that retrieves all information stored about a snap.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  getSnap,\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<InvokeSnapParams>,\n  ): Promise<InvokeSnapResult> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    if (!getSnap(snapId)) {\n      throw rpcErrors.invalidRequest({\n        message: `The snap \"${snapId}\" is not installed. Please install it first, before invoking the snap.`,\n      });\n    }\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}