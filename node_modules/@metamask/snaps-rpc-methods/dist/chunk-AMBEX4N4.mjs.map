{"version":3,"sources":["../src/permissions.ts"],"sourcesContent":["import type {\n  PermissionConstraint,\n  PermissionSpecificationConstraint,\n} from '@metamask/permission-controller';\nimport type { SnapPermissions } from '@metamask/snaps-utils';\nimport { hasProperty } from '@metamask/utils';\n\nimport {\n  endowmentCaveatMappers,\n  endowmentPermissionBuilders,\n} from './endowments';\nimport {\n  caveatMappers,\n  restrictedMethodPermissionBuilders,\n} from './restricted';\nimport { selectHooks } from './utils';\n\n/**\n * Map initial permissions as defined in a Snap manifest to something that can\n * be processed by the PermissionsController. Each caveat mapping function\n * should return a valid permission caveat value.\n *\n * This function does not validate the caveat values, since that is done by\n * the PermissionsController itself, upon requesting the permissions.\n *\n * @param initialPermissions - The initial permissions to process.\n * @returns The processed permissions.\n */\nexport function processSnapPermissions(\n  initialPermissions: SnapPermissions,\n): Record<string, Pick<PermissionConstraint, 'caveats'>> {\n  return Object.fromEntries(\n    Object.entries(initialPermissions).map(([initialPermission, value]) => {\n      if (hasProperty(caveatMappers, initialPermission)) {\n        return [initialPermission, caveatMappers[initialPermission](value)];\n      } else if (hasProperty(endowmentCaveatMappers, initialPermission)) {\n        return [\n          initialPermission,\n          endowmentCaveatMappers[initialPermission](value),\n        ];\n      }\n\n      // If we have no mapping, this may be a non-snap permission, return as-is\n      return [\n        initialPermission,\n        value as Pick<PermissionConstraint, 'caveats'>,\n      ];\n    }),\n  );\n}\n\nexport const buildSnapEndowmentSpecifications = (\n  excludedEndowments: string[],\n) =>\n  Object.values(endowmentPermissionBuilders).reduce<\n    Record<string, PermissionSpecificationConstraint>\n  >((allSpecifications, { targetName, specificationBuilder }) => {\n    if (!excludedEndowments.includes(targetName)) {\n      allSpecifications[targetName] = specificationBuilder({});\n    }\n    return allSpecifications;\n  }, {});\n\nexport const buildSnapRestrictedMethodSpecifications = (\n  excludedPermissions: string[],\n  hooks: Record<string, unknown>,\n) =>\n  Object.values(restrictedMethodPermissionBuilders).reduce<\n    Record<string, PermissionSpecificationConstraint>\n  >((specifications, { targetName, specificationBuilder, methodHooks }) => {\n    if (!excludedPermissions.includes(targetName)) {\n      specifications[targetName] = specificationBuilder({\n        // @ts-expect-error The selectHooks type is wonky\n        methodHooks: selectHooks<typeof hooks, keyof typeof methodHooks>(\n          hooks,\n          methodHooks,\n        ) as Pick<typeof hooks, keyof typeof methodHooks>,\n      });\n    }\n    return specifications;\n  }, {});\n"],"mappings":";;;;;;;;;;;;;;;AAKA,SAAS,mBAAmB;AAuBrB,SAAS,uBACd,oBACuD;AACvD,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,kBAAkB,EAAE,IAAI,CAAC,CAAC,mBAAmB,KAAK,MAAM;AACrE,UAAI,YAAY,eAAe,iBAAiB,GAAG;AACjD,eAAO,CAAC,mBAAmB,cAAc,iBAAiB,EAAE,KAAK,CAAC;AAAA,MACpE,WAAW,YAAY,wBAAwB,iBAAiB,GAAG;AACjE,eAAO;AAAA,UACL;AAAA,UACA,uBAAuB,iBAAiB,EAAE,KAAK;AAAA,QACjD;AAAA,MACF;AAGA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,mCAAmC,CAC9C,uBAEA,OAAO,OAAO,2BAA2B,EAAE,OAEzC,CAAC,mBAAmB,EAAE,YAAY,qBAAqB,MAAM;AAC7D,MAAI,CAAC,mBAAmB,SAAS,UAAU,GAAG;AAC5C,sBAAkB,UAAU,IAAI,qBAAqB,CAAC,CAAC;AAAA,EACzD;AACA,SAAO;AACT,GAAG,CAAC,CAAC;AAEA,IAAM,0CAA0C,CACrD,qBACA,UAEA,OAAO,OAAO,kCAAkC,EAAE,OAEhD,CAAC,gBAAgB,EAAE,YAAY,sBAAsB,YAAY,MAAM;AACvE,MAAI,CAAC,oBAAoB,SAAS,UAAU,GAAG;AAC7C,mBAAe,UAAU,IAAI,qBAAqB;AAAA;AAAA,MAEhD,aAAa;AAAA,QACX;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT,GAAG,CAAC,CAAC;","names":[]}