{"version":3,"sources":["../src/endowments/caveats/generic.ts"],"names":[],"mappings":";AAIA,SAAS,iBAAiB;AAkBnB,SAAS,iCACd,mBAI+B;AAC/B,QAAM,mBAAmB,IAAI;AAAA,IAC3B,kBAAkB,IAAI,CAAC,WAAW,OAAO,IAAI;AAAA,EAC/C;AACA,QAAM,kBAAkB,kBAAkB;AAAA,IACxC,CAAC,WAAW,CAAC,OAAO;AAAA,EACtB;AAEA,SAAO,SAAU,EAAE,QAAQ,GAAG;AAC5B,UAAM,gBAAgB,WAAW,CAAC;AAClC,UAAM,oBAAoB,cAAc,IAAI,CAAC,WAAW,OAAO,IAAI;AACnE,UAAM,mBAAmB,IAAI,IAAI,iBAAiB;AAGlD,QAAI,iBAAiB,SAAS,kBAAkB,QAAQ;AACtD,YAAM,UAAU,cAAc;AAAA,QAC5B,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAGA,QAAI,CAAC,cAAc,MAAM,CAAC,WAAW,iBAAiB,IAAI,OAAO,IAAI,CAAC,GAAG;AACvE,YAAM,UAAU,cAAc;AAAA,QAC5B,SAAS,mCAAmC,kBACzC,IAAI,CAAC,WAAW,IAAI,OAAO,IAAI,GAAG,EAClC,KAAK,IAAI,CAAC,cAAc,cACxB,IAAI,CAAC,WAAW,IAAI,OAAO,IAAI,GAAG,EAClC,KAAK,IAAI,CAAC;AAAA,MACf,CAAC;AAAA,IACH;AAGA,QAAI,CAAC,gBAAgB,MAAM,CAAC,WAAW,iBAAiB,IAAI,OAAO,IAAI,CAAC,GAAG;AACzE,YAAM,UAAU,cAAc;AAAA,QAC5B,SAAS,mCAAmC,gBACzC,IAAI,CAAC,WAAW,IAAI,OAAO,IAAI,GAAG,EAClC,KAAK,IAAI,CAAC;AAAA,MACf,CAAC;AAAA,IACH;AAAA,EACF;AACF","sourcesContent":["import type {\n  PermissionConstraint,\n  PermissionValidatorConstraint,\n} from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nexport type CaveatMapperReturnValue = Pick<PermissionConstraint, 'caveats'>;\n\nexport type CaveatMapperFunction = (value: Json) => CaveatMapperReturnValue;\n\n/**\n * Create a generic permission validator that validates the presence of certain caveats.\n *\n * This validator only validates the types of the caveats, not the values.\n *\n * @param caveatsToValidate - A list of objects that represent caveats.\n * @param caveatsToValidate.type - The string defining the caveat type.\n * @param caveatsToValidate.optional - An optional boolean flag that defines\n * whether the caveat is optional or not.\n * @returns A function that validates a permission.\n */\nexport function createGenericPermissionValidator(\n  caveatsToValidate: {\n    type: string;\n    optional?: boolean;\n  }[],\n): PermissionValidatorConstraint {\n  const validCaveatTypes = new Set(\n    caveatsToValidate.map((caveat) => caveat.type),\n  );\n  const requiredCaveats = caveatsToValidate.filter(\n    (caveat) => !caveat.optional,\n  );\n\n  return function ({ caveats }) {\n    const actualCaveats = caveats ?? [];\n    const passedCaveatTypes = actualCaveats.map((caveat) => caveat.type);\n    const passedCaveatsSet = new Set(passedCaveatTypes);\n\n    // Disallow duplicates\n    if (passedCaveatsSet.size !== passedCaveatTypes.length) {\n      throw rpcErrors.invalidParams({\n        message: 'Duplicate caveats are not allowed.',\n      });\n    }\n\n    // Disallow caveats that don't match expected types\n    if (!actualCaveats.every((caveat) => validCaveatTypes.has(caveat.type))) {\n      throw rpcErrors.invalidParams({\n        message: `Expected the following caveats: ${caveatsToValidate\n          .map((caveat) => `\"${caveat.type}\"`)\n          .join(', ')}, received ${actualCaveats\n          .map((caveat) => `\"${caveat.type}\"`)\n          .join(', ')}.`,\n      });\n    }\n\n    // Fail if not all required caveats are specified\n    if (!requiredCaveats.every((caveat) => passedCaveatsSet.has(caveat.type))) {\n      throw rpcErrors.invalidParams({\n        message: `Expected the following caveats: ${requiredCaveats\n          .map((caveat) => `\"${caveat.type}\"`)\n          .join(', ')}.`,\n      });\n    }\n  };\n}\n"]}