{"version":3,"sources":["../src/errors.ts","../src/internals/error-wrappers.ts","../src/internals/errors.ts","../src/internals/structs.ts","../src/internals/svg.ts","../src/index.ts","../src/error-wrappers.ts","../src/images.ts","../src/ui/components/address.ts","../src/ui/builder.ts","../src/ui/nodes.ts","../src/ui/components/copyable.ts","../src/ui/components/divider.ts","../src/ui/components/heading.ts","../src/ui/components/image.ts","../src/ui/components/panel.ts","../src/ui/components/button.ts","../src/ui/components/form.ts","../src/ui/components/input.ts","../src/ui/components/row.ts","../src/ui/components/text.ts","../src/ui/components/spinner.ts","../src/ui/component.ts","../src/types/handlers/transaction.ts","../src/types/handlers/user-input.ts","../src/types/methods/dialog.ts","../src/types/methods/get-file.ts","../src/types/methods/manage-state.ts","../src/types/methods/notify.ts","../src/types/interface.ts"],"sourcesContent":["import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n","import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import { assert, hasProperty, isObject } from '@metamask/utils';\nimport { XMLParser } from 'fast-xml-parser';\n\n/**\n * Parse and validate a string as an SVG.\n *\n * @param svg - An SVG string.\n * @returns The SVG, its attributes and children in an object format.\n */\nexport function parseSvg(svg: string) {\n  try {\n    const trimmed = svg.trim();\n\n    assert(trimmed.length > 0);\n\n    const parser = new XMLParser({\n      ignoreAttributes: false,\n      parseAttributeValue: true,\n    });\n    const parsed = parser.parse(trimmed, true);\n\n    assert(hasProperty(parsed, 'svg'));\n\n    // Empty SVGs are not returned as objects\n    if (!isObject(parsed.svg)) {\n      return {};\n    }\n\n    return parsed.svg;\n  } catch {\n    throw new Error('Snap icon must be a valid SVG.');\n  }\n}\n\n/**\n * Validate that a string is a valid SVG.\n *\n * @param svg - An SVG string.\n * @returns True if the SVG is valid otherwise false.\n */\nexport function isSvg(svg: string) {\n  try {\n    parseSvg(svg);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n  parseSvg,\n  isSvg,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n","import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n","import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n","import { HexChecksumAddressStruct } from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n","import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from 'superstruct';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n","import type { Infer } from 'superstruct';\nimport { assign, object, string, unknown } from 'superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, refine, string } from 'superstruct';\n\nimport { isSvg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    if (!isSvg(value)) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n","import type { Infer, Struct } from 'superstruct';\nimport { array, assign, lazy, literal, object, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport { array, assign, literal, object, string, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string, optional, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n","import { assertStruct } from '@metamask/utils';\nimport { is } from 'superstruct';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n","import type { EnumToUnion } from '../../internals';\nimport type { Component } from '../../ui';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: Component;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  literal,\n  object,\n  optional,\n  record,\n  string,\n  union,\n} from 'superstruct';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), string()),\n    name: string(),\n  }),\n);\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: string(),\n  }),\n);\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an {@link UserInputEventType.FormSubmitEvent} is fired.\n * It contains the form values submitted.\n */\ntype UserInputEvent = Infer<typeof UserInputEventStruct>;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n}) => Promise<void>;\n","import type { EnumToUnion } from '../../internals';\nimport type { Component } from '../../ui';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: Component;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: Component;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: Component;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams = AlertDialog | ConfirmationDialog | PromptDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n","import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n","import type { Infer } from 'superstruct';\nimport { nullable, record, string, union } from 'superstruct';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we have to differentiate the state of\n * a form (that will be contained inside the root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const FormStateStruct = record(string(), nullable(string()));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(string())]),\n);\n\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n"],"mappings":"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","names":["error","hasProperty","isObject","svg","assert","assert","assign","literal","object","node","NodeType","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","string","string","assign","object","literal","array","assign","literal","object","union","assign","literal","object","optional","string","union","ButtonVariant","ButtonType","assign","object","literal","string","optional","union","assign","literal","object","string","union","assign","literal","object","optional","string","union","InputType","assign","object","literal","optional","string","union","union","assign","object","literal","string","assign","literal","object","string","optional","union","assign","boolean","literal","object","optional","string","assign","object","literal","string","optional","boolean","RowVariant","union","assign","object","literal","optional","string","assign","literal","object","assign","object","literal","assign","object","array","literal","union","assertStruct","assertStruct","assert","SeverityLevel","assign","literal","object","optional","string","union","UserInputEventType","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","record","string","union"]}