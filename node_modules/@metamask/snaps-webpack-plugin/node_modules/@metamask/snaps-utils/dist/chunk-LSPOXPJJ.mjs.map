{"version":3,"sources":["../src/eval.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,cAAc;AACvB,SAAS,YAAY;AACrB,SAAS,YAAY;AASd,IAAM,gBAAN,cAA4B,MAAM;AAAA,EAGvC,YAAY,SAAiB,QAAoB;AAC/C,UAAM,OAAO;AAEb,SAAK,OAAO;AACZ,SAAK,SAAS;AAAA,EAChB;AACF;AASA,eAAsB,WAAW,YAAyC;AACxE,QAAM,iBAAiB,UAAU;AAEjC,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,SAAS,KAAK,KAAK,WAAW,gBAAgB,GAAG,CAAC,UAAU,GAAG;AAAA;AAAA;AAAA,MAGnE,OAAO;AAAA,IACT,CAAC;AAED,QAAI,SAAS;AACb,QAAI,SAAS;AAEb,WAAO,OAAO,QAAQ,6BAA6B;AACnD,WAAO,OAAO,QAAQ,6BAA6B;AAEnD,WAAO,OAAO,GAAG,QAAQ,CAAC,SAAiB;AACzC,gBAAU,KAAK,SAAS;AAAA,IAC1B,CAAC;AAED,WAAO,OAAO,GAAG,QAAQ,CAAC,SAAiB;AACzC,gBAAU,KAAK,SAAS;AAAA,IAC1B,CAAC;AAED,WAAO,GAAG,QAAQ,CAAC,aAAqB;AACtC,YAAM,SAAS;AAAA,QACb;AAAA,QACA;AAAA,MACF;AAEA,UAAI,aAAa,GAAG;AAClB,eAAO,QAAQ,MAAM;AAAA,MACvB;AAEA,aAAO;AAAA,QACL,IAAI;AAAA,UACF,2CAA2C,QAAQ;AAAA,UACnD;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH","sourcesContent":["import { assert } from '@metamask/utils';\nimport { fork } from 'child_process';\nimport { join } from 'path';\n\nimport { validateFilePath } from './fs';\n\nexport type EvalOutput = {\n  stdout: string;\n  stderr: string;\n};\n\nexport class SnapEvalError extends Error {\n  readonly output: EvalOutput;\n\n  constructor(message: string, output: EvalOutput) {\n    super(message);\n\n    this.name = 'SnapEvalError';\n    this.output = output;\n  }\n}\n\n/**\n * Spawn a new process to run the provided bundle in.\n *\n * @param bundlePath - The path to the bundle to run.\n * @returns `null` if the worker ran successfully.\n * @throws If the worker failed to run successfully.\n */\nexport async function evalBundle(bundlePath: string): Promise<EvalOutput> {\n  await validateFilePath(bundlePath);\n\n  return new Promise((resolve, reject) => {\n    const worker = fork(join(__dirname, 'eval-worker.js'), [bundlePath], {\n      // To avoid printing the output of the worker to the console, we set\n      // `stdio` to `pipe` and handle the output ourselves.\n      stdio: 'pipe',\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    assert(worker.stdout, '`stdout` should be defined.');\n    assert(worker.stderr, '`stderr` should be defined.');\n\n    worker.stdout.on('data', (data: Buffer) => {\n      stdout += data.toString();\n    });\n\n    worker.stderr.on('data', (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    worker.on('exit', (exitCode: number) => {\n      const output = {\n        stdout,\n        stderr,\n      };\n\n      if (exitCode === 0) {\n        return resolve(output);\n      }\n\n      return reject(\n        new SnapEvalError(\n          `Process exited with non-zero exit code: ${exitCode}.`,\n          output,\n        ),\n      );\n    });\n  });\n}\n"]}