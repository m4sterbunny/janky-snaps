{"version":3,"sources":["../src/common/commands.ts"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,mBAAmB;AAC5B,SAAS,wBAAwB;AAiC1B,SAAS,oBACd,QACA,SACA,SACgB;AAGhB,UAAQ,SAAS;AAAA,IACf,KAAK,YAAY,eAAe;AAC9B,4CAAsC,QAAQ,MAAM;AAEpD,YAAM,EAAE,aAAa,SAAS,kBAAkB,IAAI,QAAQ;AAC5D,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,IACA,KAAK,YAAY,aAAa;AAC5B,0CAAoC,QAAQ,MAAM;AAElD,YAAM,EAAE,WAAW,gBAAgB,IAAI,QAAQ;AAC/C,aAAO,EAAE,WAAW,gBAAgB;AAAA,IACtC;AAAA,IACA,KAAK,YAAY,cAAc;AAC7B,2CAAqC,QAAQ,MAAM;AAInD,YAAM,EAAE,SAAS,QAAQ,QAAQ,IAC/B,QAAQ;AAEV,aAAO,SACH;AAAA,QACE;AAAA,QACA;AAAA,MACF,IACA;AAAA,QACE;AAAA,QACA;AAAA,MACF;AAAA,IACN;AAAA,IACA,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAO,EAAE,QAAQ,QAAQ;AAAA,IAE3B,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AAAA,IACjB,KAAK,YAAY;AACf,aAAO,EAAE,QAAQ;AAAA,IAEnB,KAAK,YAAY;AACf,aAAO,CAAC;AAAA,IACV,KAAK,YAAY,aAAa;AAC5B,0CAAoC,QAAQ,MAAM;AAElD,YAAM,EAAE,IAAI,MAAM,IAAI,QAAQ;AAC9B,aAAO,EAAE,IAAI,MAAM;AAAA,IACrB;AAAA,IAEA;AACE,aAAO,iBAAiB,OAAO;AAAA,EACnC;AACF;AAaO,SAAS,gCACd,WACA,YACA,aACuB;AACvB,SAAO;AAAA,IACL,MAAM,YAAY,QAAQ,QAAQ,IAAI;AAAA,IACtC,WAAW,YAAY;AACrB,kBAAY;AACZ,aAAO,QAAQ,QAAQ,IAAI;AAAA,IAC7B;AAAA,IAEA,aAAa,OAAO,QAAQ,YAAY,eAAe;AACrD,YAAM,UAAU,QAAQ,YAAY,UAAU;AAC9C,aAAO;AAAA,IACT;AAAA,IAEA,SAAS,OAAO,QAAQ,SAAS,QAAQ,YAAY;AACnD,aACG,MAAM;AAAA,QACL;AAAA,QACA;AAAA,QACA,oBAAoB,QAAQ,SAAS,OAAO;AAAA,MAC9C,KAAM;AAAA,IAEV;AAAA,EACF;AACF","sourcesContent":["import { HandlerType } from '@metamask/snaps-utils';\nimport { assertExhaustive } from '@metamask/utils';\n\nimport type { InvokeSnap, InvokeSnapArgs } from './BaseSnapExecutor';\nimport type {\n  ExecuteSnap,\n  JsonRpcRequestWithoutId,\n  Ping,\n  PossibleLookupRequestArgs,\n  SnapRpc,\n  Terminate,\n} from './validation';\nimport {\n  assertIsOnTransactionRequestArguments,\n  assertIsOnSignatureRequestArguments,\n  assertIsOnNameLookupRequestArguments,\n  assertIsOnUserInputRequestArguments,\n} from './validation';\n\nexport type CommandMethodsMapping = {\n  ping: Ping;\n  terminate: Terminate;\n  executeSnap: ExecuteSnap;\n  snapRpc: SnapRpc;\n};\n\n/**\n * Formats the arguments for the given handler.\n *\n * @param origin - The origin of the request.\n * @param handler - The handler to pass the request to.\n * @param request - The request object.\n * @returns The formatted arguments.\n */\nexport function getHandlerArguments(\n  origin: string,\n  handler: HandlerType,\n  request: JsonRpcRequestWithoutId,\n): InvokeSnapArgs {\n  // `request` is already validated by the time this function is called.\n\n  switch (handler) {\n    case HandlerType.OnTransaction: {\n      assertIsOnTransactionRequestArguments(request.params);\n\n      const { transaction, chainId, transactionOrigin } = request.params;\n      return {\n        transaction,\n        chainId,\n        transactionOrigin,\n      };\n    }\n    case HandlerType.OnSignature: {\n      assertIsOnSignatureRequestArguments(request.params);\n\n      const { signature, signatureOrigin } = request.params;\n      return { signature, signatureOrigin };\n    }\n    case HandlerType.OnNameLookup: {\n      assertIsOnNameLookupRequestArguments(request.params);\n\n      // TS complains that domain/address are not part of the type\n      // casting here as we've already validated the request args in the above step.\n      const { chainId, domain, address } =\n        request.params as unknown as PossibleLookupRequestArgs;\n\n      return domain\n        ? {\n            chainId,\n            domain,\n          }\n        : {\n            chainId,\n            address,\n          };\n    }\n    case HandlerType.OnRpcRequest:\n    case HandlerType.OnKeyringRequest:\n      return { origin, request };\n\n    case HandlerType.OnCronjob:\n    case HandlerType.OnInstall:\n    case HandlerType.OnUpdate:\n      return { request };\n\n    case HandlerType.OnHomePage:\n      return {};\n    case HandlerType.OnUserInput: {\n      assertIsOnUserInputRequestArguments(request.params);\n\n      const { id, event } = request.params;\n      return { id, event };\n    }\n\n    default:\n      return assertExhaustive(handler);\n  }\n}\n\n/**\n * Gets an object mapping internal, \"command\" JSON-RPC method names to their\n * implementations.\n *\n * @param startSnap - A function that starts a snap.\n * @param invokeSnap - A function that invokes the RPC method handler of a\n * snap.\n * @param onTerminate - A function that will be called when this executor is\n * terminated in order to handle cleanup tasks.\n * @returns An object containing the \"command\" method implementations.\n */\nexport function getCommandMethodImplementations(\n  startSnap: (...args: Parameters<ExecuteSnap>) => Promise<void>,\n  invokeSnap: InvokeSnap,\n  onTerminate: () => void,\n): CommandMethodsMapping {\n  return {\n    ping: async () => Promise.resolve('OK'),\n    terminate: async () => {\n      onTerminate();\n      return Promise.resolve('OK');\n    },\n\n    executeSnap: async (snapId, sourceCode, endowments) => {\n      await startSnap(snapId, sourceCode, endowments);\n      return 'OK';\n    },\n\n    snapRpc: async (target, handler, origin, request) => {\n      return (\n        (await invokeSnap(\n          target,\n          handler,\n          getHandlerArguments(origin, handler, request),\n        )) ?? null\n      );\n    },\n  };\n}\n"]}