{"version":3,"sources":["../src/common/endowments/index.ts"],"sourcesContent":["import type { StreamProvider } from '@metamask/providers';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { SnapsProvider } from '@metamask/snaps-sdk';\nimport { logWarning } from '@metamask/snaps-utils';\nimport { hasProperty } from '@metamask/utils';\n\nimport type { NotifyFunction } from '../BaseSnapExecutor';\nimport { rootRealmGlobal } from '../globalObject';\nimport type { EndowmentFactoryOptions } from './commonEndowmentFactory';\nimport buildCommonEndowments from './commonEndowmentFactory';\n\ntype EndowmentFactoryResult = {\n  /**\n   * A function that performs any necessary teardown when the snap becomes idle.\n   *\n   * NOTE:** The endowments are not reconstructed if the snap is re-invoked\n   * before being terminated, so the teardown operation must not render the\n   * endowments unusable; it should simply restore the endowments to their\n   * original state.\n   */\n  teardownFunction?: () => Promise<void> | void;\n  [key: string]: unknown;\n};\n\n/**\n * Retrieve consolidated endowment factories for common endowments.\n */\nconst registeredEndowments = buildCommonEndowments();\n\n/**\n * A map of endowment names to their factory functions. Some endowments share\n * the same factory function, but we only call each factory once for each snap.\n * See {@link createEndowments} for details.\n */\nconst endowmentFactories = registeredEndowments.reduce((factories, builder) => {\n  builder.names.forEach((name) => {\n    factories.set(name, builder.factory);\n  });\n  return factories;\n}, new Map<string, (options?: EndowmentFactoryOptions) => EndowmentFactoryResult>());\n\n/**\n * Gets the endowments for a particular Snap. Some endowments, like `setTimeout`\n * and `clearTimeout`, must be attenuated so that they can only affect behavior\n * within the Snap's own realm. Therefore, we use factory functions to create\n * such attenuated / modified endowments. Otherwise, the value that's on the\n * root realm global will be used.\n *\n * @param options - An options bag.\n * @param options.snap - The Snaps global API object.\n * @param options.ethereum - The Snap's EIP-1193 provider object.\n * @param options.snapId - The id of the snap that will use the created endowments.\n * @param options.endowments - The list of endowments to provide to the snap.\n * @param options.notify - A reference to the notify function of the snap executor.\n * @returns An object containing the Snap's endowments.\n */\nexport function createEndowments({\n  snap,\n  ethereum,\n  snapId,\n  endowments,\n  notify,\n}: {\n  snap: SnapsProvider;\n  ethereum: StreamProvider;\n  snapId: string;\n  endowments: string[];\n  notify: NotifyFunction;\n}): { endowments: Record<string, unknown>; teardown: () => Promise<void> } {\n  const attenuatedEndowments: Record<string, unknown> = {};\n\n  // TODO: All endowments should be hardened to prevent covert communication\n  // channels. Hardening the returned objects breaks tests elsewhere in the\n  // monorepo, so further research is needed.\n  const result = endowments.reduce<{\n    allEndowments: Record<string, unknown>;\n    teardowns: (() => Promise<void> | void)[];\n  }>(\n    ({ allEndowments, teardowns }, endowmentName) => {\n      // First, check if the endowment has a factory, and default to that.\n      if (endowmentFactories.has(endowmentName)) {\n        if (!hasProperty(attenuatedEndowments, endowmentName)) {\n          // Call the endowment factory for the current endowment. If the factory\n          // creates multiple endowments, they will all be assigned to the\n          // `attenuatedEndowments` object, but will only be passed on to the snap\n          // if explicitly listed among its endowment.\n          // This may not have an actual use case, but, safety first.\n\n          // We just confirmed that endowmentFactories has the specified key.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const { teardownFunction, ...endowment } = endowmentFactories.get(\n            endowmentName,\n          )!({ snapId, notify });\n          Object.assign(attenuatedEndowments, endowment);\n          if (teardownFunction) {\n            teardowns.push(teardownFunction);\n          }\n        }\n        allEndowments[endowmentName] = attenuatedEndowments[endowmentName];\n      } else if (endowmentName === 'ethereum') {\n        // Special case for adding the EIP-1193 provider.\n        allEndowments[endowmentName] = ethereum;\n      } else if (endowmentName in rootRealmGlobal) {\n        logWarning(`Access to unhardened global ${endowmentName}.`);\n        // If the endowment doesn't have a factory, just use whatever is on the\n        // global object.\n        const globalValue = (rootRealmGlobal as Record<string, unknown>)[\n          endowmentName\n        ];\n        allEndowments[endowmentName] = globalValue;\n      } else {\n        // If we get to this point, we've been passed an endowment that doesn't\n        // exist in our current environment.\n        throw rpcErrors.internal(`Unknown endowment: \"${endowmentName}\".`);\n      }\n      return { allEndowments, teardowns };\n    },\n    {\n      allEndowments: { snap },\n      teardowns: [],\n    },\n  );\n\n  const teardown = async () => {\n    await Promise.all(\n      result.teardowns.map((teardownFunction) => teardownFunction()),\n    );\n  };\n  return { endowments: result.allEndowments, teardown };\n}\n"],"mappings":";;;;;;;;AACA,SAAS,iBAAiB;AAE1B,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAuB5B,IAAM,uBAAuB,+BAAsB;AAOnD,IAAM,qBAAqB,qBAAqB,OAAO,CAAC,WAAW,YAAY;AAC7E,UAAQ,MAAM,QAAQ,CAAC,SAAS;AAC9B,cAAU,IAAI,MAAM,QAAQ,OAAO;AAAA,EACrC,CAAC;AACD,SAAO;AACT,GAAG,oBAAI,IAA2E,CAAC;AAiB5E,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAM2E;AACzE,QAAM,uBAAgD,CAAC;AAKvD,QAAM,SAAS,WAAW;AAAA,IAIxB,CAAC,EAAE,eAAe,UAAU,GAAG,kBAAkB;AAE/C,UAAI,mBAAmB,IAAI,aAAa,GAAG;AACzC,YAAI,CAAC,YAAY,sBAAsB,aAAa,GAAG;AASrD,gBAAM,EAAE,kBAAkB,GAAG,UAAU,IAAI,mBAAmB;AAAA,YAC5D;AAAA,UACF,EAAG,EAAE,QAAQ,OAAO,CAAC;AACrB,iBAAO,OAAO,sBAAsB,SAAS;AAC7C,cAAI,kBAAkB;AACpB,sBAAU,KAAK,gBAAgB;AAAA,UACjC;AAAA,QACF;AACA,sBAAc,aAAa,IAAI,qBAAqB,aAAa;AAAA,MACnE,WAAW,kBAAkB,YAAY;AAEvC,sBAAc,aAAa,IAAI;AAAA,MACjC,WAAW,iBAAiB,iBAAiB;AAC3C,mBAAW,+BAA+B,aAAa,GAAG;AAG1D,cAAM,cAAe,gBACnB,aACF;AACA,sBAAc,aAAa,IAAI;AAAA,MACjC,OAAO;AAGL,cAAM,UAAU,SAAS,uBAAuB,aAAa,IAAI;AAAA,MACnE;AACA,aAAO,EAAE,eAAe,UAAU;AAAA,IACpC;AAAA,IACA;AAAA,MACE,eAAe,EAAE,KAAK;AAAA,MACtB,WAAW,CAAC;AAAA,IACd;AAAA,EACF;AAEA,QAAM,WAAW,YAAY;AAC3B,UAAM,QAAQ;AAAA,MACZ,OAAO,UAAU,IAAI,CAAC,qBAAqB,iBAAiB,CAAC;AAAA,IAC/D;AAAA,EACF;AACA,SAAO,EAAE,YAAY,OAAO,eAAe,SAAS;AACtD;","names":[]}