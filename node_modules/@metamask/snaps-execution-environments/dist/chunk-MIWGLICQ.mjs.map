{"version":3,"sources":["../src/proxy/ProxySnapExecutor.ts"],"sourcesContent":["import type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport { WindowPostMessageStream } from '@metamask/post-message-stream';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport packageJson from '@metamask/snaps-execution-environments/package.json';\nimport { createWindow, logError } from '@metamask/snaps-utils';\nimport type { JsonRpcRequest } from '@metamask/utils';\nimport { assert } from '@metamask/utils';\n\ntype ExecutorJob = {\n  id: string;\n  window: Window;\n  stream: WindowPostMessageStream;\n};\n\nconst IFRAME_URL = `https://execution.metamask.io/iframe/${packageJson.version}/index.html`;\n\n/**\n * A \"proxy\" snap executor that uses a level of indirection to execute snaps.\n *\n * Useful for multiple execution environments.\n *\n * This is not a traditional snap executor, as it does not execute snaps itself.\n * Instead, it creates an iframe window for each snap execution, and sends the\n * snap execution request to the iframe window. The iframe window is responsible\n * for executing the snap.\n *\n * This executor is persisted between snap executions. The executor essentially\n * acts as a proxy between the client and the iframe execution environment.\n */\nexport class ProxySnapExecutor {\n  readonly #stream: BasePostMessageStream;\n\n  readonly #frameUrl: string;\n\n  readonly jobs: Record<string, ExecutorJob> = {};\n\n  /**\n   * Initialize the executor with the given stream. This is a wrapper around the\n   * constructor.\n   *\n   * @param stream - The stream to use for communication.\n   * @param frameUrl - An optional URL for the iframe to use.\n   * @returns The initialized executor.\n   */\n  static initialize(stream: BasePostMessageStream, frameUrl = IFRAME_URL) {\n    return new ProxySnapExecutor(stream, frameUrl);\n  }\n\n  constructor(stream: BasePostMessageStream, frameUrl: string) {\n    this.#stream = stream;\n    this.#stream.on('data', this.#onData.bind(this));\n    this.#frameUrl = frameUrl;\n  }\n\n  /**\n   * Handle an incoming message from a `ProxyExecutionService`. This\n   * assumes that the message contains a `jobId` property, and a JSON-RPC\n   * request in the `data` property.\n   *\n   * @param data - The message data.\n   * @param data.data - The JSON-RPC request.\n   * @param data.jobId - The job ID.\n   */\n  #onData(data: { data: JsonRpcRequest; jobId: string }) {\n    const { jobId, data: request } = data;\n\n    if (!this.jobs[jobId]) {\n      // This ensures that a job is initialized before it is used. To avoid\n      // code duplication, we call the `#onData` method again, which will\n      // run the rest of the logic after initialization.\n      this.#initializeJob(jobId)\n        .then(() => {\n          this.#onData(data);\n        })\n        .catch((error) => {\n          logError('[Worker] Error initializing job:', error);\n        });\n\n      return;\n    }\n\n    // This is a method specific to the `OffscreenSnapExecutor`, as the service\n    // itself does not have access to the iframes directly.\n    if (request.method === 'terminateJob') {\n      this.#terminateJob(jobId);\n      return;\n    }\n\n    this.jobs[jobId].stream.write(request);\n  }\n\n  /**\n   * Create a new iframe and set up a stream to communicate with it.\n   *\n   * @param jobId - The job ID.\n   */\n  async #initializeJob(jobId: string): Promise<ExecutorJob> {\n    const window = await createWindow(this.#frameUrl, jobId);\n    const jobStream = new WindowPostMessageStream({\n      name: 'parent',\n      target: 'child',\n      targetWindow: window, // iframe's internal window\n      targetOrigin: '*',\n    });\n\n    // Write messages from the iframe to the parent, wrapped with the job ID.\n    jobStream.on('data', (data) => {\n      this.#stream.write({ data, jobId });\n    });\n\n    this.jobs[jobId] = { id: jobId, window, stream: jobStream };\n    return this.jobs[jobId];\n  }\n\n  /**\n   * Terminate the job with the given ID. This will close the iframe and delete\n   * the job from the internal job map.\n   *\n   * @param jobId - The job ID.\n   */\n  #terminateJob(jobId: string) {\n    assert(this.jobs[jobId], `Job \"${jobId}\" not found.`);\n\n    const iframe = document.getElementById(jobId);\n    assert(iframe, `Iframe with ID \"${jobId}\" not found.`);\n\n    iframe.remove();\n    this.jobs[jobId].stream.destroy();\n    delete this.jobs[jobId];\n  }\n}\n"],"mappings":";;;;;;;;AACA,SAAS,+BAA+B;AAExC,OAAO,iBAAiB;AACxB,SAAS,cAAc,gBAAgB;AAEvC,SAAS,cAAc;AAQvB,IAAM,aAAa,wCAAwC,YAAY,OAAO;AAd9E;AA6BO,IAAM,qBAAN,MAAM,mBAAkB;AAAA,EAmB7B,YAAY,QAA+B,UAAkB;AAe7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAwBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1FA,uBAAS,SAAT;AAEA,uBAAS,WAAT;AAEA,SAAS,OAAoC,CAAC;AAe5C,uBAAK,SAAU;AACf,uBAAK,SAAQ,GAAG,QAAQ,sBAAK,oBAAQ,KAAK,IAAI,CAAC;AAC/C,uBAAK,WAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EARA,OAAO,WAAW,QAA+B,WAAW,YAAY;AACtE,WAAO,IAAI,mBAAkB,QAAQ,QAAQ;AAAA,EAC/C;AAoFF;AApGW;AAEA;AA+BT;AAAA,YAAO,SAAC,MAA+C;AACrD,QAAM,EAAE,OAAO,MAAM,QAAQ,IAAI;AAEjC,MAAI,CAAC,KAAK,KAAK,KAAK,GAAG;AAIrB,0BAAK,kCAAL,WAAoB,OACjB,KAAK,MAAM;AACV,4BAAK,oBAAL,WAAa;AAAA,IACf,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,eAAS,oCAAoC,KAAK;AAAA,IACpD,CAAC;AAEH;AAAA,EACF;AAIA,MAAI,QAAQ,WAAW,gBAAgB;AACrC,0BAAK,gCAAL,WAAmB;AACnB;AAAA,EACF;AAEA,OAAK,KAAK,KAAK,EAAE,OAAO,MAAM,OAAO;AACvC;AAOM;AAAA,mBAAc,eAAC,OAAqC;AACxD,QAAM,SAAS,MAAM,aAAa,mBAAK,YAAW,KAAK;AACvD,QAAM,YAAY,IAAI,wBAAwB;AAAA,IAC5C,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,cAAc;AAAA;AAAA,IACd,cAAc;AAAA,EAChB,CAAC;AAGD,YAAU,GAAG,QAAQ,CAAC,SAAS;AAC7B,uBAAK,SAAQ,MAAM,EAAE,MAAM,MAAM,CAAC;AAAA,EACpC,CAAC;AAED,OAAK,KAAK,KAAK,IAAI,EAAE,IAAI,OAAO,QAAQ,QAAQ,UAAU;AAC1D,SAAO,KAAK,KAAK,KAAK;AACxB;AAQA;AAAA,kBAAa,SAAC,OAAe;AAC3B,SAAO,KAAK,KAAK,KAAK,GAAG,QAAQ,KAAK,cAAc;AAEpD,QAAM,SAAS,SAAS,eAAe,KAAK;AAC5C,SAAO,QAAQ,mBAAmB,KAAK,cAAc;AAErD,SAAO,OAAO;AACd,OAAK,KAAK,KAAK,EAAE,OAAO,QAAQ;AAChC,SAAO,KAAK,KAAK,KAAK;AACxB;AApGK,IAAM,oBAAN;","names":[]}