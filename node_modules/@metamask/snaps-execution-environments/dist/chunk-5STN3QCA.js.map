{"version":3,"sources":["../src/webworker/pool/WebWorkerPool.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport {\n  WebWorkerParentPostMessageStream,\n  WindowPostMessageStream,\n} from '@metamask/post-message-stream';\nimport { logError } from '@metamask/snaps-utils';\nimport type { JsonRpcRequest } from '@metamask/utils';\nimport { assert } from '@metamask/utils';\nimport { nanoid } from 'nanoid/non-secure';\n\ntype ExecutorJob = {\n  id: string;\n  worker: Worker;\n  stream: WebWorkerParentPostMessageStream;\n};\n\n/**\n * A snap executor using the WebWorker API.\n *\n * This is not a traditional snap executor, as it does not execute snaps itself.\n * Instead, it creates a pool of webworkers for each snap execution, and sends\n * the snap execution request to the webworker. The webworker is responsible for\n * executing the snap.\n */\nexport class WebWorkerPool {\n  readonly #poolSize;\n\n  readonly #stream: BasePostMessageStream;\n\n  readonly #url: string;\n\n  readonly pool: Worker[] = [];\n\n  readonly jobs: Map<string, ExecutorJob> = new Map();\n\n  #workerSourceURL?: string;\n\n  /* istanbul ignore next - Constructor arguments. */\n  static initialize(\n    stream: BasePostMessageStream = new WindowPostMessageStream({\n      name: 'child',\n      target: 'parent',\n      targetWindow: self.parent,\n      targetOrigin: '*',\n    }),\n    url = '../executor/bundle.js',\n    poolSize?: number,\n  ) {\n    return new WebWorkerPool(stream, url, poolSize);\n  }\n\n  constructor(stream: BasePostMessageStream, url: string, poolSize = 3) {\n    this.#stream = stream;\n    this.#url = url;\n    this.#poolSize = poolSize;\n\n    this.#stream.on('data', this.#onData.bind(this));\n  }\n\n  /**\n   * Handle an incoming message from the `WebWorkerExecutionService`. This\n   * assumes that the message contains a `jobId` property, and a JSON-RPC\n   * request in the `data` property.\n   *\n   * @param data - The message data.\n   * @param data.data - The JSON-RPC request.\n   * @param data.jobId - The job ID.\n   */\n  #onData(data: { data: JsonRpcRequest; jobId: string }) {\n    const { jobId, data: request } = data;\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      // This ensures that a job is initialized before it is used. To avoid\n      // code duplication, we call the `#onData` method again, which will\n      // run the rest of the logic after initialization.\n      this.#initializeJob(jobId)\n        .then(() => {\n          this.#onData(data);\n        })\n        .catch((error) => {\n          logError('[Worker] Error initializing job:', error.toString());\n\n          this.#stream.write({\n            jobId,\n            data: {\n              name: 'command',\n              data: {\n                jsonrpc: '2.0',\n                id: request.id ?? null,\n                error: {\n                  code: -32000,\n                  message: 'Internal error',\n                },\n              },\n            },\n          });\n        });\n\n      return;\n    }\n\n    // This is a method specific to the `WebWorkerPool`, as the service itself\n    // does not have access to the workers directly.\n    if (request.method === 'terminateJob') {\n      this.#terminateJob(jobId);\n      return;\n    }\n\n    job.stream.write(request);\n  }\n\n  /**\n   * Create a new worker and set up a stream to communicate with it.\n   *\n   * @param jobId - The job ID.\n   * @returns The job.\n   */\n  async #initializeJob(jobId: string): Promise<ExecutorJob> {\n    const worker = await this.#getWorker();\n    const jobStream = new WebWorkerParentPostMessageStream({\n      worker,\n    });\n\n    // Write messages from the worker to the parent, wrapped with the job ID.\n    jobStream.on('data', (data) => {\n      this.#stream.write({ data, jobId });\n    });\n\n    const job = { id: jobId, worker, stream: jobStream };\n    this.jobs.set(jobId, job);\n    return job;\n  }\n\n  /**\n   * Terminate the job with the given ID. This will close the worker and delete\n   * the job from the internal job map.\n   *\n   * @param jobId - The job ID.\n   */\n  #terminateJob(jobId: string) {\n    const job = this.jobs.get(jobId);\n    assert(job, `Job \"${jobId}\" not found.`);\n\n    job.stream.destroy();\n    job.worker.terminate();\n\n    this.jobs.delete(jobId);\n  }\n\n  /**\n   * Get a worker from the pool. A new worker will be created automatically.\n   *\n   * @returns The worker.\n   */\n  async #getWorker() {\n    // Lazily create the pool of workers.\n    if (this.pool.length === 0) {\n      await this.#updatePool();\n    }\n\n    const worker = this.pool.shift();\n    assert(worker, 'Worker not found.');\n\n    await this.#updatePool();\n\n    return worker;\n  }\n\n  /**\n   * Update the pool of workers. This will create new workers if the pool is\n   * below the minimum size.\n   */\n  async #updatePool() {\n    while (this.pool.length < this.#poolSize) {\n      const worker = await this.#createWorker();\n      this.pool.push(worker);\n    }\n  }\n\n  /**\n   * Create a new worker. This will fetch the worker source if it has not\n   * already been fetched.\n   *\n   * @returns The worker.\n   */\n  async #createWorker() {\n    return new Worker(await this.#getWorkerURL(), {\n      name: `worker-${nanoid()}`,\n    });\n  }\n\n  /**\n   * Get the URL of the worker source. This will fetch the worker source if it\n   * has not already been fetched.\n   *\n   * @returns The worker source URL, as a `blob:` URL.\n   */\n  async #getWorkerURL() {\n    if (this.#workerSourceURL) {\n      return this.#workerSourceURL;\n    }\n\n    const blob = await fetch(this.#url)\n      .then(async (response) => response.blob())\n      .then(URL.createObjectURL.bind(URL));\n\n    this.#workerSourceURL = blob;\n    return blob;\n  }\n}\n"]}