{"version":3,"sources":["../src/common/utils.ts"],"sourcesContent":["import type { StreamProvider, RequestArguments } from '@metamask/providers';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport {\n  assert,\n  assertStruct,\n  getJsonSize,\n  getSafeJson,\n  isObject,\n  JsonStruct,\n} from '@metamask/utils';\n\nimport { log } from '../logging';\n\n// 64 MB - we chose this number because it is the size limit for postMessage\n// between the extension and the dapp enforced by Chrome.\nconst MAX_RESPONSE_JSON_SIZE = 64_000_000;\n\n/**\n * Make proxy for Promise and handle the teardown process properly.\n * If the teardown is called in the meanwhile, Promise result will not be\n * exposed to the snap anymore and warning will be logged to the console.\n *\n * @param originalPromise - Original promise.\n * @param teardownRef - Reference containing teardown count.\n * @param teardownRef.lastTeardown - Number of the last teardown.\n * @returns New proxy promise.\n */\nexport async function withTeardown<Type>(\n  originalPromise: Promise<Type>,\n  teardownRef: { lastTeardown: number },\n): Promise<Type> {\n  const myTeardown = teardownRef.lastTeardown;\n  return new Promise<Type>((resolve, reject) => {\n    originalPromise\n      .then((value) => {\n        if (teardownRef.lastTeardown === myTeardown) {\n          resolve(value);\n        } else {\n          log(\n            'Late promise received after Snap finished execution. Promise will be dropped.',\n          );\n        }\n      })\n      .catch((reason) => {\n        if (teardownRef.lastTeardown === myTeardown) {\n          reject(reason);\n        } else {\n          log(\n            'Late promise received after Snap finished execution. Promise will be dropped.',\n          );\n        }\n      });\n  });\n}\n\n/**\n * Returns a Proxy that only allows access to a `request` function.\n * This is useful for replacing StreamProvider with an attenuated version.\n *\n * @param request - Custom attenuated request function.\n * @returns Proxy that mimics a StreamProvider instance.\n */\nexport function proxyStreamProvider(request: unknown): StreamProvider {\n  // Proxy target is intentionally set to be an empty object, to ensure\n  // that access to the prototype chain is not possible.\n  const proxy = new Proxy(\n    {},\n    {\n      has(_target: object, prop: string | symbol) {\n        return typeof prop === 'string' && ['request'].includes(prop);\n      },\n      get(_target, prop: keyof StreamProvider) {\n        if (prop === 'request') {\n          return request;\n        }\n\n        return undefined;\n      },\n    },\n  );\n\n  return proxy as StreamProvider;\n}\n\n// We're blocking these RPC methods for v1, will revisit later.\nexport const BLOCKED_RPC_METHODS = Object.freeze([\n  'wallet_requestSnaps',\n  'wallet_requestPermissions',\n  'wallet_revokePermissions',\n  // We disallow all of these confirmations for now, since the screens are not ready for Snaps.\n  'eth_sendRawTransaction',\n  'eth_sendTransaction',\n  'eth_sign',\n  'eth_signTypedData',\n  'eth_signTypedData_v1',\n  'eth_signTypedData_v3',\n  'eth_signTypedData_v4',\n  'eth_decrypt',\n  'eth_getEncryptionPublicKey',\n  'wallet_addEthereumChain',\n  'wallet_switchEthereumChain',\n  'wallet_watchAsset',\n  'wallet_registerOnboarding',\n  'wallet_scanQRCode',\n]);\n\n/**\n * Asserts the validity of request arguments for a snap outbound request using the `snap.request` API.\n *\n * @param args - The arguments to validate.\n */\nexport function assertSnapOutboundRequest(args: RequestArguments) {\n  // Disallow any non `wallet_` or `snap_` methods for separation of concerns.\n  assert(\n    String.prototype.startsWith.call(args.method, 'wallet_') ||\n      String.prototype.startsWith.call(args.method, 'snap_'),\n    'The global Snap API only allows RPC methods starting with `wallet_*` and `snap_*`.',\n    rpcErrors.methodNotSupported,\n  );\n  assert(\n    !BLOCKED_RPC_METHODS.includes(args.method),\n    rpcErrors.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assertStruct(\n    args,\n    JsonStruct,\n    'Provided value is not JSON-RPC compatible',\n    rpcErrors.invalidParams,\n  );\n}\n\n/**\n * Asserts the validity of request arguments for an ethereum outbound request using the `ethereum.request` API.\n *\n * @param args - The arguments to validate.\n */\nexport function assertEthereumOutboundRequest(args: RequestArguments) {\n  // Disallow snaps methods for separation of concerns.\n  assert(\n    !String.prototype.startsWith.call(args.method, 'snap_'),\n    rpcErrors.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assert(\n    !BLOCKED_RPC_METHODS.includes(args.method),\n    rpcErrors.methodNotFound({\n      data: {\n        method: args.method,\n      },\n    }),\n  );\n  assertStruct(\n    args,\n    JsonStruct,\n    'Provided value is not JSON-RPC compatible',\n    rpcErrors.invalidParams,\n  );\n}\n\n/**\n * Gets a sanitized value to be used for passing to the underlying MetaMask provider.\n *\n * @param value - An unsanitized value from a snap.\n * @returns A sanitized value ready to be passed to a MetaMask provider.\n */\nexport function sanitizeRequestArguments(value: unknown): RequestArguments {\n  // Before passing to getSafeJson we run the value through JSON serialization.\n  // This lets request arguments contain undefined which is normally disallowed.\n  const json = JSON.parse(JSON.stringify(value));\n  return getSafeJson(json) as RequestArguments;\n}\n\n/**\n * Check if the input is a valid response.\n *\n * @param response - The response.\n * @returns True if the response is valid, otherwise false.\n */\nexport function isValidResponse(response: Record<string, unknown>) {\n  if (!isObject(response)) {\n    return false;\n  }\n\n  try {\n    // If the JSON is invalid this will throw and we should return false.\n    const size = getJsonSize(response);\n    return size < MAX_RESPONSE_JSON_SIZE;\n  } catch {\n    return false;\n  }\n}\n"],"mappings":";;;;;AACA,SAAS,iBAAiB;AAC1B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMP,IAAM,yBAAyB;AAY/B,eAAsB,aACpB,iBACA,aACe;AACf,QAAM,aAAa,YAAY;AAC/B,SAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,oBACG,KAAK,CAAC,UAAU;AACf,UAAI,YAAY,iBAAiB,YAAY;AAC3C,gBAAQ,KAAK;AAAA,MACf,OAAO;AACL;AAAA,UACE;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC,EACA,MAAM,CAAC,WAAW;AACjB,UAAI,YAAY,iBAAiB,YAAY;AAC3C,eAAO,MAAM;AAAA,MACf,OAAO;AACL;AAAA,UACE;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACL,CAAC;AACH;AASO,SAAS,oBAAoB,SAAkC;AAGpE,QAAM,QAAQ,IAAI;AAAA,IAChB,CAAC;AAAA,IACD;AAAA,MACE,IAAI,SAAiB,MAAuB;AAC1C,eAAO,OAAO,SAAS,YAAY,CAAC,SAAS,EAAE,SAAS,IAAI;AAAA,MAC9D;AAAA,MACA,IAAI,SAAS,MAA4B;AACvC,YAAI,SAAS,WAAW;AACtB,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAGO,IAAM,sBAAsB,OAAO,OAAO;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAOM,SAAS,0BAA0B,MAAwB;AAEhE;AAAA,IACE,OAAO,UAAU,WAAW,KAAK,KAAK,QAAQ,SAAS,KACrD,OAAO,UAAU,WAAW,KAAK,KAAK,QAAQ,OAAO;AAAA,IACvD;AAAA,IACA,UAAU;AAAA,EACZ;AACA;AAAA,IACE,CAAC,oBAAoB,SAAS,KAAK,MAAM;AAAA,IACzC,UAAU,eAAe;AAAA,MACvB,MAAM;AAAA,QACJ,QAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ;AACF;AAOO,SAAS,8BAA8B,MAAwB;AAEpE;AAAA,IACE,CAAC,OAAO,UAAU,WAAW,KAAK,KAAK,QAAQ,OAAO;AAAA,IACtD,UAAU,eAAe;AAAA,MACvB,MAAM;AAAA,QACJ,QAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACA;AAAA,IACE,CAAC,oBAAoB,SAAS,KAAK,MAAM;AAAA,IACzC,UAAU,eAAe;AAAA,MACvB,MAAM;AAAA,QACJ,QAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU;AAAA,EACZ;AACF;AAQO,SAAS,yBAAyB,OAAkC;AAGzE,QAAM,OAAO,KAAK,MAAM,KAAK,UAAU,KAAK,CAAC;AAC7C,SAAO,YAAY,IAAI;AACzB;AAQO,SAAS,gBAAgB,UAAmC;AACjE,MAAI,CAAC,SAAS,QAAQ,GAAG;AACvB,WAAO;AAAA,EACT;AAEA,MAAI;AAEF,UAAM,OAAO,YAAY,QAAQ;AACjC,WAAO,OAAO;AAAA,EAChB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;","names":[]}