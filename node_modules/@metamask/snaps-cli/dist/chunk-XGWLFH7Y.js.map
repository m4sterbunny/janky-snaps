{"version":3,"sources":["../src/utils/steps.ts"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,WAAW;AAEpB,OAAO,mBAAmB;AAsB1B,eAAsB,aACpB,OACA,SACA;AACA,QAAM,UAAU,cAAc;AAAA;AAAA,IAE5B,QAAQ,QAAQ;AAAA,EAClB,CAAC;AAED,UAAQ,MAAM;AAEd,MAAI;AACF,eAAW,QAAQ,OAAO;AAExB,UAAI,KAAK,aAAa,CAAC,KAAK,UAAU,OAAO,GAAG;AAC9C;AAAA,MACF;AAIA,cAAQ,MAAM,IAAI,KAAK,IAAI,CAAC;AAE5B,YAAM,KAAK,KAAK;AAAA,QACd,GAAG;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAIA,QAAI,QAAQ,YAAY;AACtB,cAAQ,QAAQ,OAAO;AAAA,IACzB;AAAA,EACF,SAAS,QAAQ;AACf,UAAM,gBAAgB,MAAM,GAAG,OAAO;AACtC,YAAQ,KAAK;AACb,YAAQ,WAAW;AAAA,EACrB;AACF","sourcesContent":["import { dim } from 'chalk';\nimport type { Ora } from 'ora';\nimport createSpinner from 'ora';\n\nimport { getErrorMessage } from './errors';\nimport { error } from './logging';\n\nexport type Step<Context extends Record<string, unknown>> = {\n  name: string;\n  condition?: (context: Context) => boolean;\n  task: (context: Context & { spinner: Ora }) => Promise<void>;\n};\n\nexport type Steps<Context extends Record<string, unknown>> = Readonly<\n  Step<Context>[]\n>;\n\n/**\n * Execute a list of steps in series. Each step receives the context object and\n * a spinner instance.\n *\n * @param steps - The steps to execute.\n * @param context - The context object that will be passed to each step.\n */\nexport async function executeSteps<Context extends Record<string, unknown>>(\n  steps: Steps<Context>,\n  context: Context,\n) {\n  const spinner = createSpinner({\n    // Ora writes to `process.stderr` by default.\n    stream: process.stdout,\n  });\n\n  spinner.start();\n\n  try {\n    for (const step of steps) {\n      // If the step has a condition, and it returns false, we skip the step.\n      if (step.condition && !step.condition(context)) {\n        continue;\n      }\n\n      // Calling `start` here instead of setting `spinner.text` seems to work\n      // better when the process doesn't have a TTY.\n      spinner.start(dim(step.name));\n\n      await step.task({\n        ...context,\n        spinner,\n      });\n    }\n\n    // The spinner may have been stopped by a step, so we only succeed if it's\n    // still spinning.\n    if (spinner.isSpinning) {\n      spinner.succeed('Done!');\n    }\n  } catch (_error) {\n    error(getErrorMessage(_error), spinner);\n    spinner.stop();\n    process.exitCode = 1;\n  }\n}\n"]}