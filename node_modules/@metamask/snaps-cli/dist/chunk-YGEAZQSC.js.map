{"version":3,"sources":["../src/webpack/server.ts"],"names":[],"mappings":";AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,oBAAoB;AAE7B,SAAS,MAAM,UAAU,WAAW,aAAa,KAAK,aAAa;AACnE,OAAO,qBAAqB;AAc5B,SAAS,gBAAgB,MAAc,IAAY;AACjD,SAAO,SAAS,MAAM,EAAE,EAAE,MAAM,GAAG,EAAE,KAAK,MAAM,GAAG;AACrD;AAUO,SAAS,gBACd,QACA,UACA;AACA,QAAM,iBACJ,SAAS,OAAO,OAAO;AAAA,IAAI,CAAC,SAC1B;AAAA,MACE,OAAO,OAAO;AAAA,MACd,YAAY,OAAO,OAAO,MAAM,IAAI;AAAA,IACtC;AAAA,EACF,KAAK,CAAC;AAER,QAAM,oBACJ,SAAS,OAAO,SAAS;AAAA,IAAI,CAAC,iBAC5B;AAAA,MACE,OAAO,OAAO;AAAA,MACd,YAAY,OAAO,OAAO,MAAM,YAAY;AAAA,IAC9C;AAAA,EACF,KAAK,CAAC;AAER,QAAM,aAAa,SAAS,OAAO,SAAS,IAAI,WAC5C;AAAA,IACE;AAAA,MACE,OAAO,OAAO;AAAA,MACd;AAAA,QACE,OAAO,OAAO;AAAA,QACd,SAAS,OAAO,SAAS,IAAI;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,IACA,CAAC;AAEL,SAAO;AAAA,IACL;AAAA,MACE,OAAO,OAAO;AAAA,MACd;AAAA,QACE,OAAO,OAAO;AAAA,QACd,OAAO,OAAO;AAAA,QACd,OAAO,OAAO;AAAA,MAChB;AAAA,IACF;AAAA,IACA;AAAA,MACE,OAAO,OAAO;AAAA,MACd,YAAY,OAAO,OAAO,MAAM,iBAAiB,QAAQ;AAAA,IAC3D;AAAA,IACA,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AACF;AAaO,SAAS,UAAU,QAAyB;AASjD,iBAAe,YACb,SACA,UACA;AACA,UAAM,eAAe,KAAK,OAAO,OAAO,MAAM,iBAAiB,QAAQ;AACvE,UAAM,EAAE,OAAO,IAAI,MAAM,aAA2B,YAAY;AAChE,UAAM,eAAe,gBAAgB,QAAQ,MAAM;AAEnD,UAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AACjC,UAAM,UAAU,aAAa,KAAK,CAAC,gBAAgB,SAAS,WAAW;AAEvE,QAAI,CAAC,SAAS;AACZ,eAAS,aAAa;AACtB,eAAS,IAAI;AACb;AAAA,IACF;AAEA,UAAM,gBAAgB,SAAS,UAAU;AAAA,MACvC,QAAQ,OAAO,OAAO;AAAA,MACtB,kBAAkB;AAAA,MAClB,SAAS;AAAA,QACP;AAAA,UACE,QAAQ;AAAA,UACR,SAAS;AAAA,YACP;AAAA,cACE,KAAK;AAAA,cACL,OAAO;AAAA,YACT;AAAA,YACA;AAAA,cACE,KAAK;AAAA,cACL,OAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,SAAS,aAAa,CAAC,SAAS,aAAa;AACjD,gBAAY,SAAS,QAAQ,EAAE;AAAA;AAAA,MAE7B,CAAC,UAAU;AACT,iBAAS,KAAK;AACd,iBAAS,aAAa;AACtB,iBAAS,IAAI;AAAA,MACf;AAAA,IACF;AAAA,EACF,CAAC;AAWD,QAAM,SAAS,OAAO,OAAO,OAAO,OAAO,SAAS;AAClD,WAAO,IAAI,QAIR,CAAC,SAAS,WAAW;AACtB,UAAI;AACF,eAAO,OAAO,MAAM,MAAM;AACxB,gBAAM,QAAQ,YAAY;AACxB,kBAAM,IAAI,QAAc,CAAC,cAAc,gBAAgB;AACrD,qBAAO,MAAM,CAAC,eAAe;AAC3B,oBAAI,YAAY;AACd,yBAAO,YAAY,UAAU;AAAA,gBAC/B;AAEA,uBAAO,aAAa;AAAA,cACtB,CAAC;AAAA,YACH,CAAC;AAAA,UACH;AAEA,gBAAM,UAAU,OAAO,QAAQ;AAC/B,kBAAQ,EAAE,MAAM,QAAQ,MAAM,QAAQ,MAAM,CAAC;AAAA,QAC/C,CAAC;AAAA,MACH,SAAS,aAAa;AACpB,eAAO,WAAW;AAAA,MACpB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,EAAE,OAAO;AAClB","sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  logError,\n  NpmSnapFileNames,\n  readJsonFile,\n} from '@metamask/snaps-utils/node';\nimport type { IncomingMessage, Server, ServerResponse } from 'http';\nimport { createServer } from 'http';\nimport type { AddressInfo } from 'net';\nimport { join, relative, resolve as resolvePath, sep, posix } from 'path';\nimport serveMiddleware from 'serve-handler';\n\nimport type { ProcessedConfig } from '../config';\n\n/**\n * Get the relative path from one path to another.\n *\n * Note: This is a modified version of `path.relative` that uses Posix\n * separators for URL-compatibility.\n *\n * @param from - The path to start from.\n * @param to - The path to end at.\n * @returns The relative path.\n */\nfunction getRelativePath(from: string, to: string) {\n  return relative(from, to).split(sep).join(posix.sep);\n}\n\n/**\n * Get the allowed paths for the static server. This includes the output file,\n * the manifest file, and any auxiliary/localization files.\n *\n * @param config - The config object.\n * @param manifest - The Snap manifest object.\n * @returns An array of allowed paths.\n */\nexport function getAllowedPaths(\n  config: ProcessedConfig,\n  manifest: SnapManifest,\n) {\n  const auxiliaryFiles =\n    manifest.source.files?.map((file) =>\n      getRelativePath(\n        config.server.root,\n        resolvePath(config.server.root, file),\n      ),\n    ) ?? [];\n\n  const localizationFiles =\n    manifest.source.locales?.map((localization) =>\n      getRelativePath(\n        config.server.root,\n        resolvePath(config.server.root, localization),\n      ),\n    ) ?? [];\n\n  const otherFiles = manifest.source.location.npm.iconPath\n    ? [\n        getRelativePath(\n          config.server.root,\n          resolvePath(\n            config.server.root,\n            manifest.source.location.npm.iconPath,\n          ),\n        ),\n      ]\n    : [];\n\n  return [\n    getRelativePath(\n      config.server.root,\n      resolvePath(\n        config.server.root,\n        config.output.path,\n        config.output.filename,\n      ),\n    ),\n    getRelativePath(\n      config.server.root,\n      resolvePath(config.server.root, NpmSnapFileNames.Manifest),\n    ),\n    ...auxiliaryFiles,\n    ...localizationFiles,\n    ...otherFiles,\n  ];\n}\n\n/**\n * Get a static server for development purposes.\n *\n * Note: We're intentionally not using `webpack-dev-server` here because it\n * adds a lot of extra stuff to the output that we don't need, and it's\n * difficult to customize.\n *\n * @param config - The config object.\n * @returns An object with a `listen` method that returns a promise that\n * resolves when the server is listening.\n */\nexport function getServer(config: ProcessedConfig) {\n  /**\n   * Get the response for a request. This is extracted into a function so that\n   * we can easily catch errors and send a 500 response.\n   *\n   * @param request - The request.\n   * @param response - The response.\n   * @returns A promise that resolves when the response is sent.\n   */\n  async function getResponse(\n    request: IncomingMessage,\n    response: ServerResponse,\n  ) {\n    const manifestPath = join(config.server.root, NpmSnapFileNames.Manifest);\n    const { result } = await readJsonFile<SnapManifest>(manifestPath);\n    const allowedPaths = getAllowedPaths(config, result);\n\n    const path = request.url?.slice(1);\n    const allowed = allowedPaths.some((allowedPath) => path === allowedPath);\n\n    if (!allowed) {\n      response.statusCode = 404;\n      response.end();\n      return;\n    }\n\n    await serveMiddleware(request, response, {\n      public: config.server.root,\n      directoryListing: false,\n      headers: [\n        {\n          source: '**/*',\n          headers: [\n            {\n              key: 'Cache-Control',\n              value: 'no-cache',\n            },\n            {\n              key: 'Access-Control-Allow-Origin',\n              value: '*',\n            },\n          ],\n        },\n      ],\n    });\n  }\n\n  const server = createServer((request, response) => {\n    getResponse(request, response).catch(\n      /* istanbul ignore next */\n      (error) => {\n        logError(error);\n        response.statusCode = 500;\n        response.end();\n      },\n    );\n  });\n\n  /**\n   * Start the server on the port specified in the config.\n   *\n   * @param port - The port to listen on.\n   * @returns A promise that resolves when the server is listening. The promise\n   * resolves to an object with the port and the server instance. Note that if\n   * the `config.server.port` is `0`, the OS will choose a random port for us,\n   * so we need to get the port from the server after it starts.\n   */\n  const listen = async (port = config.server.port) => {\n    return new Promise<{\n      port: number;\n      server: Server;\n      close: () => Promise<void>;\n    }>((resolve, reject) => {\n      try {\n        server.listen(port, () => {\n          const close = async () => {\n            await new Promise<void>((resolveClose, rejectClose) => {\n              server.close((closeError) => {\n                if (closeError) {\n                  return rejectClose(closeError);\n                }\n\n                return resolveClose();\n              });\n            });\n          };\n\n          const address = server.address() as AddressInfo;\n          resolve({ port: address.port, server, close });\n        });\n      } catch (listenError) {\n        reject(listenError);\n      }\n    });\n  };\n\n  return { listen };\n}\n"]}