{"version":3,"sources":["../src/commands/manifest/manifest.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,cAAc;AAkBvB,IAAM,QAAgC;AAAA,EACpC;AAAA,IACE,MAAM;AAAA,IACN,MAAM,OAAO,EAAE,MAAM,MAAM;AACzB,UAAI,CAAE,MAAM,OAAO,KAAK,GAAI;AAC1B,cAAM,IAAI;AAAA,UACR,6BAA6B,KAAK;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,MAAM,OAAO,EAAE,OAAO,QAAQ,SAAS,QAAQ,MAAM;AACnD,YAAM,QAAQ,iBAAiB,QAAQ,OAAO;AAC9C,YAAM,QAAQ,MAAM,SAAS,OAAO,OAAO,OAAO;AAElD,UAAI,OAAO;AACT,gBAAQ,QAAQ,kCAAkC;AAAA,MACpD;AAAA,IACF;AAAA,EACF;AACF;AASA,SAAS,iBAAiB,QAAyB,SAA0B;AAC3E,MAAI,OAAO,QAAQ,QAAQ,WAAW;AACpC,WAAO,QAAQ;AAAA,EACjB;AAEA,SAAO,OAAO,QAAQ,iBAAiB;AACzC;AAUA,eAAsB,gBACpB,QACA,SACA;AACA,QAAM,aAAa,OAAO;AAAA,IACxB,OAAO,OAAO,SAAS;AAAA,IACvB;AAAA,IACA;AAAA,EACF,CAAC;AACH","sourcesContent":["import { isFile } from '@metamask/snaps-utils/node';\n\nimport type { ProcessedConfig } from '../../config';\nimport { CommandError } from '../../errors';\nimport type { Steps } from '../../utils';\nimport { executeSteps } from '../../utils';\nimport { manifest } from './implementation';\n\ntype ManifestOptions = {\n  fix?: boolean;\n};\n\ntype ManifestContext = {\n  input: string;\n  config: ProcessedConfig;\n  options: ManifestOptions;\n};\n\nconst steps: Steps<ManifestContext> = [\n  {\n    name: 'Checking the input file.',\n    task: async ({ input }) => {\n      if (!(await isFile(input))) {\n        throw new CommandError(\n          `Manifest file not found: \"${input}\". Make sure that the \\`snap.manifest.json\\` file exists.`,\n        );\n      }\n    },\n  },\n  {\n    name: 'Validating the snap manifest.',\n    task: async ({ input, config, options, spinner }) => {\n      const write = getWriteManifest(config, options);\n      const valid = await manifest(input, write, spinner);\n\n      if (valid) {\n        spinner.succeed('The snap manifest file is valid.');\n      }\n    },\n  },\n];\n\n/**\n * Get whether to write the manifest to disk.\n *\n * @param config - The config object.\n * @param options - The options object.\n * @returns Whether to write the manifest to disk.\n */\nfunction getWriteManifest(config: ProcessedConfig, options: ManifestOptions) {\n  if (typeof options.fix === 'boolean') {\n    return options.fix;\n  }\n\n  return config.legacy?.writeManifest ?? false;\n}\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param config - The config object.\n * @param options - The options object.\n */\nexport async function manifestHandler(\n  config: ProcessedConfig,\n  options: ManifestOptions,\n) {\n  await executeSteps(steps, {\n    input: config.manifest.path,\n    config,\n    options,\n  });\n}\n"]}