{"version":3,"sources":["../src/webpack/loaders/wasm.ts"],"names":["loader"],"mappings":";AAEA,SAAS,cAAc;AACvB,SAAS,SAAS,eAAe;AAU1B,SAAS,WAAW,WAAqC;AAC9D,SAAO,OAAO,QAAQ,SAAS,EAC5B;AAAA,IACC,CAAC,CAAC,YAAY,WAAW,MACvB,YAAY,YAAY,KAAK,IAAI,CAAC,WAAW,KAAK;AAAA,MAChD;AAAA,IACF,CAAC;AAAA,EACL,EACC,KAAK,IAAI;AACd;AASO,SAAS,iBAAiB,WAAqC;AACpE,SAAO,OAAO,QAAQ,SAAS,EAC5B;AAAA,IACC,CAAC,CAAC,YAAY,WAAW,MACvB,GAAG,KAAK,UAAU,UAAU,CAAC,OAAO,YAAY,KAAK,IAAI,CAAC;AAAA,EAC9D,EACC,KAAK,IAAI;AACd;AAUO,SAAS,WAAW,aAAmD;AAC5E,SAAO,YACJ,IAAI,CAAC,eAAe;AACnB,QAAI,WAAW,SAAS,WAAW;AACjC,aAAO,0BAA0B,KAAK,UAAU,WAAW,IAAI,CAAC;AAAA,IAClE;AAEA,WAAO,gBAAgB,WAAW,IAAI,cAAc,KAAK;AAAA,MACvD,WAAW;AAAA,IACb,CAAC;AAAA,EACH,CAAC,EACA,KAAK,IAAI;AACd;AAiBA,IAAM,SAAmC,eAAeA,QACtD,QACA;AACA,SAAO,kBAAkB,YAAY,qCAAqC;AAE1E,QAAM,QAAQ,IAAI,WAAW,MAAM;AACnC,QAAM,aAAa,MAAM,YAAY,QAAQ,KAAK;AAGlD,QAAM,UAAU,YAAY,OAAO,QAAQ,UAAU;AACrD,QAAM,UAAU,YAAY,OAAO,QAAQ,UAAU,EAAE,OAErD,CAAC,QAAQ,eAAe;AAzF5B;AA0FI,gBAAO,WAAW,YAAlB,aAA8B,CAAC;AAC/B,WAAO,WAAW,MAAM,EAAE,KAAK,WAAW,IAAI;AAE9C,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAIL,QAAM,OAAO,QAAQ,KAAK,YAAY;AACtC,aAAW,QAAQ,OAAO,KAAK,OAAO,GAAG;AACvC,SAAK,cAAc,QAAQ,MAAM,IAAI,CAAC;AAAA,EACxC;AAEA,SAAO;AAAA,MACH,WAAW,OAAO,CAAC;AAAA;AAAA,mCAEU,KAAK,UAAU,MAAM,KAAK,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA,QAG7D,iBAAiB,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,MAI3B,WAAW,OAAO,CAAC;AAAA;AAEzB;AAEA,IAAO,eAAQ;AAKR,IAAM,MAAM","sourcesContent":["/* eslint-disable no-restricted-globals */\n\nimport { assert } from '@metamask/utils';\nimport { dirname, resolve } from 'path';\nimport type { LoaderDefinitionFunction } from 'webpack';\n\n/**\n * Get the imports code for the WASM module. This code imports each of the\n * imports from the WASM module.\n *\n * @param importMap - The import map for the WASM module.\n * @returns The imports code for the WASM module.\n */\nexport function getImports(importMap: Record<string, string[]>) {\n  return Object.entries(importMap)\n    .map(\n      ([moduleName, exportNames]) =>\n        `import { ${exportNames.join(', ')} } from ${JSON.stringify(\n          moduleName,\n        )};`,\n    )\n    .join('\\n');\n}\n\n/**\n * Get the imports code to use in `WebAssembly.Instance`. This code adds each of\n * the imports to the `imports` object.\n *\n * @param importMap - The import map for the WASM module.\n * @returns The imports code for the WASM module.\n */\nexport function getModuleImports(importMap: Record<string, string[]>) {\n  return Object.entries(importMap)\n    .map(\n      ([moduleName, exportNames]) =>\n        `${JSON.stringify(moduleName)}: { ${exportNames.join(', ')} },`,\n    )\n    .join('\\n');\n}\n\n/**\n * Get the exports code for the WASM module. This code exports each of the\n * exports from the WASM module as a variable. This function assumes that the\n * exports are available in a variable named `exports`.\n *\n * @param descriptors - The export descriptors from the WASM module.\n * @returns The exports code for the WASM module.\n */\nexport function getExports(descriptors: WebAssembly.ModuleExportDescriptor[]) {\n  return descriptors\n    .map((descriptor) => {\n      if (descriptor.name === 'default') {\n        return `export default exports[${JSON.stringify(descriptor.name)}];`;\n      }\n\n      return `export const ${descriptor.name} = exports[${JSON.stringify(\n        descriptor.name,\n      )}];`;\n    })\n    .join('\\n');\n}\n\n/**\n * A Webpack loader that synchronously loads the WASM module. This makes it\n * possible to import the WASM module directly.\n *\n * @param source - The WASM module as `Uint8Array`.\n * @returns The WASM module as a JavaScript string.\n * @example\n * ```ts\n * import * as wasm from './program.wasm';\n *\n * // Do something with the WASM module...\n * ```\n */\n// Note: This function needs to be defined like this, so that Webpack can bind\n// `this` to the loader context, and TypeScript can infer the type of `this`.\nconst loader: LoaderDefinitionFunction = async function loader(\n  source: unknown,\n) {\n  assert(source instanceof Uint8Array, 'Expected source to be a Uint8Array.');\n\n  const bytes = new Uint8Array(source);\n  const wasmModule = await WebAssembly.compile(bytes);\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const exports = WebAssembly.Module.exports(wasmModule);\n  const imports = WebAssembly.Module.imports(wasmModule).reduce<\n    Record<string, string[]>\n  >((target, descriptor) => {\n    target[descriptor.module] ??= [];\n    target[descriptor.module].push(descriptor.name);\n\n    return target;\n  }, {});\n\n  // Add the WASM import as a dependency so that Webpack will watch it for\n  // changes.\n  const path = dirname(this.resourcePath);\n  for (const name of Object.keys(imports)) {\n    this.addDependency(resolve(path, name));\n  }\n\n  return `\n    ${getImports(imports)}\n\n    const bytes = new Uint8Array(${JSON.stringify(Array.from(source))});\n    const module = new WebAssembly.Module(bytes);\n    const instance = new WebAssembly.Instance(module, {\n      ${getModuleImports(imports)}\n    });\n\n    const exports = instance.exports;\n    ${getExports(exports)}\n  `;\n};\n\nexport default loader;\n\n// By setting `raw` to `true`, we are telling Webpack to provide the source as a\n// `Uint8Array` instead of converting it to a string. This allows us to avoid\n// having to convert the source back to a `Uint8Array` in the loader.\nexport const raw = true;\n"]}