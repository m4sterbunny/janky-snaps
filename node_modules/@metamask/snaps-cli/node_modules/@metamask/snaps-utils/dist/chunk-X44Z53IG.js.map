{"version":3,"sources":["../src/fs.ts"],"names":[],"mappings":";;;;;;;;AACA,SAAS,YAAY,UAAU;AAC/B,OAAO,QAAQ;AACf,OAAO,eAAe;AActB,eAAsB,YACpB,YACA,WACkB;AAClB,MAAI;AACF,UAAM,QAAQ,MAAM,GAAG,KAAK,UAAU;AACtC,WAAO,MAAM,YAAY;AAAA,EAC3B,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,UAAU;AAC3B,UAAI,CAAC,WAAW;AACd,eAAO;AAAA,MACT;AAEA,YAAM,GAAG,MAAM,YAAY,EAAE,WAAW,KAAK,CAAC;AAC9C,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAQA,eAAsB,OAAO,YAAsC;AACjE,MAAI;AACF,UAAM,QAAQ,MAAM,GAAG,KAAK,UAAU;AACtC,WAAO,MAAM,OAAO;AAAA,EACtB,SAAS,OAAO;AACd,WAAO;AAAA,EACT;AACF;AAQA,eAAsB,aACpB,YAC4B;AAC5B,MAAI,CAAC,WAAW,SAAS,OAAO,GAAG;AACjC,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AAEA,MAAI;AACJ,MAAI;AACF,WAAO,MAAM,gBAAgB,YAAY,MAAM;AAAA,EACjD,SAAS,OAAO;AACd,QAAI,MAAM,SAAS,UAAU;AAC3B,YAAM,IAAI;AAAA,QACR,mBAAmB,UAAU;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM;AAAA,EACR;AACA,OAAK,SAAS,UAAU,KAAK,SAAS,CAAC;AACvC,SAAO;AACT;AAUO,SAAS,eAAe,QAAgB,aAA6B;AAC1E,SAAO,UAAU,KAAK,QAAQ,eAAe,WAAW;AAC1D;AAUO,SAAS,oBAAoB,UAA2B;AAC7D,MACE,CAAC,SAAS,SAAS,KAAK,KACxB,aAAa,SACb,UAAU,SAAS,QAAQ,MAAM,UACjC;AACA,UAAM,IAAI,MAAM,yBAAyB,QAAQ,sBAAsB;AAAA,EACzE;AACA,SAAO;AACT;AASA,eAAsB,iBAAiB,UAAoC;AACzE,QAAM,SAAS,MAAM,OAAO,QAAQ;AACpC,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR,oBAAoB,QAAQ;AAAA,IAC9B;AAAA,EACF;AACA,SAAO;AACT;AAUA,eAAsB,gBACpB,SACA,WACkB;AAClB,QAAM,SAAS,MAAM,YAAY,SAAS,SAAS;AACnD,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR,oBAAoB,OAAO;AAAA,IAC7B;AAAA,EACF;AACA,SAAO;AACT;AAUA,eAAsB,iBACpB,UACA,cACA,IACe;AACf,QAAM,WAAW,UAAU,KAAK,GAAG,OAAO,GAAG,QAAQ;AACrD,QAAM,GAAG,MAAM,UAAU,QAAQ,QAAQ,GAAG,EAAE,WAAW,KAAK,CAAC;AAC/D,QAAM,GAAG,UAAU,UAAU,YAAY;AACzC,MAAI;AACF,UAAM,GAAG,QAAQ;AAAA,EACnB,UAAE;AACA,QAAI,MAAM,OAAO,QAAQ,GAAG;AAC1B,YAAM,GAAG,OAAO,QAAQ;AAAA,IAC1B;AAAA,EACF;AACF","sourcesContent":["import type { Json } from '@metamask/utils';\nimport { promises as fs } from 'fs';\nimport os from 'os';\nimport pathUtils from 'path';\n\nimport { parseJson } from './json';\nimport type { VirtualFile } from './virtual-file';\nimport { readVirtualFile } from './virtual-file/node';\n\n/**\n * Checks whether the given path string resolves to an existing directory, and\n * optionally creates the directory if it doesn't exist.\n *\n * @param pathString - The path string to check.\n * @param createDir - Whether to create the directory if it doesn't exist.\n * @returns Whether the given path is an existing directory.\n */\nexport async function isDirectory(\n  pathString: string,\n  createDir: boolean,\n): Promise<boolean> {\n  try {\n    const stats = await fs.stat(pathString);\n    return stats.isDirectory();\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      if (!createDir) {\n        return false;\n      }\n\n      await fs.mkdir(pathString, { recursive: true });\n      return true;\n    }\n\n    return false;\n  }\n}\n\n/**\n * Checks whether the given path string resolves to an existing file.\n *\n * @param pathString - The path string to check.\n * @returns Whether the given path is an existing file.\n */\nexport async function isFile(pathString: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(pathString);\n    return stats.isFile();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Reads a `.json` file, parses its contents, and returns them.\n *\n * @param pathString - The path to the JSON file.\n * @returns The parsed contents of the JSON file.\n */\nexport async function readJsonFile<Type extends Json = Json>(\n  pathString: string,\n): Promise<VirtualFile<Type>> {\n  if (!pathString.endsWith('.json')) {\n    throw new Error('The specified file must be a \".json\" file.');\n  }\n\n  let file;\n  try {\n    file = await readVirtualFile(pathString, 'utf8');\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw new Error(\n        `Could not find '${pathString}'. Please ensure that the file exists.`,\n      );\n    }\n\n    throw error;\n  }\n  file.result = parseJson(file.toString());\n  return file as VirtualFile<Type>;\n}\n\n/**\n * Gets the complete out file path from an output file name and parent\n * directory path.\n *\n * @param outDir - The path to the out file's parent directory.\n * @param outFileName - The out file's name.\n * @returns The complete path to the out file.\n */\nexport function getOutfilePath(outDir: string, outFileName: string): string {\n  return pathUtils.join(outDir, outFileName || 'bundle.js');\n}\n\n/**\n * Ensures that the outfile name is just a `.js` file name.\n * Throws on validation failure.\n *\n * @param filename - The file name to validate.\n * @returns `true` if validation succeeded.\n * @throws If the file name is invalid.\n */\nexport function validateOutfileName(filename: string): boolean {\n  if (\n    !filename.endsWith('.js') ||\n    filename === '.js' ||\n    pathUtils.basename(filename) !== filename\n  ) {\n    throw new Error(`Invalid outfile name: ${filename}. Must be a .js file`);\n  }\n  return true;\n}\n\n/**\n * Validates a file path. Throws on validation failure.\n *\n * @param filePath - The file path to validate.\n * @returns `true` if validation succeeded.\n * @throws If the path does not resolve to a file.\n */\nexport async function validateFilePath(filePath: string): Promise<boolean> {\n  const exists = await isFile(filePath);\n  if (!exists) {\n    throw new Error(\n      `Invalid params: '${filePath}' is not a file or does not exist.`,\n    );\n  }\n  return true;\n}\n\n/**\n * Validates a directory path. Throws on validation failure.\n *\n * @param dirPath - The directory path to validate.\n * @param createDir - Whether to create the directory if it doesn't exist.\n * @returns `true` if validation succeeded or the directory was created.\n * @throws If the directory does not exist or could not be created.\n */\nexport async function validateDirPath(\n  dirPath: string,\n  createDir: boolean,\n): Promise<boolean> {\n  const exists = await isDirectory(dirPath, createDir);\n  if (!exists) {\n    throw new Error(\n      `Invalid params: '${dirPath}' is not a directory or could not be created.`,\n    );\n  }\n  return true;\n}\n\n/**\n * Creates a temporary file with a given name and content, writes it to disk and calls the provided function.\n * This function handles deletion of the temporary file after usage.\n *\n * @param fileName - The name of the temporary file.\n * @param fileContents - The content of the temporary file.\n * @param fn - The callback function to call when the temporary file has been created.\n */\nexport async function useTemporaryFile(\n  fileName: string,\n  fileContents: string,\n  fn: (path: string) => Promise<unknown>,\n): Promise<void> {\n  const filePath = pathUtils.join(os.tmpdir(), fileName);\n  await fs.mkdir(pathUtils.dirname(filePath), { recursive: true });\n  await fs.writeFile(filePath, fileContents);\n  try {\n    await fn(filePath);\n  } finally {\n    if (await isFile(filePath)) {\n      await fs.unlink(filePath);\n    }\n  }\n}\n"]}