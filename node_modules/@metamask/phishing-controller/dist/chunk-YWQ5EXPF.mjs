var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/PhishingController.ts
import { BaseController } from "@metamask/base-controller";
import { safelyExecute } from "@metamask/controller-utils";
import PhishingDetector from "eth-phishing-detect/src/detector";
import { toASCII } from "punycode/";
var PHISHING_CONFIG_BASE_URL = "https://phishing-detection.metafi.codefi.network";
var METAMASK_STALELIST_FILE = "/v1/stalelist";
var METAMASK_HOTLIST_DIFF_FILE = "/v1/diffsSince";
var HOTLIST_REFRESH_INTERVAL = 30 * 60;
var STALELIST_REFRESH_INTERVAL = 4 * 24 * 60 * 60;
var METAMASK_STALELIST_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_STALELIST_FILE}`;
var METAMASK_HOTLIST_DIFF_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_HOTLIST_DIFF_FILE}`;
var ListKeys = /* @__PURE__ */ ((ListKeys2) => {
  ListKeys2["PhishfortHotlist"] = "phishfort_hotlist";
  ListKeys2["EthPhishingDetectConfig"] = "eth_phishing_detect_config";
  return ListKeys2;
})(ListKeys || {});
var ListNames = /* @__PURE__ */ ((ListNames2) => {
  ListNames2["MetaMask"] = "MetaMask";
  ListNames2["Phishfort"] = "Phishfort";
  return ListNames2;
})(ListNames || {});
var phishingListNameKeyMap = {
  ["Phishfort" /* Phishfort */]: "phishfort_hotlist" /* PhishfortHotlist */,
  ["MetaMask" /* MetaMask */]: "eth_phishing_detect_config" /* EthPhishingDetectConfig */
};
var phishingListKeyNameMap = {
  ["eth_phishing_detect_config" /* EthPhishingDetectConfig */]: "MetaMask" /* MetaMask */,
  ["phishfort_hotlist" /* PhishfortHotlist */]: "Phishfort" /* Phishfort */
};
var controllerName = "PhishingController";
var metadata = {
  phishingLists: { persist: true, anonymous: false },
  whitelist: { persist: true, anonymous: false },
  hotlistLastFetched: { persist: true, anonymous: false },
  stalelistLastFetched: { persist: true, anonymous: false }
};
var getDefaultState = () => {
  return {
    phishingLists: [],
    whitelist: [],
    hotlistLastFetched: 0,
    stalelistLastFetched: 0
  };
};
var _detector, _stalelistRefreshInterval, _hotlistRefreshInterval, _inProgressHotlistUpdate, _inProgressStalelistUpdate, _registerMessageHandlers, registerMessageHandlers_fn, _updateStalelist, updateStalelist_fn, _updateHotlist, updateHotlist_fn, _queryConfig, queryConfig_fn;
var PhishingController = class extends BaseController {
  /**
   * Construct a Phishing Controller.
   *
   * @param config - Initial options used to configure this controller.
   * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.
   * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.
   * @param config.messenger - The controller restricted messenger.
   * @param config.state - Initial state to set on this controller.
   */
  constructor({
    stalelistRefreshInterval = STALELIST_REFRESH_INTERVAL,
    hotlistRefreshInterval = HOTLIST_REFRESH_INTERVAL,
    messenger,
    state = {}
  }) {
    super({
      name: controllerName,
      metadata,
      messenger,
      state: {
        ...getDefaultState(),
        ...state
      }
    });
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    __privateAdd(this, _registerMessageHandlers);
    /**
     * Update the stalelist configuration.
     *
     * This should only be called from the `updateStalelist` function, which is a wrapper around
     * this function that prevents redundant configuration updates.
     */
    __privateAdd(this, _updateStalelist);
    /**
     * Update the stalelist configuration.
     *
     * This should only be called from the `updateStalelist` function, which is a wrapper around
     * this function that prevents redundant configuration updates.
     */
    __privateAdd(this, _updateHotlist);
    __privateAdd(this, _queryConfig);
    // TODO: Replace `any` with type
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __privateAdd(this, _detector, void 0);
    __privateAdd(this, _stalelistRefreshInterval, void 0);
    __privateAdd(this, _hotlistRefreshInterval, void 0);
    __privateAdd(this, _inProgressHotlistUpdate, void 0);
    __privateAdd(this, _inProgressStalelistUpdate, void 0);
    __privateSet(this, _stalelistRefreshInterval, stalelistRefreshInterval);
    __privateSet(this, _hotlistRefreshInterval, hotlistRefreshInterval);
    __privateMethod(this, _registerMessageHandlers, registerMessageHandlers_fn).call(this);
    this.updatePhishingDetector();
  }
  /**
   * Updates this.detector with an instance of PhishingDetector using the current state.
   */
  updatePhishingDetector() {
    __privateSet(this, _detector, new PhishingDetector(this.state.phishingLists));
  }
  /**
   * Set the interval at which the stale phishing list will be refetched.
   * Fetching will only occur on the next call to test/bypass.
   * For immediate update to the phishing list, call {@link updateStalelist} directly.
   *
   * @param interval - the new interval, in ms.
   */
  setStalelistRefreshInterval(interval) {
    __privateSet(this, _stalelistRefreshInterval, interval);
  }
  /**
   * Set the interval at which the hot list will be refetched.
   * Fetching will only occur on the next call to test/bypass.
   * For immediate update to the phishing list, call {@link updateHotlist} directly.
   *
   * @param interval - the new interval, in ms.
   */
  setHotlistRefreshInterval(interval) {
    __privateSet(this, _hotlistRefreshInterval, interval);
  }
  /**
   * Determine if an update to the stalelist configuration is needed.
   *
   * @returns Whether an update is needed
   */
  isStalelistOutOfDate() {
    return fetchTimeNow() - this.state.stalelistLastFetched >= __privateGet(this, _stalelistRefreshInterval);
  }
  /**
   * Determine if an update to the hotlist configuration is needed.
   *
   * @returns Whether an update is needed
   */
  isHotlistOutOfDate() {
    return fetchTimeNow() - this.state.hotlistLastFetched >= __privateGet(this, _hotlistRefreshInterval);
  }
  /**
   * Conditionally update the phishing configuration.
   *
   * If the stalelist configuration is out of date, this function will call `updateStalelist`
   * to update the configuration. This will automatically grab the hotlist,
   * so it isn't necessary to continue on to download the hotlist.
   *
   */
  async maybeUpdateState() {
    const staleListOutOfDate = this.isStalelistOutOfDate();
    if (staleListOutOfDate) {
      await this.updateStalelist();
      return;
    }
    const hotlistOutOfDate = this.isHotlistOutOfDate();
    if (hotlistOutOfDate) {
      await this.updateHotlist();
    }
  }
  /**
   * Determines if a given origin is unapproved.
   *
   * It is strongly recommended that you call {@link maybeUpdateState} before calling this,
   * to check whether the phishing configuration is up-to-date. It will be updated if necessary
   * by calling {@link updateStalelist} or {@link updateHotlist}.
   *
   * @param origin - Domain origin of a website.
   * @returns Whether the origin is an unapproved origin.
   */
  test(origin) {
    const punycodeOrigin = toASCII(origin);
    if (this.state.whitelist.includes(punycodeOrigin)) {
      return { result: false, type: "all" };
    }
    return __privateGet(this, _detector).check(punycodeOrigin);
  }
  /**
   * Temporarily marks a given origin as approved.
   *
   * @param origin - The origin to mark as approved.
   */
  bypass(origin) {
    const punycodeOrigin = toASCII(origin);
    const { whitelist } = this.state;
    if (whitelist.includes(punycodeOrigin)) {
      return;
    }
    this.update((draftState) => {
      draftState.whitelist.push(punycodeOrigin);
    });
  }
  /**
   * Update the hotlist.
   *
   * If an update is in progress, no additional update will be made. Instead this will wait until
   * the in-progress update has finished.
   */
  async updateHotlist() {
    if (__privateGet(this, _inProgressHotlistUpdate)) {
      await __privateGet(this, _inProgressHotlistUpdate);
      return;
    }
    try {
      __privateSet(this, _inProgressHotlistUpdate, __privateMethod(this, _updateHotlist, updateHotlist_fn).call(this));
      await __privateGet(this, _inProgressHotlistUpdate);
    } finally {
      __privateSet(this, _inProgressHotlistUpdate, void 0);
    }
  }
  /**
   * Update the stalelist.
   *
   * If an update is in progress, no additional update will be made. Instead this will wait until
   * the in-progress update has finished.
   */
  async updateStalelist() {
    if (__privateGet(this, _inProgressStalelistUpdate)) {
      await __privateGet(this, _inProgressStalelistUpdate);
      return;
    }
    try {
      __privateSet(this, _inProgressStalelistUpdate, __privateMethod(this, _updateStalelist, updateStalelist_fn).call(this));
      await __privateGet(this, _inProgressStalelistUpdate);
    } finally {
      __privateSet(this, _inProgressStalelistUpdate, void 0);
    }
  }
};
_detector = new WeakMap();
_stalelistRefreshInterval = new WeakMap();
_hotlistRefreshInterval = new WeakMap();
_inProgressHotlistUpdate = new WeakMap();
_inProgressStalelistUpdate = new WeakMap();
_registerMessageHandlers = new WeakSet();
registerMessageHandlers_fn = function() {
  this.messagingSystem.registerActionHandler(
    `${controllerName}:maybeUpdateState`,
    this.maybeUpdateState.bind(this)
  );
  this.messagingSystem.registerActionHandler(
    `${controllerName}:testOrigin`,
    this.test.bind(this)
  );
};
_updateStalelist = new WeakSet();
updateStalelist_fn = async function() {
  let stalelistResponse;
  let hotlistDiffsResponse;
  try {
    stalelistResponse = await __privateMethod(this, _queryConfig, queryConfig_fn).call(this, METAMASK_STALELIST_URL).then((d) => d);
    if (stalelistResponse?.data && stalelistResponse.data.lastUpdated > 0) {
      hotlistDiffsResponse = await __privateMethod(this, _queryConfig, queryConfig_fn).call(this, `${METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`);
    }
  } finally {
    const timeNow = fetchTimeNow();
    this.update((draftState) => {
      draftState.stalelistLastFetched = timeNow;
      draftState.hotlistLastFetched = timeNow;
    });
  }
  if (!stalelistResponse || !hotlistDiffsResponse) {
    return;
  }
  const { phishfort_hotlist, eth_phishing_detect_config, ...partialState } = stalelistResponse.data;
  const phishfortListState = {
    ...phishfort_hotlist,
    ...partialState,
    fuzzylist: [],
    // Phishfort hotlist doesn't contain a fuzzylist
    allowlist: [],
    // Phishfort hotlist doesn't contain an allowlist
    name: phishingListKeyNameMap.phishfort_hotlist
  };
  const metamaskListState = {
    ...eth_phishing_detect_config,
    ...partialState,
    name: phishingListKeyNameMap.eth_phishing_detect_config
  };
  const newPhishfortListState = applyDiffs(
    phishfortListState,
    hotlistDiffsResponse.data,
    "phishfort_hotlist" /* PhishfortHotlist */
  );
  const newMetaMaskListState = applyDiffs(
    metamaskListState,
    hotlistDiffsResponse.data,
    "eth_phishing_detect_config" /* EthPhishingDetectConfig */
  );
  this.update((draftState) => {
    draftState.phishingLists = [newMetaMaskListState, newPhishfortListState];
  });
  this.updatePhishingDetector();
};
_updateHotlist = new WeakSet();
updateHotlist_fn = async function() {
  const lastDiffTimestamp = Math.max(
    ...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated)
  );
  let hotlistResponse;
  try {
    hotlistResponse = await __privateMethod(this, _queryConfig, queryConfig_fn).call(this, `${METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`);
  } finally {
    this.update((draftState) => {
      draftState.hotlistLastFetched = fetchTimeNow();
    });
  }
  if (!hotlistResponse?.data) {
    return;
  }
  const hotlist = hotlistResponse.data;
  const newPhishingLists = this.state.phishingLists.map(
    (phishingList) => applyDiffs(
      phishingList,
      hotlist,
      phishingListNameKeyMap[phishingList.name]
    )
  );
  this.update((draftState) => {
    draftState.phishingLists = newPhishingLists;
  });
  this.updatePhishingDetector();
};
_queryConfig = new WeakSet();
queryConfig_fn = async function(input) {
  const response = await safelyExecute(
    () => fetch(input, { cache: "no-cache" }),
    true
  );
  switch (response?.status) {
    case 200: {
      return await response.json();
    }
    default: {
      return null;
    }
  }
};
var PhishingController_default = PhishingController;

// src/utils.ts
var fetchTimeNow = () => Math.round(Date.now() / 1e3);
var splitStringByPeriod = (stringToSplit) => {
  const periodIndex = stringToSplit.indexOf(".");
  return [
    stringToSplit.slice(0, periodIndex),
    stringToSplit.slice(periodIndex + 1)
  ];
};
var applyDiffs = (listState, hotlistDiffs, listKey) => {
  const diffsToApply = hotlistDiffs.filter(
    ({ timestamp, targetList }) => timestamp > listState.lastUpdated && splitStringByPeriod(targetList)[0] === listKey
  );
  let latestDiffTimestamp = listState.lastUpdated;
  const listSets = {
    allowlist: new Set(listState.allowlist),
    blocklist: new Set(listState.blocklist),
    fuzzylist: new Set(listState.fuzzylist)
  };
  for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {
    const targetListType = splitStringByPeriod(targetList)[1];
    if (timestamp > latestDiffTimestamp) {
      latestDiffTimestamp = timestamp;
    }
    if (isRemoval) {
      listSets[targetListType].delete(url);
    } else {
      listSets[targetListType].add(url);
    }
  }
  return {
    allowlist: Array.from(listSets.allowlist),
    blocklist: Array.from(listSets.blocklist),
    fuzzylist: Array.from(listSets.fuzzylist),
    version: listState.version,
    name: phishingListKeyNameMap[listKey],
    tolerance: listState.tolerance,
    lastUpdated: latestDiffTimestamp
  };
};

export {
  fetchTimeNow,
  applyDiffs,
  PHISHING_CONFIG_BASE_URL,
  METAMASK_STALELIST_FILE,
  METAMASK_HOTLIST_DIFF_FILE,
  HOTLIST_REFRESH_INTERVAL,
  STALELIST_REFRESH_INTERVAL,
  METAMASK_STALELIST_URL,
  METAMASK_HOTLIST_DIFF_URL,
  ListKeys,
  ListNames,
  phishingListKeyNameMap,
  PhishingController,
  PhishingController_default
};
//# sourceMappingURL=chunk-YWQ5EXPF.mjs.map