{"version":3,"sources":["../src/PhishingController.ts","../src/utils.ts"],"names":["ListKeys","ListNames"],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport { safelyExecute } from '@metamask/controller-utils';\nimport PhishingDetector from 'eth-phishing-detect/src/detector';\nimport { toASCII } from 'punycode/';\n\nimport { applyDiffs, fetchTimeNow } from './utils';\n\nexport const PHISHING_CONFIG_BASE_URL =\n  'https://phishing-detection.metafi.codefi.network';\n\nexport const METAMASK_STALELIST_FILE = '/v1/stalelist';\n\nexport const METAMASK_HOTLIST_DIFF_FILE = '/v1/diffsSince';\n\nexport const HOTLIST_REFRESH_INTERVAL = 30 * 60; // 30 mins in seconds\nexport const STALELIST_REFRESH_INTERVAL = 4 * 24 * 60 * 60; // 4 days in seconds\n\nexport const METAMASK_STALELIST_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_STALELIST_FILE}`;\nexport const METAMASK_HOTLIST_DIFF_URL = `${PHISHING_CONFIG_BASE_URL}${METAMASK_HOTLIST_DIFF_FILE}`;\n\n/**\n * @type ListTypes\n *\n * Type outlining the types of lists provided by aggregating different source lists\n */\nexport type ListTypes = 'fuzzylist' | 'blocklist' | 'allowlist';\n\n/**\n * @type EthPhishingResponse\n *\n * Configuration response from the eth-phishing-detect package\n * consisting of approved and unapproved website origins\n * @property blacklist - List of unapproved origins\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property version - Version number of this configuration\n * @property whitelist - List of approved origins\n */\nexport type EthPhishingResponse = {\n  blacklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  whitelist: string[];\n};\n\n/**\n * @type PhishingStalelist\n *\n * type defining expected type of the stalelist.json file.\n * @property eth_phishing_detect_config - Stale list sourced from eth-phishing-detect's config.json.\n * @property phishfort_hotlist - Stale list sourced from phishfort's hotlist.json. Only includes blocklist. Deduplicated entries from eth_phishing_detect_config.\n * @property tolerance - Fuzzy match tolerance level\n * @property lastUpdated - Timestamp of last update.\n * @property version - Stalelist data structure iteration.\n */\nexport type PhishingStalelist = {\n  eth_phishing_detect_config: Record<ListTypes, string[]>;\n  phishfort_hotlist: Record<ListTypes, string[]>;\n  tolerance: number;\n  version: number;\n  lastUpdated: number;\n};\n\n/**\n * @type PhishingListState\n *\n * type defining the persisted list state. This is the persisted state that is updated frequently with `this.maybeUpdateState()`.\n * @property allowlist - List of approved origins (legacy naming \"whitelist\")\n * @property blocklist - List of unapproved origins (legacy naming \"blacklist\")\n * @property fuzzylist - List of fuzzy-matched unapproved origins\n * @property tolerance - Fuzzy match tolerance level\n * @property lastUpdated - Timestamp of last update.\n * @property version - Version of the phishing list state.\n * @property name - Name of the list. Used for attribution.\n */\nexport type PhishingListState = {\n  allowlist: string[];\n  blocklist: string[];\n  fuzzylist: string[];\n  tolerance: number;\n  version: number;\n  lastUpdated: number;\n  name: ListNames;\n};\n\n/**\n * @type EthPhishingDetectResult\n *\n * type that describes the result of the `test` method.\n * @property name - Name of the config on which a match was found.\n * @property version - Version of the config on which a match was found.\n * @property result - Whether a domain was detected as a phishing domain. True means an unsafe domain.\n * @property match - The matching fuzzylist origin when a fuzzylist match is found. Returned as undefined for non-fuzzy true results.\n * @property type - The field of the config on which a match was found.\n */\nexport type EthPhishingDetectResult = {\n  name?: string;\n  version?: string;\n  result: boolean;\n  match?: string; // Returned as undefined for non-fuzzy true results.\n  type: 'all' | 'fuzzy' | 'blocklist' | 'allowlist';\n};\n\n/**\n * @type HotlistDiff\n *\n * type defining the expected type of the diffs in hotlist.json file.\n * @property url - Url of the diff entry.\n * @property timestamp - Timestamp at which the diff was identified.\n * @property targetList - The list name where the diff was identified.\n * @property isRemoval - Was the diff identified a removal type.\n */\nexport type HotlistDiff = {\n  url: string;\n  timestamp: number;\n  targetList: `${ListKeys}.${ListTypes}`;\n  isRemoval?: boolean;\n};\n\nexport type DataResultWrapper<T> = {\n  data: T;\n};\n\n/**\n * @type Hotlist\n *\n * Type defining expected hotlist.json file.\n * @property url - Url of the diff entry.\n * @property timestamp - Timestamp at which the diff was identified.\n * @property targetList - The list name where the diff was identified.\n * @property isRemoval - Was the diff identified a removal type.\n */\nexport type Hotlist = HotlistDiff[];\n\n/**\n * Enum containing upstream data provider source list keys.\n * These are the keys denoting lists consumed by the upstream data provider.\n */\nexport enum ListKeys {\n  PhishfortHotlist = 'phishfort_hotlist',\n  EthPhishingDetectConfig = 'eth_phishing_detect_config',\n}\n\n/**\n * Enum containing downstream client attribution names.\n */\nexport enum ListNames {\n  MetaMask = 'MetaMask',\n  Phishfort = 'Phishfort',\n}\n\n/**\n * Maps from downstream client attribution name\n * to list key sourced from upstream data provider.\n */\nconst phishingListNameKeyMap = {\n  [ListNames.Phishfort]: ListKeys.PhishfortHotlist,\n  [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,\n};\n\n/**\n * Maps from list key sourced from upstream data\n * provider to downstream client attribution name.\n */\nexport const phishingListKeyNameMap = {\n  [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,\n  [ListKeys.PhishfortHotlist]: ListNames.Phishfort,\n};\n\nconst controllerName = 'PhishingController';\n\nconst metadata = {\n  phishingLists: { persist: true, anonymous: false },\n  whitelist: { persist: true, anonymous: false },\n  hotlistLastFetched: { persist: true, anonymous: false },\n  stalelistLastFetched: { persist: true, anonymous: false },\n};\n\n/**\n * Get a default empty state for the controller.\n * @returns The default empty state.\n */\nconst getDefaultState = (): PhishingControllerState => {\n  return {\n    phishingLists: [],\n    whitelist: [],\n    hotlistLastFetched: 0,\n    stalelistLastFetched: 0,\n  };\n};\n\n/**\n * @type PhishingControllerState\n *\n * Phishing controller state\n * @property phishing - eth-phishing-detect configuration\n * @property whitelist - array of temporarily-approved origins\n */\nexport type PhishingControllerState = {\n  phishingLists: PhishingListState[];\n  whitelist: string[];\n  hotlistLastFetched: number;\n  stalelistLastFetched: number;\n};\n\n/**\n * @type PhishingControllerOptions\n *\n * Phishing controller options\n * @property stalelistRefreshInterval - Polling interval used to fetch stale list.\n * @property hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.\n */\nexport type PhishingControllerOptions = {\n  stalelistRefreshInterval?: number;\n  hotlistRefreshInterval?: number;\n  messenger: PhishingControllerMessenger;\n  state?: Partial<PhishingControllerState>;\n};\n\nexport type MaybeUpdateState = {\n  type: `${typeof controllerName}:maybeUpdateState`;\n  handler: PhishingController['maybeUpdateState'];\n};\n\nexport type TestOrigin = {\n  type: `${typeof controllerName}:testOrigin`;\n  handler: PhishingController['test'];\n};\n\nexport type PhishingControllerActions = MaybeUpdateState | TestOrigin;\n\nexport type PhishingControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  PhishingControllerActions,\n  never,\n  never,\n  never\n>;\n\n/**\n * Controller that manages community-maintained lists of approved and unapproved website origins.\n */\nexport class PhishingController extends BaseController<\n  typeof controllerName,\n  PhishingControllerState,\n  PhishingControllerMessenger\n> {\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #detector: any;\n\n  #stalelistRefreshInterval: number;\n\n  #hotlistRefreshInterval: number;\n\n  #inProgressHotlistUpdate?: Promise<void>;\n\n  #inProgressStalelistUpdate?: Promise<void>;\n\n  /**\n   * Construct a Phishing Controller.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.\n   * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.\n   * @param config.messenger - The controller restricted messenger.\n   * @param config.state - Initial state to set on this controller.\n   */\n  constructor({\n    stalelistRefreshInterval = STALELIST_REFRESH_INTERVAL,\n    hotlistRefreshInterval = HOTLIST_REFRESH_INTERVAL,\n    messenger,\n    state = {},\n  }: PhishingControllerOptions) {\n    super({\n      name: controllerName,\n      metadata,\n      messenger,\n      state: {\n        ...getDefaultState(),\n        ...state,\n      },\n    });\n\n    this.#stalelistRefreshInterval = stalelistRefreshInterval;\n    this.#hotlistRefreshInterval = hotlistRefreshInterval;\n    this.#registerMessageHandlers();\n\n    this.updatePhishingDetector();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:maybeUpdateState` as const,\n      this.maybeUpdateState.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:testOrigin` as const,\n      this.test.bind(this),\n    );\n  }\n\n  /**\n   * Updates this.detector with an instance of PhishingDetector using the current state.\n   */\n  updatePhishingDetector() {\n    this.#detector = new PhishingDetector(this.state.phishingLists);\n  }\n\n  /**\n   * Set the interval at which the stale phishing list will be refetched.\n   * Fetching will only occur on the next call to test/bypass.\n   * For immediate update to the phishing list, call {@link updateStalelist} directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setStalelistRefreshInterval(interval: number) {\n    this.#stalelistRefreshInterval = interval;\n  }\n\n  /**\n   * Set the interval at which the hot list will be refetched.\n   * Fetching will only occur on the next call to test/bypass.\n   * For immediate update to the phishing list, call {@link updateHotlist} directly.\n   *\n   * @param interval - the new interval, in ms.\n   */\n  setHotlistRefreshInterval(interval: number) {\n    this.#hotlistRefreshInterval = interval;\n  }\n\n  /**\n   * Determine if an update to the stalelist configuration is needed.\n   *\n   * @returns Whether an update is needed\n   */\n  isStalelistOutOfDate() {\n    return (\n      fetchTimeNow() - this.state.stalelistLastFetched >=\n      this.#stalelistRefreshInterval\n    );\n  }\n\n  /**\n   * Determine if an update to the hotlist configuration is needed.\n   *\n   * @returns Whether an update is needed\n   */\n  isHotlistOutOfDate() {\n    return (\n      fetchTimeNow() - this.state.hotlistLastFetched >=\n      this.#hotlistRefreshInterval\n    );\n  }\n\n  /**\n   * Conditionally update the phishing configuration.\n   *\n   * If the stalelist configuration is out of date, this function will call `updateStalelist`\n   * to update the configuration. This will automatically grab the hotlist,\n   * so it isn't necessary to continue on to download the hotlist.\n   *\n   */\n  async maybeUpdateState() {\n    const staleListOutOfDate = this.isStalelistOutOfDate();\n    if (staleListOutOfDate) {\n      await this.updateStalelist();\n      return;\n    }\n    const hotlistOutOfDate = this.isHotlistOutOfDate();\n    if (hotlistOutOfDate) {\n      await this.updateHotlist();\n    }\n  }\n\n  /**\n   * Determines if a given origin is unapproved.\n   *\n   * It is strongly recommended that you call {@link maybeUpdateState} before calling this,\n   * to check whether the phishing configuration is up-to-date. It will be updated if necessary\n   * by calling {@link updateStalelist} or {@link updateHotlist}.\n   *\n   * @param origin - Domain origin of a website.\n   * @returns Whether the origin is an unapproved origin.\n   */\n  test(origin: string): EthPhishingDetectResult {\n    const punycodeOrigin = toASCII(origin);\n    if (this.state.whitelist.includes(punycodeOrigin)) {\n      return { result: false, type: 'all' }; // Same as whitelisted match returned by detector.check(...).\n    }\n    return this.#detector.check(punycodeOrigin);\n  }\n\n  /**\n   * Temporarily marks a given origin as approved.\n   *\n   * @param origin - The origin to mark as approved.\n   */\n  bypass(origin: string) {\n    const punycodeOrigin = toASCII(origin);\n    const { whitelist } = this.state;\n    if (whitelist.includes(punycodeOrigin)) {\n      return;\n    }\n    this.update((draftState) => {\n      draftState.whitelist.push(punycodeOrigin);\n    });\n  }\n\n  /**\n   * Update the hotlist.\n   *\n   * If an update is in progress, no additional update will be made. Instead this will wait until\n   * the in-progress update has finished.\n   */\n  async updateHotlist() {\n    if (this.#inProgressHotlistUpdate) {\n      await this.#inProgressHotlistUpdate;\n      return;\n    }\n\n    try {\n      this.#inProgressHotlistUpdate = this.#updateHotlist();\n      await this.#inProgressHotlistUpdate;\n    } finally {\n      this.#inProgressHotlistUpdate = undefined;\n    }\n  }\n\n  /**\n   * Update the stalelist.\n   *\n   * If an update is in progress, no additional update will be made. Instead this will wait until\n   * the in-progress update has finished.\n   */\n  async updateStalelist() {\n    if (this.#inProgressStalelistUpdate) {\n      await this.#inProgressStalelistUpdate;\n      return;\n    }\n\n    try {\n      this.#inProgressStalelistUpdate = this.#updateStalelist();\n      await this.#inProgressStalelistUpdate;\n    } finally {\n      this.#inProgressStalelistUpdate = undefined;\n    }\n  }\n\n  /**\n   * Update the stalelist configuration.\n   *\n   * This should only be called from the `updateStalelist` function, which is a wrapper around\n   * this function that prevents redundant configuration updates.\n   */\n  async #updateStalelist() {\n    let stalelistResponse;\n    let hotlistDiffsResponse;\n    try {\n      stalelistResponse = await this.#queryConfig<\n        DataResultWrapper<PhishingStalelist>\n      >(METAMASK_STALELIST_URL).then((d) => d);\n\n      // Fetching hotlist diffs relies on having a lastUpdated timestamp to do `GET /v1/diffsSince/:timestamp`,\n      // so it doesn't make sense to call if there is not a timestamp to begin with.\n      if (stalelistResponse?.data && stalelistResponse.data.lastUpdated > 0) {\n        hotlistDiffsResponse = await this.#queryConfig<\n          DataResultWrapper<Hotlist>\n        >(`${METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`);\n      }\n    } finally {\n      // Set `stalelistLastFetched` and `hotlistLastFetched` even for failed requests to prevent server\n      // from being overwhelmed with traffic after a network disruption.\n      const timeNow = fetchTimeNow();\n      this.update((draftState) => {\n        draftState.stalelistLastFetched = timeNow;\n        draftState.hotlistLastFetched = timeNow;\n      });\n    }\n\n    if (!stalelistResponse || !hotlistDiffsResponse) {\n      return;\n    }\n\n    const { phishfort_hotlist, eth_phishing_detect_config, ...partialState } =\n      stalelistResponse.data;\n\n    const phishfortListState: PhishingListState = {\n      ...phishfort_hotlist,\n      ...partialState,\n      fuzzylist: [], // Phishfort hotlist doesn't contain a fuzzylist\n      allowlist: [], // Phishfort hotlist doesn't contain an allowlist\n      name: phishingListKeyNameMap.phishfort_hotlist,\n    };\n    const metamaskListState: PhishingListState = {\n      ...eth_phishing_detect_config,\n      ...partialState,\n      name: phishingListKeyNameMap.eth_phishing_detect_config,\n    };\n    // Correctly shaping eth-phishing-detect state by applying hotlist diffs to the stalelist.\n    const newPhishfortListState: PhishingListState = applyDiffs(\n      phishfortListState,\n      hotlistDiffsResponse.data,\n      ListKeys.PhishfortHotlist,\n    );\n    const newMetaMaskListState: PhishingListState = applyDiffs(\n      metamaskListState,\n      hotlistDiffsResponse.data,\n      ListKeys.EthPhishingDetectConfig,\n    );\n\n    this.update((draftState) => {\n      draftState.phishingLists = [newMetaMaskListState, newPhishfortListState];\n    });\n    this.updatePhishingDetector();\n  }\n\n  /**\n   * Update the stalelist configuration.\n   *\n   * This should only be called from the `updateStalelist` function, which is a wrapper around\n   * this function that prevents redundant configuration updates.\n   */\n  async #updateHotlist() {\n    const lastDiffTimestamp = Math.max(\n      ...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated),\n    );\n    let hotlistResponse: DataResultWrapper<Hotlist> | null;\n\n    try {\n      hotlistResponse = await this.#queryConfig<DataResultWrapper<Hotlist>>(\n        `${METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`,\n      );\n    } finally {\n      // Set `hotlistLastFetched` even for failed requests to prevent server from being overwhelmed with\n      // traffic after a network disruption.\n      this.update((draftState) => {\n        draftState.hotlistLastFetched = fetchTimeNow();\n      });\n    }\n\n    if (!hotlistResponse?.data) {\n      return;\n    }\n    const hotlist = hotlistResponse.data;\n    const newPhishingLists = this.state.phishingLists.map((phishingList) =>\n      applyDiffs(\n        phishingList,\n        hotlist,\n        phishingListNameKeyMap[phishingList.name],\n      ),\n    );\n\n    this.update((draftState) => {\n      draftState.phishingLists = newPhishingLists;\n    });\n    this.updatePhishingDetector();\n  }\n\n  async #queryConfig<ResponseType>(\n    input: RequestInfo,\n  ): Promise<ResponseType | null> {\n    const response = await safelyExecute(\n      () => fetch(input, { cache: 'no-cache' }),\n      true,\n    );\n\n    switch (response?.status) {\n      case 200: {\n        return await response.json();\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n}\n\nexport default PhishingController;\n","import type {\n  Hotlist,\n  ListKeys,\n  PhishingListState,\n} from './PhishingController';\nimport { phishingListKeyNameMap } from './PhishingController';\n/**\n * Fetches current epoch time in seconds.\n *\n * @returns the Date.now() time in seconds instead of miliseconds. backend files rely on timestamps in seconds since epoch.\n */\nexport const fetchTimeNow = (): number => Math.round(Date.now() / 1000);\n\n/**\n * Split a string into two pieces, using the first period as the delimiter.\n *\n * @param stringToSplit - The string to split.\n * @returns An array of length two containing the beginning and end of the string.\n */\nconst splitStringByPeriod = <Start extends string, End extends string>(\n  stringToSplit: `${Start}.${End}`,\n): [Start, End] => {\n  const periodIndex = stringToSplit.indexOf('.');\n  return [\n    stringToSplit.slice(0, periodIndex) as Start,\n    stringToSplit.slice(periodIndex + 1) as End,\n  ];\n};\n\n/**\n * Determines which diffs are applicable to the listState, then applies those diffs.\n *\n * @param listState - the stalelist or the existing liststate that diffs will be applied to.\n * @param hotlistDiffs - the diffs to apply to the listState if valid.\n * @param listKey - the key associated with the input/output phishing list state.\n * @returns the new list state\n */\nexport const applyDiffs = (\n  listState: PhishingListState,\n  hotlistDiffs: Hotlist,\n  listKey: ListKeys,\n): PhishingListState => {\n  // filter to remove diffs that were added before the lastUpdate time.\n  // filter to remove diffs that aren't applicable to the specified list (by listKey).\n  const diffsToApply = hotlistDiffs.filter(\n    ({ timestamp, targetList }) =>\n      timestamp > listState.lastUpdated &&\n      splitStringByPeriod(targetList)[0] === listKey,\n  );\n\n  // the reason behind using latestDiffTimestamp as the lastUpdated time\n  // is so that we can benefit server-side from memoization due to end client's\n  // `GET /v1/diffSince/:timestamp` requests lining up with\n  // our periodic updates (which create diffs at specific timestamps).\n  let latestDiffTimestamp = listState.lastUpdated;\n\n  const listSets = {\n    allowlist: new Set(listState.allowlist),\n    blocklist: new Set(listState.blocklist),\n    fuzzylist: new Set(listState.fuzzylist),\n  };\n  for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {\n    const targetListType = splitStringByPeriod(targetList)[1];\n    if (timestamp > latestDiffTimestamp) {\n      latestDiffTimestamp = timestamp;\n    }\n    if (isRemoval) {\n      listSets[targetListType].delete(url);\n    } else {\n      listSets[targetListType].add(url);\n    }\n  }\n\n  return {\n    allowlist: Array.from(listSets.allowlist),\n    blocklist: Array.from(listSets.blocklist),\n    fuzzylist: Array.from(listSets.fuzzylist),\n    version: listState.version,\n    name: phishingListKeyNameMap[listKey],\n    tolerance: listState.tolerance,\n    lastUpdated: latestDiffTimestamp,\n  };\n};\n"]}