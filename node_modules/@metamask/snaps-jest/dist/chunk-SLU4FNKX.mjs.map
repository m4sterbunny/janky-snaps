{"version":3,"sources":["../src/internals/server.ts"],"sourcesContent":["import type { SnapManifest } from '@metamask/snaps-utils';\nimport {\n  assertIsSnapManifest,\n  isDirectory,\n  isFile,\n} from '@metamask/snaps-utils/node';\nimport { createModuleLogger } from '@metamask/utils';\nimport express from 'express';\nimport { promises as fs } from 'fs';\nimport type { Server } from 'http';\nimport { createServer } from 'http';\nimport { resolve as pathResolve } from 'path';\n\nimport type { SnapsEnvironmentOptions } from '../options';\nimport { rootLogger } from './logger';\n\nexport type ServerOptions = Required<\n  // We need a double `Required` for the type to be inferred correctly.\n  Required<SnapsEnvironmentOptions>['server']\n>;\n\n/**\n * Check that:\n *\n * - The root directory exists.\n * - The root directory contains a `snap.manifest.json` file.\n * - The file path in the manifest exists.\n *\n * @param root - The root directory.\n * @throws If any of the checks fail.\n */\nasync function assertRoot(root: string) {\n  if (!root) {\n    throw new Error('You must specify a root directory.');\n  }\n\n  if (!(await isDirectory(root, false))) {\n    throw new Error(`Root directory \"${root}\" is not a directory.`);\n  }\n\n  const manifestPath = pathResolve(root, 'snap.manifest.json');\n  const manifest: SnapManifest = await fs\n    .readFile(manifestPath, 'utf8')\n    .then(JSON.parse);\n\n  assertIsSnapManifest(manifest);\n  const filePath = pathResolve(root, manifest.source.location.npm.filePath);\n\n  if (!(await isFile(filePath))) {\n    throw new Error(\n      `File \"${filePath}\" does not exist, or is not a file. Did you forget to build your snap?`,\n    );\n  }\n}\n\n/**\n * Start an HTTP server on `localhost` with a random port. This is used to serve\n * the static files for the environment.\n *\n * @param options - The options to use.\n * @param options.port - The port to use for the server.\n * @param options.root - The root directory to serve from the server.\n * @returns The HTTP server.\n */\nexport async function startServer(options: ServerOptions) {\n  await assertRoot(options.root);\n\n  const log = createModuleLogger(rootLogger, 'server');\n  const app = express();\n\n  app.use((_request, response, next) => {\n    response.header('Access-Control-Allow-Origin', '*');\n    response.header('Access-Control-Allow-Credentials', 'true');\n    response.header('Access-Control-Allow-Methods', 'GET, OPTIONS');\n    response.header('Access-Control-Allow-Headers', 'Content-Type');\n\n    next();\n  });\n\n  app.use(express.static(pathResolve(process.cwd(), options.root)));\n\n  const server = createServer(app);\n  return await new Promise<Server>((resolve, reject) => {\n    server.listen(options.port, () => {\n      resolve(server);\n    });\n\n    server.on('error', (error) => {\n      log(error);\n      reject(error);\n    });\n  });\n}\n"],"mappings":";;;;;AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,0BAA0B;AACnC,OAAO,aAAa;AACpB,SAAS,YAAY,UAAU;AAE/B,SAAS,oBAAoB;AAC7B,SAAS,WAAW,mBAAmB;AAoBvC,eAAe,WAAW,MAAc;AACtC,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACtD;AAEA,MAAI,CAAE,MAAM,YAAY,MAAM,KAAK,GAAI;AACrC,UAAM,IAAI,MAAM,mBAAmB,IAAI,uBAAuB;AAAA,EAChE;AAEA,QAAM,eAAe,YAAY,MAAM,oBAAoB;AAC3D,QAAM,WAAyB,MAAM,GAClC,SAAS,cAAc,MAAM,EAC7B,KAAK,KAAK,KAAK;AAElB,uBAAqB,QAAQ;AAC7B,QAAM,WAAW,YAAY,MAAM,SAAS,OAAO,SAAS,IAAI,QAAQ;AAExE,MAAI,CAAE,MAAM,OAAO,QAAQ,GAAI;AAC7B,UAAM,IAAI;AAAA,MACR,SAAS,QAAQ;AAAA,IACnB;AAAA,EACF;AACF;AAWA,eAAsB,YAAY,SAAwB;AACxD,QAAM,WAAW,QAAQ,IAAI;AAE7B,QAAM,MAAM,mBAAmB,YAAY,QAAQ;AACnD,QAAM,MAAM,QAAQ;AAEpB,MAAI,IAAI,CAAC,UAAU,UAAU,SAAS;AACpC,aAAS,OAAO,+BAA+B,GAAG;AAClD,aAAS,OAAO,oCAAoC,MAAM;AAC1D,aAAS,OAAO,gCAAgC,cAAc;AAC9D,aAAS,OAAO,gCAAgC,cAAc;AAE9D,SAAK;AAAA,EACP,CAAC;AAED,MAAI,IAAI,QAAQ,OAAO,YAAY,QAAQ,IAAI,GAAG,QAAQ,IAAI,CAAC,CAAC;AAEhE,QAAM,SAAS,aAAa,GAAG;AAC/B,SAAO,MAAM,IAAI,QAAgB,CAAC,SAAS,WAAW;AACpD,WAAO,OAAO,QAAQ,MAAM,MAAM;AAChC,cAAQ,MAAM;AAAA,IAChB,CAAC;AAED,WAAO,GAAG,SAAS,CAAC,UAAU;AAC5B,UAAI,KAAK;AACT,aAAO,KAAK;AAAA,IACd,CAAC;AAAA,EACH,CAAC;AACH;","names":[]}