{"version":3,"sources":["../src/internals/simulation/middleware/internal-methods/middleware.ts"],"names":[],"mappings":";;;;;;;;AACA,SAAS,gBAAgB;AAezB,IAAM,iBAAiB;AAAA;AAAA,EAErB,2BAA2B;AAAA,EAC3B,qBAAqB;AAAA,EACrB,cAAc;AAAA;AAEhB;AAaO,SAAS,gCACd,OACwC;AAGxC,SAAO,eAAe,iBAAiB,SAAS,UAAU,MAAM,KAAK;AACnE,UAAM,UACJ,eAAe,QAAQ,MAAqC;AAC9D,QAAI,SAAS;AACX,UAAI;AAEF,eAAO,MAAM,QAAQ,SAAS,UAAU,MAAM,KAAK,KAAK;AAAA,MAC1D,SAAS,OAAY;AACnB,iBAAS,KAAK;AACd,eAAO,IAAI,KAAK;AAAA,MAClB;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,EACd;AACF","sourcesContent":["import type { JsonRpcMiddleware } from '@metamask/json-rpc-engine';\nimport { logError } from '@metamask/snaps-utils';\nimport type { Json, JsonRpcParams } from '@metamask/utils';\n\nimport { getAccountsHandler } from './accounts';\nimport { getProviderStateHandler } from './provider-state';\n\nexport type InternalMethodsMiddlewareHooks = {\n  /**\n   * A hook that returns the user's secret recovery phrase.\n   *\n   * @returns The user's secret recovery phrase.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n};\n\nconst methodHandlers = {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  metamask_getProviderState: getProviderStateHandler,\n  eth_requestAccounts: getAccountsHandler,\n  eth_accounts: getAccountsHandler,\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n\n/**\n * Create a middleware for handling JSON-RPC methods normally handled internally\n * by the MetaMask client.\n *\n * NOTE: This middleware provides all `hooks` to all handlers and should\n * therefore NOT be used outside of the simulation environment. It is intended\n * for testing purposes only.\n *\n * @param hooks - Any hooks used by the middleware handlers.\n * @returns A middleware function.\n */\nexport function createInternalMethodsMiddleware(\n  hooks: InternalMethodsMiddlewareHooks,\n): JsonRpcMiddleware<JsonRpcParams, Json> {\n  // This should probably use createAsyncMiddleware.\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return async function methodMiddleware(request, response, next, end) {\n    const handler =\n      methodHandlers[request.method as keyof typeof methodHandlers];\n    if (handler) {\n      try {\n        // Implementations may or may not be async, so we must await them.\n        return await handler(request, response, next, end, hooks);\n      } catch (error: any) {\n        logError(error);\n        return end(error);\n      }\n    }\n\n    return next();\n  };\n}\n"]}