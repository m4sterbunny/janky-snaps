{"version":3,"sources":["../src/internals/simulation/interface.ts"],"names":["content"],"mappings":";;;;;;;AAQA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,aAAa,mBAAmB;AAGzC,SAAS,MAAM,KAAK,QAAQ,YAAY;AAgBjC,SAAS,qBACd,SACA,MACA,SACA,kBACe;AACf,UAAQ,MAAM;AAAA,IACZ,KAAK,WAAW;AACd,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA,IAAI,YAAY,SAAS,IAAI;AAAA,MAC/B;AAAA,IAEF,KAAK,WAAW;AACd,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QAEA,IAAI,YAAY,SAAS,IAAI;AAAA,QAC7B,QAAQ,YAAY,SAAS,KAAK;AAAA,MACpC;AAAA,IAEF,KAAK,WAAW;AACd,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QAEA,IAAI,iBAAiB,OAAO;AAAA,QAC5B,QAAQ,YAAY,SAAS,IAAI;AAAA,MACnC;AAAA,IAEF;AACE,YAAM,IAAI,MAAM,wCAAwC,OAAO,IAAI,CAAC,IAAI;AAAA,EAC5E;AACF;AAUA,SAAS,YAAY,SAA0B,OAAgB;AAM7D,YAAU,kBAAgC;AACxC,UAAM,IAAI,iBAAiB,KAAK,CAAC;AAAA,EACnC;AAEA,SAAO,YAAY;AACjB,UAAM,QAAQ,eAAe,EAAE,UAAU;AAAA,EAC3C;AACF;AASA,SAAS,iBAAiB,SAA0B;AAOlD,YAAU,gBAAgB,OAA6B;AACrD,UAAM,IAAI,iBAAiB,KAAK,CAAC;AAAA,EACnC;AAEA,SAAO,OAAO,QAAQ,OAAO;AAC3B,UAAM,QAAQ,iBAAiB,KAAK,EAAE,UAAU;AAAA,EAClD;AACF;AAUA,UAAU,mBACR,qBACA,QACkD;AAClD,QAAM,mBAAqC,MAAM,OAAO,mBAAmB;AAE3E,MAAI,kBAAkB;AACpB,UAAM,EAAE,SAAAA,SAAQ,IAAI,oBAAoB;AAAA,MACtC;AAAA,MACA;AAAA,MACA,iBAAiB;AAAA,IACnB;AAEA,WAAO,EAAE,GAAG,kBAAkB,SAAAA,SAAQ;AAAA,EACxC;AAEA,QAAM,EAAE,QAAQ,IAA8B,MAAM,KAAK,aAAa,IAAI;AAE1E,QAAM,EAAE,QAAQ,IAAI,oBAAoB;AAAA,IACtC;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,EACV;AAEA,SAAO,EAAE,GAAG,SAAS,QAAQ;AAC/B;AASO,SAAS,WACd,SACA,MAMY;AACZ,QAAM,EAAE,KAAK,IAAI;AAEjB,OACG,SAAS,SAAS,UAAU,SAAS,SAAS,UAC/C,QAAQ,SAAS,MACjB;AACA,WAAO,EAAE,SAAS,QAAQ;AAAA,EAC5B;AAEA,MAAI,YAAY,OAAO,GAAG;AACxB,eAAW,WAAW,QAAQ,UAAU;AACtC,YAAM,SAAS,WAAW,SAAS,IAAI;AACvC,YAAM,OAAO,SAAS,SAAS,OAAO,QAAQ,OAAO,QAAQ;AAE7D,UAAI,QAAQ;AACV,eAAO,EAAE,SAAS,OAAO,SAAS,KAAK;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAWA,eAAsB,aACpB,qBACA,IACA,SACA,QACA,MACe;AACf,QAAM,SAAS,WAAW,SAAS,IAAI;AACvC;AAAA,IACE,WAAW,UAAa,OAAO,QAAQ,SAAS,SAAS;AAAA,IACzD;AAAA,EACF;AAEA,MAAI,OAAO,QAAQ,OAAO,QAAQ,eAAe,WAAW,QAAQ;AAClE,UAAM,EAAE,MAAM,IAAI,oBAAoB;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,oBAAoB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,YAAY;AAAA,QACrB,SAAS;AAAA,UACP,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,YACN,OAAO;AAAA,cACL,MAAM,mBAAmB;AAAA,cACzB,MAAM,OAAO;AAAA,cACb,OAAO,MAAM,OAAO,IAAI;AAAA,YAC1B;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA;AAAA,EACF;AAEA,MAAI,OAAO,QAAQ,eAAe,WAAW,QAAQ;AACnD,UAAM,oBAAoB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,YAAY;AAAA,QACrB,SAAS;AAAA,UACP,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,QAAQ;AAAA,YACN,OAAO;AAAA,cACL,MAAM,mBAAmB;AAAA,cACzB,MAAM,OAAO,QAAQ;AAAA,YACvB;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAWO,SAAS,WACd,OACA,MACA,OACA,MACgB;AAChB,MAAI,MAAM;AACR,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,IAAI,GAAG;AAAA,QACN,GAAI,MAAM,IAAI;AAAA,QACd,CAAC,IAAI,GAAG;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,GAAG,OAAO,CAAC,IAAI,GAAG,MAAM;AACnC;AAYA,eAAsB,YACpB,qBACA,IACA,SACA,QACA,MACA,OACA;AACA,QAAM,SAAS,WAAW,SAAS,IAAI;AAEvC;AAAA,IACE,WAAW,UAAa,OAAO,QAAQ,SAAS,SAAS;AAAA,IACzD;AAAA,EACF;AAEA,QAAM,EAAE,MAAM,IAAI,oBAAoB;AAAA,IACpC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,WAAW,WAAW,OAAO,MAAM,OAAO,OAAO,IAAI;AAE3D,sBAAoB;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,oBAAoB,KAAK,qCAAqC,QAAQ;AAAA,IAC1E,QAAQ;AAAA,IACR,SAAS,YAAY;AAAA,IACrB,SAAS;AAAA,MACP,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ;AAAA,QACN,OAAO;AAAA,UACL,MAAM,mBAAmB;AAAA,UACzB,MAAM,OAAO,QAAQ;AAAA,UACrB;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAWO,UAAU,aACf,SACA,QACA,qBAC6B;AAC7B,QAAM,EAAE,MAAM,IAAI,QAAQ,IAAI,MAAM;AAAA,IAClC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,mBAAmB;AAAA,IACvB,cAAc,OAAO,SAAiB;AACpC,YAAM,aAAa,qBAAqB,IAAI,SAAS,QAAQ,IAAI;AAAA,IACnE;AAAA,IACA,aAAa,OAAO,MAAc,UAAkB;AAClD,YAAM,YAAY,qBAAqB,IAAI,SAAS,QAAQ,MAAM,KAAK;AAAA,IACzE;AAAA,EACF;AAEA,SAAO,qBAAqB,SAAS,MAAM,SAAS,gBAAgB;AACtE","sourcesContent":["import type {\n  Button,\n  Component,\n  FormState,\n  Input,\n  InterfaceState,\n  SnapId,\n} from '@metamask/snaps-sdk';\nimport {\n  ButtonType,\n  DialogType,\n  NodeType,\n  UserInputEventType,\n  assert,\n} from '@metamask/snaps-sdk';\nimport { HandlerType, hasChildren } from '@metamask/snaps-utils';\nimport type { PayloadAction } from '@reduxjs/toolkit';\nimport { type SagaIterator } from 'redux-saga';\nimport { call, put, select, take } from 'redux-saga/effects';\n\nimport type { SnapInterface, SnapInterfaceActions } from '../../types';\nimport type { RootControllerMessenger } from './controllers';\nimport type { Interface, RunSagaFunction } from './store';\nimport { getCurrentInterface, resolveInterface, setInterface } from './store';\n\n/**\n * Get a user interface object from a type and content object.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param type - The type of the interface.\n * @param content - The content to show in the interface.\n * @param interfaceActions - The actions to interact with the interface.\n * @returns The user interface object.\n */\nexport function getInterfaceResponse(\n  runSaga: RunSagaFunction,\n  type: DialogType,\n  content: Component,\n  interfaceActions: SnapInterfaceActions,\n): SnapInterface {\n  switch (type) {\n    case DialogType.Alert:\n      return {\n        ...interfaceActions,\n        type,\n        content,\n        ok: resolveWith(runSaga, null),\n      };\n\n    case DialogType.Confirmation:\n      return {\n        ...interfaceActions,\n        type,\n        content,\n\n        ok: resolveWith(runSaga, true),\n        cancel: resolveWith(runSaga, false),\n      };\n\n    case DialogType.Prompt:\n      return {\n        ...interfaceActions,\n        type,\n        content,\n\n        ok: resolveWithInput(runSaga),\n        cancel: resolveWith(runSaga, null),\n      };\n\n    default:\n      throw new Error(`Unknown or unsupported dialog type: \"${String(type)}\".`);\n  }\n}\n\n/**\n * Resolve the current user interface with the given value. This returns a\n * function that can be used to resolve the user interface.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param value - The value to resolve the user interface with.\n * @returns A function that can be used to resolve the user interface.\n */\nfunction resolveWith(runSaga: RunSagaFunction, value: unknown) {\n  /**\n   * Resolve the current user interface with the given value.\n   *\n   * @yields Puts the resolve user interface action.\n   */\n  function* resolveWithSaga(): SagaIterator {\n    yield put(resolveInterface(value));\n  }\n\n  return async () => {\n    await runSaga(resolveWithSaga).toPromise();\n  };\n}\n\n/**\n * Resolve the current user interface with the provided input. This returns a\n * function that can be used to resolve the user interface.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @returns A function that can be used to resolve the user interface.\n */\nfunction resolveWithInput(runSaga: RunSagaFunction) {\n  /**\n   * Resolve the current user interface with the given value.\n   *\n   * @param value - The value to resolve the user interface with.\n   * @yields Puts the resolve user interface action.\n   */\n  function* resolveWithSaga(value: string): SagaIterator {\n    yield put(resolveInterface(value));\n  }\n\n  return async (value = '') => {\n    await runSaga(resolveWithSaga, value).toPromise();\n  };\n}\n\n/**\n * Get the stored user interface from the store.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param snapId - The Snap ID.\n * @yields Takes the set interface action.\n * @returns The user interface object.\n */\nfunction* getStoredInterface(\n  controllerMessenger: RootControllerMessenger,\n  snapId: SnapId,\n): SagaIterator<Interface & { content: Component }> {\n  const currentInterface: Interface | null = yield select(getCurrentInterface);\n\n  if (currentInterface) {\n    const { content } = controllerMessenger.call(\n      'SnapInterfaceController:getInterface',\n      snapId,\n      currentInterface.id,\n    );\n\n    return { ...currentInterface, content };\n  }\n\n  const { payload }: PayloadAction<Interface> = yield take(setInterface.type);\n\n  const { content } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    payload.id,\n  );\n\n  return { ...payload, content };\n}\n\n/**\n * Get a Button or an Input from an interface.\n *\n * @param content - The interface content.\n * @param name - The element name.\n * @returns An object containing the element and the form name if it's contained in a form, otherwise undefined.\n */\nexport function getElement(\n  content: Component,\n  name: string,\n):\n  | {\n      element: Button | Input;\n      form?: string;\n    }\n  | undefined {\n  const { type } = content;\n\n  if (\n    (type === NodeType.Button || type === NodeType.Input) &&\n    content.name === name\n  ) {\n    return { element: content };\n  }\n\n  if (hasChildren(content)) {\n    for (const element of content.children) {\n      const result = getElement(element, name);\n      const form = type === NodeType.Form ? content.name : result?.form;\n\n      if (result) {\n        return { element: result.element, form };\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Click on an element of the Snap interface.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface content.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n */\nexport async function clickElement(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: Component,\n  snapId: SnapId,\n  name: string,\n): Promise<void> {\n  const result = getElement(content, name);\n  assert(\n    result !== undefined && result.element.type === NodeType.Button,\n    'No button found in the interface.',\n  );\n\n  if (result.form && result.element.buttonType === ButtonType.Submit) {\n    const { state } = controllerMessenger.call(\n      'SnapInterfaceController:getInterface',\n      snapId,\n      id,\n    );\n\n    await controllerMessenger.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      {\n        origin: '',\n        handler: HandlerType.OnUserInput,\n        request: {\n          jsonrpc: '2.0',\n          method: ' ',\n          params: {\n            event: {\n              type: UserInputEventType.FormSubmitEvent,\n              name: result.form,\n              value: state[result.form],\n            },\n            id,\n          },\n        },\n      },\n    );\n\n    return;\n  }\n\n  if (result.element.buttonType !== ButtonType.Submit) {\n    await controllerMessenger.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      {\n        origin: '',\n        handler: HandlerType.OnUserInput,\n        request: {\n          jsonrpc: '2.0',\n          method: ' ',\n          params: {\n            event: {\n              type: UserInputEventType.ButtonClickEvent,\n              name: result.element.name,\n            },\n            id,\n          },\n        },\n      },\n    );\n  }\n}\n\n/**\n * Merge a value in the interface state.\n *\n * @param state - The actual interface state.\n * @param name - The component name that changed value.\n * @param value - The new value.\n * @param form - The form name if the element is in one.\n * @returns The state with the merged value.\n */\nexport function mergeValue(\n  state: InterfaceState,\n  name: string,\n  value: string | null,\n  form?: string,\n): InterfaceState {\n  if (form) {\n    return {\n      ...state,\n      [form]: {\n        ...(state[form] as FormState),\n        [name]: value,\n      },\n    };\n  }\n\n  return { ...state, [name]: value };\n}\n\n/**\n * Type a value in an interface element.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface Components.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n * @param value - The value to type in the element.\n */\nexport async function typeInField(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: Component,\n  snapId: SnapId,\n  name: string,\n  value: string,\n) {\n  const result = getElement(content, name);\n\n  assert(\n    result !== undefined && result.element.type === NodeType.Input,\n    'No input found in the interface.',\n  );\n\n  const { state } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    id,\n  );\n\n  const newState = mergeValue(state, name, value, result.form);\n\n  controllerMessenger.call(\n    'SnapInterfaceController:updateInterfaceState',\n    id,\n    newState,\n  );\n\n  await controllerMessenger.call('ExecutionService:handleRpcRequest', snapId, {\n    origin: '',\n    handler: HandlerType.OnUserInput,\n    request: {\n      jsonrpc: '2.0',\n      method: ' ',\n      params: {\n        event: {\n          type: UserInputEventType.InputChangeEvent,\n          name: result.element.name,\n          value,\n        },\n        id,\n      },\n    },\n  });\n}\n\n/**\n * Get a user interface object from a Snap.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param snapId - The Snap ID.\n * @param controllerMessenger - The controller messenger used to call actions.\n * @yields Takes the set interface action.\n * @returns The user interface object.\n */\nexport function* getInterface(\n  runSaga: RunSagaFunction,\n  snapId: SnapId,\n  controllerMessenger: RootControllerMessenger,\n): SagaIterator<SnapInterface> {\n  const { type, id, content } = yield call(\n    getStoredInterface,\n    controllerMessenger,\n    snapId,\n  );\n\n  const interfaceActions = {\n    clickElement: async (name: string) => {\n      await clickElement(controllerMessenger, id, content, snapId, name);\n    },\n    typeInField: async (name: string, value: string) => {\n      await typeInField(controllerMessenger, id, content, snapId, name, value);\n    },\n  };\n\n  return getInterfaceResponse(runSaga, type, content, interfaceActions);\n}\n"]}