{"version":3,"sources":["../src/internals/simulation/simulation.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ActionConstraint,\n  EventConstraint,\n} from '@metamask/base-controller';\nimport { ControllerMessenger } from '@metamask/base-controller';\nimport { createEngineStream } from '@metamask/json-rpc-middleware-stream';\nimport { mnemonicPhraseToBytes } from '@metamask/key-tree';\nimport type { AbstractExecutionService } from '@metamask/snaps-controllers';\nimport {\n  fetchSnap,\n  detectSnapLocation,\n  NodeThreadExecutionService,\n  setupMultiplex,\n} from '@metamask/snaps-controllers/node';\nimport type {\n  SnapId,\n  AuxiliaryFileEncoding,\n  Component,\n  InterfaceState,\n} from '@metamask/snaps-sdk';\nimport type { FetchedSnapFiles } from '@metamask/snaps-utils';\nimport { logError } from '@metamask/snaps-utils';\nimport type { Duplex } from 'readable-stream';\nimport { pipeline } from 'readable-stream';\n\nimport type { RootControllerMessenger } from './controllers';\nimport { getControllers, registerSnap } from './controllers';\nimport { getSnapFile } from './files';\nimport { getEndowments } from './methods';\nimport { createJsonRpcEngine } from './middleware';\nimport type { SimulationOptions, SimulationUserOptions } from './options';\nimport { getOptions } from './options';\nimport type { RunSagaFunction, Store } from './store';\nimport { createStore } from './store';\n\n/**\n * Options for the execution service, without the options that are shared\n * between all execution services.\n *\n * @template Service - The type of the execution service, i.e., the class that\n * creates the execution service.\n */\nexport type ExecutionServiceOptions<\n  Service extends new (...args: any[]) => any,\n> = Omit<\n  ConstructorParameters<Service>[0],\n  keyof ConstructorParameters<typeof AbstractExecutionService<unknown>>[0]\n>;\n\n/**\n * The options for running a Snap in a simulated environment.\n *\n * @property executionService - The execution service to use.\n * @property executionServiceOptions - The options to use when creating the\n * execution service, if any. This should only include options specific to the\n * provided execution service.\n * @property options - The simulation options.\n * @template Service - The type of the execution service.\n */\nexport type InstallSnapOptions<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService<unknown>\n  >,\n> = ExecutionServiceOptions<Service> extends Record<string, never>\n  ? {\n      executionService: Service;\n      executionServiceOptions?: ExecutionServiceOptions<Service>;\n      options?: SimulationUserOptions;\n    }\n  : {\n      executionService: Service;\n      executionServiceOptions: ExecutionServiceOptions<Service>;\n      options?: SimulationUserOptions;\n    };\n\nexport type InstalledSnap = {\n  snapId: SnapId;\n  store: Store;\n  executionService: InstanceType<typeof AbstractExecutionService>;\n  controllerMessenger: ControllerMessenger<ActionConstraint, EventConstraint>;\n  runSaga: RunSagaFunction;\n};\n\nexport type MiddlewareHooks = {\n  /**\n   * A hook that returns the user's secret recovery phrase.\n   *\n   * @returns The user's secret recovery phrase.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * A hook that returns the Snap's auxiliary file for the given path.\n   *\n   * @param path - The path of the auxiliary file to get.\n   * @param encoding - The encoding to use when returning the file.\n   * @returns The Snap's auxiliary file for the given path.\n   */\n  getSnapFile: (\n    path: string,\n    encoding: AuxiliaryFileEncoding,\n  ) => Promise<string | null>;\n\n  /**\n   * A hook that returns whether the client is locked or not.\n   *\n   * @returns A boolean flag signaling whether the client is locked.\n   */\n  getIsLocked: () => boolean;\n  createInterface: (content: Component) => Promise<string>;\n  updateInterface: (id: string, content: Component) => Promise<void>;\n  getInterfaceState: (id: string) => InterfaceState;\n};\n\n/**\n * Install a Snap in a simulated environment. This will fetch the Snap files,\n * create a Redux store, set up the controllers and JSON-RPC stack, register the\n * Snap, and run the Snap code in the execution service.\n *\n * @param snapId - The ID of the Snap to install.\n * @param options - The options to use when installing the Snap.\n * @param options.executionService - The execution service to use.\n * @param options.executionServiceOptions - The options to use when creating the\n * execution service, if any. This should only include options specific to the\n * provided execution service.\n * @param options.options - The simulation options.\n * @template Service - The type of the execution service.\n */\nexport async function handleInstallSnap<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService\n  >,\n>(\n  snapId: SnapId,\n  {\n    executionService,\n    executionServiceOptions,\n    options: rawOptions = {},\n  }: Partial<InstallSnapOptions<Service>> = {},\n): Promise<InstalledSnap> {\n  const options = getOptions(rawOptions);\n\n  // Fetch Snap files.\n  const location = detectSnapLocation(snapId, {\n    allowLocal: true,\n  });\n\n  const snapFiles = await fetchSnap(snapId, location);\n\n  // Create Redux store.\n  const { store, runSaga } = createStore(options);\n\n  const controllerMessenger = new ControllerMessenger<any, any>();\n\n  registerActions(controllerMessenger);\n\n  // Set up controllers and JSON-RPC stack.\n  const hooks = getHooks(options, snapFiles, snapId, controllerMessenger);\n\n  const { subjectMetadataController, permissionController } = getControllers({\n    controllerMessenger,\n    hooks,\n    runSaga,\n    options,\n  });\n\n  const engine = createJsonRpcEngine({\n    store,\n    hooks,\n    permissionMiddleware: permissionController.createPermissionMiddleware({\n      origin: snapId,\n    }),\n  });\n\n  // Create execution service.\n  const ExecutionService = executionService ?? NodeThreadExecutionService;\n  const service = new ExecutionService({\n    ...executionServiceOptions,\n    messenger: controllerMessenger.getRestricted({\n      name: 'ExecutionService',\n      allowedActions: [],\n      allowedEvents: [],\n    }),\n    setupSnapProvider: (_snapId: string, rpcStream: Duplex) => {\n      const mux = setupMultiplex(rpcStream, 'snapStream');\n      const stream = mux.createStream('metamask-provider');\n      const providerStream = createEngineStream({ engine });\n\n      // Error function is difficult to test, so we ignore it.\n      /* istanbul ignore next 2 */\n      pipeline(stream, providerStream, stream, (error: unknown) => {\n        if (error) {\n          logError(`Provider stream failure.`, error);\n        }\n      });\n    },\n  });\n\n  // Register the Snap. This sets up the Snap's permissions and subject\n  // metadata.\n  await registerSnap(snapId, snapFiles.manifest.result, {\n    permissionController,\n    subjectMetadataController,\n  });\n\n  // Run the Snap code in the execution service.\n  await service.executeSnap({\n    snapId,\n    sourceCode: snapFiles.sourceCode.toString('utf8'),\n    endowments: await getEndowments(permissionController, snapId),\n  });\n\n  return {\n    snapId,\n    store,\n    executionService: service,\n    controllerMessenger,\n    runSaga,\n  };\n}\n\n/**\n * Get the hooks for the simulation.\n *\n * @param options - The simulation options.\n * @param snapFiles - The Snap files.\n * @param snapId - The Snap ID.\n * @param controllerMessenger - The controller messenger.\n * @returns The hooks for the simulation.\n */\nexport function getHooks(\n  options: SimulationOptions,\n  snapFiles: FetchedSnapFiles,\n  snapId: SnapId,\n  controllerMessenger: RootControllerMessenger,\n): MiddlewareHooks {\n  return {\n    getMnemonic: async () =>\n      Promise.resolve(mnemonicPhraseToBytes(options.secretRecoveryPhrase)),\n    getSnapFile: async (path: string, encoding: AuxiliaryFileEncoding) =>\n      await getSnapFile(snapFiles.auxiliaryFiles, path, encoding),\n    getIsLocked: () => false,\n    createInterface: async (...args) =>\n      controllerMessenger.call(\n        'SnapInterfaceController:createInterface',\n        snapId,\n        ...args,\n      ),\n    updateInterface: async (...args) =>\n      controllerMessenger.call(\n        'SnapInterfaceController:updateInterface',\n        snapId,\n        ...args,\n      ),\n    getInterfaceState: (...args) =>\n      controllerMessenger.call(\n        'SnapInterfaceController:getInterface',\n        snapId,\n        ...args,\n      ).state,\n  };\n}\n\n/**\n * Register mocked action handlers.\n *\n * @param controllerMessenger - The controller messenger.\n */\nexport function registerActions(controllerMessenger: RootControllerMessenger) {\n  controllerMessenger.registerActionHandler(\n    'PhishingController:maybeUpdateState',\n    async () => Promise.resolve(),\n  );\n\n  controllerMessenger.registerActionHandler(\n    'PhishingController:testOrigin',\n    () => ({ result: false, type: 'all' }),\n  );\n}\n"]}