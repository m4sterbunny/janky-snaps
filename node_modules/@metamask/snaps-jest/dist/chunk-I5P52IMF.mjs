import {
  getCurrentInterface,
  resolveInterface,
  setInterface
} from "./chunk-74TIKA2T.mjs";

// src/internals/simulation/interface.ts
import {
  ButtonType,
  DialogType,
  NodeType,
  UserInputEventType,
  assert
} from "@metamask/snaps-sdk";
import { HandlerType, hasChildren } from "@metamask/snaps-utils";
import { call, put, select, take } from "redux-saga/effects";
function getInterfaceResponse(runSaga, type, content, interfaceActions) {
  switch (type) {
    case DialogType.Alert:
      return {
        ...interfaceActions,
        type,
        content,
        ok: resolveWith(runSaga, null)
      };
    case DialogType.Confirmation:
      return {
        ...interfaceActions,
        type,
        content,
        ok: resolveWith(runSaga, true),
        cancel: resolveWith(runSaga, false)
      };
    case DialogType.Prompt:
      return {
        ...interfaceActions,
        type,
        content,
        ok: resolveWithInput(runSaga),
        cancel: resolveWith(runSaga, null)
      };
    default:
      throw new Error(`Unknown or unsupported dialog type: "${String(type)}".`);
  }
}
function resolveWith(runSaga, value) {
  function* resolveWithSaga() {
    yield put(resolveInterface(value));
  }
  return async () => {
    await runSaga(resolveWithSaga).toPromise();
  };
}
function resolveWithInput(runSaga) {
  function* resolveWithSaga(value) {
    yield put(resolveInterface(value));
  }
  return async (value = "") => {
    await runSaga(resolveWithSaga, value).toPromise();
  };
}
function* getStoredInterface(controllerMessenger, snapId) {
  const currentInterface = yield select(getCurrentInterface);
  if (currentInterface) {
    const { content: content2 } = controllerMessenger.call(
      "SnapInterfaceController:getInterface",
      snapId,
      currentInterface.id
    );
    return { ...currentInterface, content: content2 };
  }
  const { payload } = yield take(setInterface.type);
  const { content } = controllerMessenger.call(
    "SnapInterfaceController:getInterface",
    snapId,
    payload.id
  );
  return { ...payload, content };
}
function getElement(content, name) {
  const { type } = content;
  if ((type === NodeType.Button || type === NodeType.Input) && content.name === name) {
    return { element: content };
  }
  if (hasChildren(content)) {
    for (const element of content.children) {
      const result = getElement(element, name);
      const form = type === NodeType.Form ? content.name : result?.form;
      if (result) {
        return { element: result.element, form };
      }
    }
  }
  return void 0;
}
async function clickElement(controllerMessenger, id, content, snapId, name) {
  const result = getElement(content, name);
  assert(
    result !== void 0 && result.element.type === NodeType.Button,
    "No button found in the interface."
  );
  if (result.form && result.element.buttonType === ButtonType.Submit) {
    const { state } = controllerMessenger.call(
      "SnapInterfaceController:getInterface",
      snapId,
      id
    );
    await controllerMessenger.call(
      "ExecutionService:handleRpcRequest",
      snapId,
      {
        origin: "",
        handler: HandlerType.OnUserInput,
        request: {
          jsonrpc: "2.0",
          method: " ",
          params: {
            event: {
              type: UserInputEventType.FormSubmitEvent,
              name: result.form,
              value: state[result.form]
            },
            id
          }
        }
      }
    );
    return;
  }
  if (result.element.buttonType !== ButtonType.Submit) {
    await controllerMessenger.call(
      "ExecutionService:handleRpcRequest",
      snapId,
      {
        origin: "",
        handler: HandlerType.OnUserInput,
        request: {
          jsonrpc: "2.0",
          method: " ",
          params: {
            event: {
              type: UserInputEventType.ButtonClickEvent,
              name: result.element.name
            },
            id
          }
        }
      }
    );
  }
}
function mergeValue(state, name, value, form) {
  if (form) {
    return {
      ...state,
      [form]: {
        ...state[form],
        [name]: value
      }
    };
  }
  return { ...state, [name]: value };
}
async function typeInField(controllerMessenger, id, content, snapId, name, value) {
  const result = getElement(content, name);
  assert(
    result !== void 0 && result.element.type === NodeType.Input,
    "No input found in the interface."
  );
  const { state } = controllerMessenger.call(
    "SnapInterfaceController:getInterface",
    snapId,
    id
  );
  const newState = mergeValue(state, name, value, result.form);
  controllerMessenger.call(
    "SnapInterfaceController:updateInterfaceState",
    id,
    newState
  );
  await controllerMessenger.call("ExecutionService:handleRpcRequest", snapId, {
    origin: "",
    handler: HandlerType.OnUserInput,
    request: {
      jsonrpc: "2.0",
      method: " ",
      params: {
        event: {
          type: UserInputEventType.InputChangeEvent,
          name: result.element.name,
          value
        },
        id
      }
    }
  });
}
function* getInterface(runSaga, snapId, controllerMessenger) {
  const { type, id, content } = yield call(
    getStoredInterface,
    controllerMessenger,
    snapId
  );
  const interfaceActions = {
    clickElement: async (name) => {
      await clickElement(controllerMessenger, id, content, snapId, name);
    },
    typeInField: async (name, value) => {
      await typeInField(controllerMessenger, id, content, snapId, name, value);
    }
  };
  return getInterfaceResponse(runSaga, type, content, interfaceActions);
}

export {
  getInterfaceResponse,
  getElement,
  clickElement,
  mergeValue,
  typeInField,
  getInterface
};
//# sourceMappingURL=chunk-I5P52IMF.mjs.map