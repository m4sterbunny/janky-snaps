{"version":3,"sources":["../src/util.ts"],"sourcesContent":["import { isValidAddress, toChecksumAddress } from '@ethereumjs/util';\nimport type EthQuery from '@metamask/eth-query';\nimport { fromWei, toWei } from '@metamask/ethjs-unit';\nimport type { Hex, Json } from '@metamask/utils';\nimport {\n  isStrictHexString,\n  add0x,\n  isHexString,\n  remove0x,\n} from '@metamask/utils';\nimport BN from 'bn.js';\nimport ensNamehash from 'eth-ens-namehash';\nimport deepEqual from 'fast-deep-equal';\n\nimport { MAX_SAFE_CHAIN_ID } from './constants';\n\nconst TIMEOUT_ERROR = new Error('timeout');\n\n/**\n * Checks whether the given number primitive chain ID is safe.\n * Because some cryptographic libraries we use expect the chain ID to be a\n * number primitive, it must not exceed a certain size.\n *\n * @param chainId - The chain ID to check for safety.\n * @returns Whether the given chain ID is safe.\n */\nexport function isSafeChainId(chainId: Hex): boolean {\n  if (!isHexString(chainId)) {\n    return false;\n  }\n  const decimalChainId = Number.parseInt(\n    chainId,\n    isStrictHexString(chainId) ? 16 : 10,\n  );\n  return (\n    Number.isSafeInteger(decimalChainId) &&\n    decimalChainId > 0 &&\n    decimalChainId <= MAX_SAFE_CHAIN_ID\n  );\n}\n/**\n * Converts a BN object to a hex string with a '0x' prefix.\n *\n * @param inputBn - BN instance to convert to a hex string.\n * @returns A '0x'-prefixed hex string.\n */\nexport function BNToHex(inputBn: BN) {\n  return add0x(inputBn.toString(16));\n}\n\n/**\n * Used to multiply a BN by a fraction.\n *\n * @param targetBN - Number to multiply by a fraction.\n * @param numerator - Numerator of the fraction multiplier.\n * @param denominator - Denominator of the fraction multiplier.\n * @returns Product of the multiplication.\n */\nexport function fractionBN(\n  targetBN: BN,\n  numerator: number | string,\n  denominator: number | string,\n) {\n  const numBN = new BN(numerator);\n  const denomBN = new BN(denominator);\n  return targetBN.mul(numBN).div(denomBN);\n}\n\n/**\n * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts.\n *\n * @param n - The base 10 number to convert to WEI.\n * @returns The number in WEI, as a BN.\n */\nexport function gweiDecToWEIBN(n: number | string) {\n  if (Number.isNaN(n)) {\n    return new BN(0);\n  }\n\n  const parts = n.toString().split('.');\n  const wholePart = parts[0] || '0';\n  let decimalPart = parts[1] || '';\n\n  if (!decimalPart) {\n    return toWei(wholePart, 'gwei');\n  }\n\n  if (decimalPart.length <= 9) {\n    return toWei(`${wholePart}.${decimalPart}`, 'gwei');\n  }\n\n  const decimalPartToRemove = decimalPart.slice(9);\n  const decimalRoundingDigit = decimalPartToRemove[0];\n\n  decimalPart = decimalPart.slice(0, 9);\n  let wei = toWei(`${wholePart}.${decimalPart}`, 'gwei');\n\n  if (Number(decimalRoundingDigit) >= 5) {\n    wei = wei.add(new BN(1));\n  }\n\n  return wei;\n}\n\n/**\n * Used to convert values from wei hex format to dec gwei format.\n *\n * @param hex - The value in hex wei.\n * @returns The value in dec gwei as string.\n */\nexport function weiHexToGweiDec(hex: string) {\n  const hexWei = new BN(remove0x(hex), 16);\n  return fromWei(hexWei, 'gwei');\n}\n\n/**\n * Return a URL that can be used to obtain ETH for a given network.\n *\n * @param networkCode - Network code of desired network.\n * @param address - Address to deposit obtained ETH.\n * @param amount - How much ETH is desired.\n * @returns URL to buy ETH based on network.\n */\nexport function getBuyURL(\n  networkCode = '1',\n  address?: string,\n  amount = 5,\n): string | undefined {\n  switch (networkCode) {\n    case '1':\n      return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;\n    case '5':\n      return 'https://goerli-faucet.slock.it/';\n    case '11155111':\n      return 'https://sepoliafaucet.net/';\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Converts a hex string to a BN object.\n *\n * @param inputHex - Number represented as a hex string.\n * @returns A BN instance.\n */\nexport function hexToBN(inputHex: string) {\n  return inputHex ? new BN(remove0x(inputHex), 16) : new BN(0);\n}\n\n/**\n * A helper function that converts hex data to human readable string.\n *\n * @param hex - The hex string to convert to string.\n * @returns A human readable string conversion.\n */\nexport function hexToText(hex: string) {\n  try {\n    const stripped = remove0x(hex);\n    const buff = Buffer.from(stripped, 'hex');\n    return buff.toString('utf8');\n  } catch (e) {\n    /* istanbul ignore next */\n    return hex;\n  }\n}\n\n/**\n * Parses a hex string and converts it into a number that can be operated on in a bignum-safe,\n * base-10 way.\n *\n * @param value - A base-16 number encoded as a string.\n * @returns The number as a BN object in base-16 mode.\n */\nexport function fromHex(value: string | BN): BN {\n  if (BN.isBN(value)) {\n    return value;\n  }\n  return new BN(hexToBN(value).toString(10));\n}\n\n/**\n * Converts an integer to a hexadecimal representation.\n *\n * @param value - An integer, an integer encoded as a base-10 string, or a BN.\n * @returns The integer encoded as a hex string.\n */\nexport function toHex(value: number | string | BN): Hex {\n  if (typeof value === 'string' && isStrictHexString(value)) {\n    return value;\n  }\n  const hexString = BN.isBN(value)\n    ? value.toString(16)\n    : new BN(value.toString(), 10).toString(16);\n  return `0x${hexString}`;\n}\n\n/**\n * Execute and return an asynchronous operation without throwing errors.\n *\n * @param operation - Function returning a Promise.\n * @param logError - Determines if the error should be logged.\n * @template Result - Type of the result of the async operation\n * @returns Promise resolving to the result of the async operation.\n */\nexport async function safelyExecute<Result>(\n  operation: () => Promise<Result>,\n  logError = false,\n): Promise<Result | undefined> {\n  try {\n    return await operation();\n  } catch (error) {\n    /* istanbul ignore next */\n    if (logError) {\n      console.error(error);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Execute and return an asynchronous operation with a timeout.\n *\n * @param operation - Function returning a Promise.\n * @param logError - Determines if the error should be logged.\n * @param timeout - Timeout to fail the operation.\n * @template Result - Type of the result of the async operation\n * @returns Promise resolving to the result of the async operation.\n */\nexport async function safelyExecuteWithTimeout<Result>(\n  operation: () => Promise<Result>,\n  logError = false,\n  timeout = 500,\n): Promise<Result | undefined> {\n  try {\n    return await Promise.race([\n      operation(),\n      new Promise<never>((_, reject) =>\n        setTimeout(() => {\n          reject(TIMEOUT_ERROR);\n        }, timeout),\n      ),\n    ]);\n  } catch (error) {\n    /* istanbul ignore next */\n    if (logError) {\n      console.error(error);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Convert an address to a checksummed hexadecimal address.\n *\n * @param address - The address to convert.\n * @returns The address in 0x-prefixed hexadecimal checksummed form if it is valid.\n */\nexport function toChecksumHexAddress(address: string): string;\n\n/**\n * Convert an address to a checksummed hexadecimal address.\n *\n * Note that this particular overload does nothing.\n *\n * @param address - A value that is not a string (e.g. `undefined` or `null`).\n * @returns The `address` untouched.\n * @deprecated This overload is designed to gracefully handle an invalid input\n * and is only present for backward compatibility. It may be removed in a future\n * major version. Please pass a string to `toChecksumHexAddress` instead.\n */\nexport function toChecksumHexAddress<T>(address: T): T;\n\n// Tools only see JSDocs for overloads and ignore them for the implementation.\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function toChecksumHexAddress(address: unknown) {\n  if (typeof address !== 'string') {\n    // Mimic behavior of `addHexPrefix` from `ethereumjs-util` (which this\n    // function was previously using) for backward compatibility.\n    return address;\n  }\n\n  const hexPrefixed = add0x(address);\n\n  if (!isHexString(hexPrefixed)) {\n    // Version 5.1 of ethereumjs-util would have returned '0xY' for input 'y'\n    // but we shouldn't waste effort trying to change case on a clearly invalid\n    // string. Instead just return the hex prefixed original string which most\n    // closely mimics the original behavior.\n    return hexPrefixed;\n  }\n\n  return toChecksumAddress(hexPrefixed);\n}\n\n/**\n * Validates that the input is a hex address. This utility method is a thin\n * wrapper around @metamask/utils.isValidHexAddress, with the exception that it\n * by default will return true for hex strings that are otherwise valid\n * hex addresses, but are not prefixed with `0x`.\n *\n * @param possibleAddress - Input parameter to check against.\n * @param options - The validation options.\n * @param options.allowNonPrefixed - If true will allow addresses without `0x` prefix.`\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddress(\n  possibleAddress: string,\n  { allowNonPrefixed = true } = {},\n): boolean {\n  const addressToCheck = allowNonPrefixed\n    ? add0x(possibleAddress)\n    : possibleAddress;\n  if (!isStrictHexString(addressToCheck)) {\n    return false;\n  }\n\n  return isValidAddress(addressToCheck);\n}\n\n/**\n * Returns whether the given code corresponds to a smart contract.\n *\n * @param code - The potential smart contract code.\n * @returns Whether the code was smart contract code or not.\n */\nexport function isSmartContractCode(code: string) {\n  /* istanbul ignore if */\n  if (!code) {\n    return false;\n  }\n  // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'\n  const smartContractCode = code !== '0x' && code !== '0x0';\n  return smartContractCode;\n}\n\n/**\n * Execute fetch and verify that the response was successful.\n *\n * @param request - Request information.\n * @param options - Fetch options.\n * @returns The fetch response.\n */\nexport async function successfulFetch(\n  request: URL | RequestInfo,\n  options?: RequestInit,\n) {\n  const response = await fetch(request, options);\n  if (!response.ok) {\n    throw new Error(\n      `Fetch failed with status '${response.status}' for request '${String(\n        request,\n      )}'`,\n    );\n  }\n  return response;\n}\n\n/**\n * Execute fetch and return object response.\n *\n * @param request - The request information.\n * @param options - The fetch options.\n * @returns The fetch response JSON data.\n */\nexport async function handleFetch(\n  request: URL | RequestInfo,\n  options?: RequestInit,\n) {\n  const response = await successfulFetch(request, options);\n  const object = await response.json();\n  return object;\n}\n\n/**\n * Execute fetch and return object response, log if known error thrown, otherwise rethrow error.\n *\n * @param request - the request options object\n * @param request.url - The request url to query.\n * @param request.options - The fetch options.\n * @param request.timeout - Timeout to fail request\n * @param request.errorCodesToCatch - array of error codes for errors we want to catch in a particular context\n * @returns The fetch response JSON data or undefined (if error occurs).\n */\nexport async function fetchWithErrorHandling({\n  url,\n  options,\n  timeout,\n  errorCodesToCatch,\n}: {\n  url: string;\n  options?: RequestInit;\n  timeout?: number;\n  errorCodesToCatch?: number[];\n}) {\n  let result;\n  try {\n    if (timeout) {\n      result = Promise.race([\n        await handleFetch(url, options),\n        new Promise<Response>((_, reject) =>\n          setTimeout(() => {\n            reject(TIMEOUT_ERROR);\n          }, timeout),\n        ),\n      ]);\n    } else {\n      result = await handleFetch(url, options);\n    }\n  } catch (e) {\n    logOrRethrowError(e, errorCodesToCatch);\n  }\n  return result;\n}\n\n/**\n * Fetch that fails after timeout.\n *\n * @param url - Url to fetch.\n * @param options - Options to send with the request.\n * @param timeout - Timeout to fail request.\n * @returns Promise resolving the request.\n */\nexport async function timeoutFetch(\n  url: string,\n  options?: RequestInit,\n  timeout = 500,\n): Promise<Response> {\n  return Promise.race([\n    successfulFetch(url, options),\n    new Promise<Response>((_, reject) =>\n      setTimeout(() => {\n        reject(TIMEOUT_ERROR);\n      }, timeout),\n    ),\n  ]);\n}\n\n/**\n * Normalizes the given ENS name.\n *\n * @param ensName - The ENS name.\n * @returns The normalized ENS name string.\n */\nexport function normalizeEnsName(ensName: string): string | null {\n  // `.` refers to the registry root contract\n  if (ensName === '.') {\n    return ensName;\n  }\n  if (ensName && typeof ensName === 'string') {\n    try {\n      const normalized = ensNamehash.normalize(ensName.trim());\n      // this regex is only sufficient with the above call to ensNamehash.normalize\n      // TODO: change 7 in regex to 3 when shorter ENS domains are live\n      if (normalized.match(/^(([\\w\\d-]+)\\.)*[\\w\\d-]{7,}\\.(eth|test)$/u)) {\n        return normalized;\n      }\n    } catch (_) {\n      // do nothing\n    }\n  }\n  return null;\n}\n\n/**\n * Wrapper method to handle EthQuery requests.\n *\n * @param ethQuery - EthQuery object initialized with a provider.\n * @param method - Method to request.\n * @param args - Arguments to send.\n * @returns Promise resolving the request.\n */\nexport function query(\n  ethQuery: EthQuery,\n  method: string,\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[] = [],\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    const cb = (error: unknown, result: unknown) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n      resolve(result);\n    };\n\n    // Using `in` rather than `hasProperty` so that we look up the prototype\n    // chain for the method.\n    if (method in ethQuery && typeof ethQuery[method] === 'function') {\n      ethQuery[method](...args, cb);\n    } else {\n      ethQuery.sendAsync({ method, params: args }, cb);\n    }\n  });\n}\n\n/**\n * Converts valid hex strings to decimal numbers, and handles unexpected arg types.\n *\n * @param value - a string that is either a hexadecimal with `0x` prefix or a decimal string.\n * @returns a decimal number.\n */\nexport const convertHexToDecimal = (\n  value: string | undefined = '0x0',\n): number => {\n  if (isStrictHexString(value)) {\n    return parseInt(value, 16);\n  }\n\n  return Number(value) ? Number(value) : 0;\n};\n\ntype PlainObject = Record<number | string | symbol, unknown>;\n\n/**\n * Determines whether a value is a \"plain\" object.\n *\n * @param value - A value to check\n * @returns True if the passed value is a plain object\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n/**\n * Like {@link Array}, but always non-empty.\n *\n * @template T - The non-empty array member type.\n */\nexport type NonEmptyArray<T> = [T, ...T[]];\n\n/**\n * Type guard for {@link NonEmptyArray}.\n *\n * @template T - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray<T>(value: T[]): value is NonEmptyArray<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Type guard for {@link Json}.\n *\n * @param value - The value to check.\n * @returns Whether the value is valid JSON.\n */\nexport function isValidJson(value: unknown): value is Json {\n  try {\n    return deepEqual(value, JSON.parse(JSON.stringify(value)));\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Utility method to log if error is a common fetch error and otherwise rethrow it.\n *\n * @param error - Caught error that we should either rethrow or log to console\n * @param codesToCatch - array of error codes for errors we want to catch and log in a particular context\n */\nfunction logOrRethrowError(error: unknown, codesToCatch: number[] = []) {\n  if (!error) {\n    return;\n  }\n\n  if (error instanceof Error) {\n    const includesErrorCodeToCatch = codesToCatch.some((code) =>\n      error.message.includes(`Fetch failed with status '${code}'`),\n    );\n\n    if (\n      includesErrorCodeToCatch ||\n      error.message.includes('Failed to fetch') ||\n      error === TIMEOUT_ERROR\n    ) {\n      console.error(error);\n    } else {\n      throw error;\n    }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n    throw error;\n  }\n}\n"],"mappings":"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","names":[]}