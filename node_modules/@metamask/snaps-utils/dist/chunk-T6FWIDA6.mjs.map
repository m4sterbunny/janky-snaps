{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from 'superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"],"mappings":";AACA,SAAS,cAAc,qBAAqB;AAE5C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,OACL;AAQA,IAAK,mBAAL,kBAAKA,sBAAL;AACL,EAAAA,kBAAA,iBAAc;AACd,EAAAA,kBAAA,cAAW;AAFD,SAAAA;AAAA,GAAA;AAKL,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AAAA,EACA;AAAA,EACA;AACF;AAIO,IAAM,2BAA2B,KAAK;AAAA,EAC3C,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM,SAAS,KAAK,OAAO,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC1C,YAAY;AAAA,IACV,OAAO;AAAA,MACL,MAAM,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,MAChC,KAAK,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,qBACd,OAC6B;AAC7B,SAAO,GAAG,OAAO,wBAAwB;AAC3C;AAQO,SAAS,2BACd,OACqC;AACrC;AAAA,IACE;AAAA,IACA;AAAA,IACA,IAAI,gCAA4B;AAAA,EAClC;AACF;AAuCO,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,SAAM;AACN,EAAAA,gBAAA,WAAQ;AAFE,SAAAA;AAAA,GAAA;AAUL,IAAK,8BAAL,kBAAKC,iCAAL;AACL,EAAAA,6BAAA,kBAAe;AACf,EAAAA,6BAAA,qBAAkB;AAClB,EAAAA,6BAAA,wBAAqB;AACrB,EAAAA,6BAAA,oBAAiB;AAJP,SAAAA;AAAA,GAAA;AAQL,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,mBAAA,cAAW;AACX,EAAAA,mBAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAwBL,IAAM,MAAM,CAAC,OAAwB,CAAC,MAC3C,OAAO,MAAM,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,KAAK;AAEzB,UAAM,YAAY,KAAK,IAAI;AAC3B,sBAAkB,KAAK,SAAS;AAChC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,sBAAsB,MAAM,SAAS,CAAC;AAAA,EAC/C;AACF,CAAC;AASI,SAAS,WACd,KACA,OAAwB,CAAC,GACJ;AACrB,SAAO,GAAG,KAAK,IAAI,IAAI,CAAC;AAC1B;AAGO,IAAM,6BAA6B;","names":["NpmSnapFileNames","SnapIdPrefixes","SnapValidationFailureReason","SNAP_STREAM_NAMES"]}