{"version":3,"sources":["../src/localization.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from 'superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"],"mappings":";;;;;AAAA,SAAS,uBAAuB;AAEhC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMA,IAAM,qBAAqB,CAAC,eAAe,cAAc;AAEzD,IAAM,yBAAyB,OAAO;AAAA,EAC3C,QAAQ,OAAO;AAAA,EACf,UAAU;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,aAAa,SAAS,OAAO,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,8BACd,mBACiC;AACjC,aAAW,QAAQ,mBAAmB;AACpC,QAAI;AACF,WAAK,SAAS,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,sBAAsB;AAAA,IACzE,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,yCAAyC,KAAK,IAAI,MAAM,MAAM,OAAO;AAAA,QACvE;AAAA,MACF;AAEA,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,sCAAsC,KAAK,IAAI;AAAA,QACjD;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,oBACd,QACA,mBACA;AACA,QAAM,OAAO,kBAAkB;AAAA,IAC7B,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,EACpD;AAEA,MAAI,CAAC,MAAM;AACT,WAAO,kBAAkB;AAAA,MACvB,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB;AAa1B,SAAS,UAAU,OAAe,MAAoC;AAC3E,QAAM,UAAU,MAAM,SAAS,iBAAiB;AAChD,QAAM,QAAQ,MAAM,KAAK,OAAO;AAEhC,SAAO,MAAM,OAAe,CAAC,QAAQ,CAAC,OAAO,GAAG,MAAM;AACpD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,SAAS,IAAI,KAAK,CAAC;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK,gCAAgC,IAAI,KAAK,CAAC,SACrE,KAAK,MACP;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,OAAO,YAAY,OAAO;AAAA,EAClD,GAAG,KAAK;AACV;AAWO,SAAS,yBACd,cACA,QACA,mBACA;AACA,QAAM,OAAO,oBAAoB,QAAQ,iBAAiB;AAE1D,SAAO,mBAAmB,OAAO,CAAC,UAAU,UAAU;AACpD,UAAM,cAAc,UAAU,SAAS,KAAK,GAAG,IAAI;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,KAAK,GAAG;AAAA,IACX;AAAA,EACF,GAAG,YAAY;AACjB;AASO,SAAS,kCACd,cACA,mBACA;AACA,MAAI;AAGF,sBACG,OAAO,CAAC,SAAS,KAAK,WAAW,IAAI,EACrC,QAAQ,CAAC,SAAS;AACjB,+BAAyB,cAAc,KAAK,QAAQ,iBAAiB;AAAA,IACvE,CAAC;AAGH,6BAAyB,cAAc,MAAM,iBAAiB;AAAA,EAChE,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,qCAAqC,gBAAgB,KAAK,CAAC;AAAA,IAC7D;AAAA,EACF;AACF;","names":[]}