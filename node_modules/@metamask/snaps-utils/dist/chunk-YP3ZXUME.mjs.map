{"version":3,"sources":["../src/manifest/manifest.ts","../src/npm.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assertExhaustive, assert, isPlainObject } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\nimport { promises as fs } from 'fs';\nimport pathUtils from 'path';\n\nimport { deepClone } from '../deep-clone';\nimport { readJsonFile } from '../fs';\nimport { getSvgDimensions } from '../icon';\nimport { validateNpmSnap } from '../npm';\nimport {\n  getSnapChecksum,\n  ProgrammaticallyFixableSnapError,\n  validateSnapShasum,\n} from '../snaps';\nimport type { SnapFiles, UnvalidatedSnapFiles } from '../types';\nimport { NpmSnapFileNames, SnapValidationFailureReason } from '../types';\nimport { readVirtualFile, VirtualFile } from '../virtual-file/node';\nimport type { SnapManifest } from './validation';\n\nconst MANIFEST_SORT_ORDER: Record<keyof SnapManifest, number> = {\n  $schema: 1,\n  version: 2,\n  description: 3,\n  proposedName: 4,\n  repository: 5,\n  source: 6,\n  initialConnections: 7,\n  initialPermissions: 8,\n  manifestVersion: 9,\n};\n\n/**\n * The result from the `checkManifest` function.\n *\n * @property manifest - The fixed manifest object.\n * @property updated - Whether the manifest was updated.\n * @property warnings - An array of warnings that were encountered during\n * processing of the manifest files. These warnings are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n * @property errors - An array of errors that were encountered during\n * processing of the manifest files. These errors are not logged to the\n * console automatically, so depending on the environment the function is called\n * in, a different method for logging can be used.\n */\nexport type CheckManifestResult = {\n  manifest: SnapManifest;\n  updated?: boolean;\n  warnings: string[];\n  errors: string[];\n};\n\nexport type WriteFileFunction = (path: string, data: string) => Promise<void>;\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param writeManifest - Whether to write the fixed manifest to disk.\n * @param sourceCode - The source code of the Snap.\n * @param writeFileFn - The function to use to write the manifest to disk.\n * @returns Whether the manifest was updated, and an array of warnings that\n * were encountered during processing of the manifest files.\n */\nexport async function checkManifest(\n  basePath: string,\n  writeManifest = true,\n  sourceCode?: string,\n  writeFileFn: WriteFileFunction = fs.writeFile,\n): Promise<CheckManifestResult> {\n  const warnings: string[] = [];\n  const errors: string[] = [];\n\n  let updated = false;\n\n  const manifestPath = pathUtils.join(basePath, NpmSnapFileNames.Manifest);\n  const manifestFile = await readJsonFile(manifestPath);\n  const unvalidatedManifest = manifestFile.result;\n\n  const packageFile = await readJsonFile(\n    pathUtils.join(basePath, NpmSnapFileNames.PackageJson),\n  );\n\n  const auxiliaryFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.files,\n  );\n\n  const localizationFilePaths = getSnapFilePaths(\n    unvalidatedManifest,\n    (manifest) => manifest?.source?.locales,\n  );\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: manifestFile,\n    packageJson: packageFile,\n    sourceCode: await getSnapSourceCode(\n      basePath,\n      unvalidatedManifest,\n      sourceCode,\n    ),\n    svgIcon: await getSnapIcon(basePath, unvalidatedManifest),\n    // Intentionally pass null as the encoding here since the files may be binary\n    auxiliaryFiles:\n      (await getSnapFiles(basePath, auxiliaryFilePaths, null)) ?? [],\n    localizationFiles:\n      (await getSnapFiles(basePath, localizationFilePaths)) ?? [],\n  };\n\n  let manifest: VirtualFile<SnapManifest> | undefined;\n  try {\n    ({ manifest } = await validateNpmSnap(snapFiles));\n  } catch (error) {\n    if (error instanceof ProgrammaticallyFixableSnapError) {\n      errors.push(error.message);\n\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      let currentError = error;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the `SnapValidationFailureReason` enum, so we only\n      // attempt to fix the manifest the same amount of times as there are\n      // reasons in the enum.\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = await fixManifest(\n          manifest\n            ? { ...partiallyValidatedFiles, manifest }\n            : partiallyValidatedFiles,\n          currentError,\n        );\n\n        try {\n          await validateNpmSnapManifest({\n            ...partiallyValidatedFiles,\n            manifest,\n          });\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          currentError = nextValidationError;\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n\n          errors.push(currentError.message);\n        }\n      }\n\n      updated = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript assumes `manifest` can still be undefined, that is not the case.\n  // But we assert to keep TypeScript happy.\n  assert(manifest);\n\n  const validatedManifest = manifest.result;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    warnings.push(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  if (!snapFiles.svgIcon) {\n    warnings.push(\n      'No icon found in the Snap manifest. It is recommended to include an icon for the Snap. See https://docs.metamask.io/snaps/how-to/design-a-snap/#guidelines-at-a-glance for more information.',\n    );\n  }\n\n  const iconDimensions =\n    snapFiles.svgIcon && getSvgDimensions(snapFiles.svgIcon.toString());\n  if (iconDimensions && iconDimensions.height !== iconDimensions.width) {\n    warnings.push(\n      'The icon in the Snap manifest is not square. It is recommended to use a square icon for the Snap.',\n    );\n  }\n\n  if (writeManifest) {\n    try {\n      const newManifest = `${JSON.stringify(\n        getWritableManifest(validatedManifest),\n        null,\n        2,\n      )}\\n`;\n\n      if (updated || newManifest !== manifestFile.value) {\n        await writeFileFn(\n          pathUtils.join(basePath, NpmSnapFileNames.Manifest),\n          newManifest,\n        );\n      }\n    } catch (error) {\n      // Note: This error isn't pushed to the errors array, because it's not an\n      // error in the manifest itself.\n      throw new Error(`Failed to update snap.manifest.json: ${error.message}`);\n    }\n  }\n\n  return { manifest: validatedManifest, updated, warnings, errors };\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nexport async function fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): Promise<VirtualFile<SnapManifest>> {\n  const { manifest, packageJson } = snapFiles;\n  const clonedFile = manifest.clone();\n  const manifestCopy = clonedFile.result;\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.result.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.result.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.result.repository\n        ? deepClone(packageJson.result.repository)\n        : undefined;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = await getSnapChecksum(snapFiles);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(error.reason);\n  }\n\n  clonedFile.result = manifestCopy;\n  clonedFile.value = JSON.stringify(manifestCopy);\n  return clonedFile;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param sourceCode - Override source code for plugins.\n * @returns The contents of the bundle file, if any.\n */\nexport async function getSnapSourceCode(\n  basePath: string,\n  manifest: Json,\n  sourceCode?: string,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n    ?.npm?.filePath;\n\n  if (!sourceFilePath) {\n    return undefined;\n  }\n\n  if (sourceCode) {\n    return new VirtualFile({\n      path: pathUtils.join(basePath, sourceFilePath),\n      value: sourceCode,\n    });\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, sourceFilePath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(\n      `Failed to read snap bundle file: ${getErrorMessage(error)}`,\n    );\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * icon and read the file.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the icon, if any.\n */\nexport async function getSnapIcon(\n  basePath: string,\n  manifest: Json,\n): Promise<VirtualFile | undefined> {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const iconPath = (manifest as Partial<SnapManifest>).source?.location?.npm\n    ?.iconPath;\n\n  if (!iconPath) {\n    return undefined;\n  }\n\n  try {\n    const virtualFile = await readVirtualFile(\n      pathUtils.join(basePath, iconPath),\n      'utf8',\n    );\n    return virtualFile;\n  } catch (error) {\n    throw new Error(`Failed to read snap icon file: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Get an array of paths from an unvalidated Snap manifest.\n *\n * @param manifest - The unvalidated Snap manifest file contents.\n * @param selector - A function that returns the paths to the files.\n * @returns The paths to the files, if any.\n */\nexport function getSnapFilePaths(\n  manifest: Json,\n  selector: (manifest: Partial<SnapManifest>) => string[] | undefined,\n) {\n  if (!isPlainObject(manifest)) {\n    return undefined;\n  }\n\n  const snapManifest = manifest as Partial<SnapManifest>;\n  const paths = selector(snapManifest);\n\n  if (!Array.isArray(paths)) {\n    return undefined;\n  }\n\n  return paths;\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the files with the\n * given paths and read them.\n *\n * @param basePath - The path to the folder with the manifest files.\n * @param paths - The paths to the files.\n * @param encoding - An optional encoding to pass down to readVirtualFile.\n * @returns A list of auxiliary files and their contents, if any.\n */\nexport async function getSnapFiles(\n  basePath: string,\n  paths: string[] | undefined,\n  encoding: BufferEncoding | null = 'utf8',\n): Promise<VirtualFile[] | undefined> {\n  if (!paths) {\n    return undefined;\n  }\n\n  try {\n    return await Promise.all(\n      paths.map(async (filePath) =>\n        readVirtualFile(pathUtils.join(basePath, filePath), encoding),\n      ),\n    );\n  } catch (error) {\n    throw new Error(`Failed to read snap files: ${getErrorMessage(error)}`);\n  }\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n\n  const keys = Object.keys(\n    repository ? { ...remaining, repository } : remaining,\n  ) as (keyof SnapManifest)[];\n\n  const writableManifest = keys\n    .sort((a, b) => MANIFEST_SORT_ORDER[a] - MANIFEST_SORT_ORDER[b])\n    .reduce<Partial<SnapManifest>>(\n      (result, key) => ({\n        ...result,\n        [key]: manifest[key],\n      }),\n      {},\n    );\n\n  return writableManifest as SnapManifest;\n}\n\n/**\n * Validates the fields of an NPM Snap manifest that has already passed JSON\n * Schema validation.\n *\n * @param snapFiles - The relevant snap files to validate.\n * @param snapFiles.manifest - The npm Snap manifest to validate.\n * @param snapFiles.packageJson - The npm Snap's `package.json`.\n * @param snapFiles.sourceCode - The Snap's source code.\n * @param snapFiles.svgIcon - The Snap's optional icon.\n * @param snapFiles.auxiliaryFiles - Any auxiliary files required by the snap at runtime.\n * @param snapFiles.localizationFiles - The Snap's localization files.\n */\nexport async function validateNpmSnapManifest({\n  manifest,\n  packageJson,\n  sourceCode,\n  svgIcon,\n  auxiliaryFiles,\n  localizationFiles,\n}: SnapFiles) {\n  const packageJsonName = packageJson.result.name;\n  const packageJsonVersion = packageJson.result.version;\n  const packageJsonRepository = packageJson.result.repository;\n\n  const manifestPackageName = manifest.result.source.location.npm.packageName;\n  const manifestPackageVersion = manifest.result.version;\n  const manifestRepository = manifest.result.repository;\n\n  if (packageJsonName !== manifestPackageName) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package name (\"${manifestPackageName}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"name\" field (\"${packageJsonName}\").`,\n      SnapValidationFailureReason.NameMismatch,\n    );\n  }\n\n  if (packageJsonVersion !== manifestPackageVersion) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" npm package version (\"${manifestPackageVersion}\") does not match the \"${NpmSnapFileNames.PackageJson}\" \"version\" field (\"${packageJsonVersion}\").`,\n      SnapValidationFailureReason.VersionMismatch,\n    );\n  }\n\n  if (\n    // The repository may be `undefined` in package.json but can only be defined\n    // or `null` in the Snap manifest due to TS@<4.4 issues.\n    (packageJsonRepository || manifestRepository) &&\n    !deepEqual(packageJsonRepository, manifestRepository)\n  ) {\n    throw new ProgrammaticallyFixableSnapError(\n      `\"${NpmSnapFileNames.Manifest}\" \"repository\" field does not match the \"${NpmSnapFileNames.PackageJson}\" \"repository\" field.`,\n      SnapValidationFailureReason.RepositoryMismatch,\n    );\n  }\n\n  await validateSnapShasum(\n    { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles },\n    `\"${NpmSnapFileNames.Manifest}\" \"shasum\" field does not match computed shasum.`,\n  );\n}\n","import { assertIsSnapIcon } from './icon';\nimport {\n  getValidatedLocalizationFiles,\n  validateSnapManifestLocalizations,\n} from './localization';\nimport { validateNpmSnapManifest } from './manifest/manifest';\nimport { assertIsSnapManifest } from './manifest/validation';\nimport type { SnapFiles, UnvalidatedSnapFiles } from './types';\nimport { assertIsNpmSnapPackageJson, NpmSnapFileNames } from './types';\n\nexport const EXPECTED_SNAP_FILES = [\n  'manifest',\n  'packageJson',\n  'sourceCode',\n] as const;\n\nexport const SnapFileNameFromKey = {\n  manifest: NpmSnapFileNames.Manifest,\n  packageJson: NpmSnapFileNames.PackageJson,\n  sourceCode: 'source code bundle',\n} as const;\n\n// TODO: Refactor this to be more shared with other validation.\n\n/**\n * Validates the files extracted from an npm Snap package tarball by ensuring\n * that they're non-empty and that the Json files match their respective schemas\n * and the Snaps publishing specification.\n *\n * @param snapFiles - The object containing the expected Snap file contents,\n * if any.\n * @param errorPrefix - The prefix of the error message.\n * @returns A tuple of the Snap manifest object and the Snap source code.\n */\nexport async function validateNpmSnap(\n  snapFiles: UnvalidatedSnapFiles,\n  errorPrefix?: `${string}: `,\n): Promise<SnapFiles> {\n  EXPECTED_SNAP_FILES.forEach((key) => {\n    if (!snapFiles[key]) {\n      throw new Error(\n        `${errorPrefix ?? ''}Missing file \"${SnapFileNameFromKey[key]}\".`,\n      );\n    }\n  });\n\n  // Typecast: We are assured that the required files exist if we get here.\n  const {\n    manifest,\n    packageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  } = snapFiles as SnapFiles;\n\n  try {\n    assertIsSnapManifest(manifest.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n  const validatedManifest = manifest;\n\n  const { iconPath } = validatedManifest.result.source.location.npm;\n  if (iconPath && !svgIcon) {\n    throw new Error(`Missing file \"${iconPath}\".`);\n  }\n\n  try {\n    assertIsNpmSnapPackageJson(packageJson.result);\n  } catch (error) {\n    throw new Error(`${errorPrefix ?? ''}${error.message}`);\n  }\n\n  const validatedPackageJson = packageJson;\n  await validateNpmSnapManifest({\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  });\n\n  if (svgIcon) {\n    try {\n      assertIsSnapIcon(svgIcon);\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  if (localizationFiles) {\n    try {\n      // This function validates and returns the localization files. We don't\n      // use the return value here, but we do want to validate the files.\n      getValidatedLocalizationFiles(localizationFiles);\n\n      validateSnapManifestLocalizations(\n        manifest.result,\n        localizationFiles.map((file) => file.result),\n      );\n    } catch (error) {\n      throw new Error(`${errorPrefix ?? ''}${error.message}`);\n    }\n  }\n\n  return {\n    manifest: validatedManifest,\n    packageJson: validatedPackageJson,\n    sourceCode,\n    svgIcon,\n    auxiliaryFiles,\n    localizationFiles,\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,uBAAuB;AAEhC,SAAS,kBAAkB,QAAQ,qBAAqB;AACxD,OAAO,eAAe;AACtB,SAAS,YAAY,UAAU;AAC/B,OAAO,eAAe;AAgBtB,IAAM,sBAA0D;AAAA,EAC9D,SAAS;AAAA,EACT,SAAS;AAAA,EACT,aAAa;AAAA,EACb,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,iBAAiB;AACnB;AAqCA,eAAsB,cACpB,UACA,gBAAgB,MAChB,YACA,cAAiC,GAAG,WACN;AAC9B,QAAM,WAAqB,CAAC;AAC5B,QAAM,SAAmB,CAAC;AAE1B,MAAI,UAAU;AAEd,QAAM,eAAe,UAAU,KAAK,6CAAmC;AACvE,QAAM,eAAe,MAAM,aAAa,YAAY;AACpD,QAAM,sBAAsB,aAAa;AAEzC,QAAM,cAAc,MAAM;AAAA,IACxB,UAAU,KAAK,0CAAsC;AAAA,EACvD;AAEA,QAAM,qBAAqB;AAAA,IACzB;AAAA,IACA,CAACA,cAAaA,WAAU,QAAQ;AAAA,EAClC;AAEA,QAAM,wBAAwB;AAAA,IAC5B;AAAA,IACA,CAACA,cAAaA,WAAU,QAAQ;AAAA,EAClC;AAEA,QAAM,YAAkC;AAAA,IACtC,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY,MAAM;AAAA,MAChB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA,SAAS,MAAM,YAAY,UAAU,mBAAmB;AAAA;AAAA,IAExD,gBACG,MAAM,aAAa,UAAU,oBAAoB,IAAI,KAAM,CAAC;AAAA,IAC/D,mBACG,MAAM,aAAa,UAAU,qBAAqB,KAAM,CAAC;AAAA,EAC9D;AAEA,MAAI;AACJ,MAAI;AACF,KAAC,EAAE,SAAS,IAAI,MAAM,gBAAgB,SAAS;AAAA,EACjD,SAAS,OAAO;AACd,QAAI,iBAAiB,kCAAkC;AACrD,aAAO,KAAK,MAAM,OAAO;AAGzB,YAAM,0BAA0B;AAEhC,UAAI,YAAY;AAChB,UAAI,eAAe;AACnB,YAAM,cAAc,OAAO,KAAK,2BAA2B,EAAE;AAM7D,eAAS,WAAW,GAAG,aAAa,YAAY,aAAa,YAAY;AACvE,mBAAW,MAAM;AAAA,UACf,WACI,EAAE,GAAG,yBAAyB,SAAS,IACvC;AAAA,UACJ;AAAA,QACF;AAEA,YAAI;AACF,gBAAM,wBAAwB;AAAA,YAC5B,GAAG;AAAA,YACH;AAAA,UACF,CAAC;AAED,sBAAY;AAAA,QACd,SAAS,qBAAqB;AAC5B,yBAAe;AAEf,cACE,EACE,+BAA+B,qCAEhC,aAAa,eAAe,CAAC,WAC9B;AACA,kBAAM,IAAI;AAAA,cACR;AAAA,EAAqF,MAAM,OAAO;AAAA,YACpG;AAAA,UACF;AAEA,iBAAO,KAAK,aAAa,OAAO;AAAA,QAClC;AAAA,MACF;AAEA,gBAAU;AAAA,IACZ,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AAIA,SAAO,QAAQ;AAEf,QAAM,oBAAoB,SAAS;AAGnC,QAAM,oBAAoB,CAAC,YAAY;AAEvC,QAAM,2BAA2B,kBAAkB;AAAA,IACjD,CAAC,QAAQ,CAAC,kBAAkB,GAAG;AAAA,EACjC;AAEA,MAAI,yBAAyB,SAAS,GAAG;AACvC,aAAS;AAAA,MACP;AAAA,EAAiD,yBAAyB;AAAA,QACxE,CAAC,YAAY,iBAAiB;AAC5B,iBAAO,GAAG,UAAU,IAAK,YAAY;AAAA;AAAA,QACvC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI,CAAC,UAAU,SAAS;AACtB,aAAS;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAEA,QAAM,iBACJ,UAAU,WAAW,iBAAiB,UAAU,QAAQ,SAAS,CAAC;AACpE,MAAI,kBAAkB,eAAe,WAAW,eAAe,OAAO;AACpE,aAAS;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAEA,MAAI,eAAe;AACjB,QAAI;AACF,YAAM,cAAc,GAAG,KAAK;AAAA,QAC1B,oBAAoB,iBAAiB;AAAA,QACrC;AAAA,QACA;AAAA,MACF,CAAC;AAAA;AAED,UAAI,WAAW,gBAAgB,aAAa,OAAO;AACjD,cAAM;AAAA,UACJ,UAAU,KAAK,6CAAmC;AAAA,UAClD;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AAGd,YAAM,IAAI,MAAM,wCAAwC,MAAM,OAAO,EAAE;AAAA,IACzE;AAAA,EACF;AAEA,SAAO,EAAE,UAAU,mBAAmB,SAAS,UAAU,OAAO;AAClE;AAWA,eAAsB,YACpB,WACA,OACoC;AACpC,QAAM,EAAE,UAAU,YAAY,IAAI;AAClC,QAAM,aAAa,SAAS,MAAM;AAClC,QAAM,eAAe,WAAW;AAEhC,UAAQ,MAAM,QAAQ;AAAA,IACpB;AACE,mBAAa,OAAO,SAAS,IAAI,cAAc,YAAY,OAAO;AAClE;AAAA,IAEF;AACE,mBAAa,UAAU,YAAY,OAAO;AAC1C;AAAA,IAEF;AACE,mBAAa,aAAa,YAAY,OAAO,aACzC,UAAU,YAAY,OAAO,UAAU,IACvC;AACJ;AAAA,IAEF;AACE,mBAAa,OAAO,SAAS,MAAM,gBAAgB,SAAS;AAC5D;AAAA,IAGF;AACE,uBAAiB,MAAM,MAAM;AAAA,EACjC;AAEA,aAAW,SAAS;AACpB,aAAW,QAAQ,KAAK,UAAU,YAAY;AAC9C,SAAO;AACT;AAWA,eAAsB,kBACpB,UACA,UACA,YACkC;AAClC,MAAI,CAAC,cAAc,QAAQ,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,iBAAkB,SAAmC,QAAQ,UAC/D,KAAK;AAET,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AAEA,MAAI,YAAY;AACd,WAAO,IAAI,YAAY;AAAA,MACrB,MAAM,UAAU,KAAK,UAAU,cAAc;AAAA,MAC7C,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,MAAI;AACF,UAAM,cAAc,MAAM;AAAA,MACxB,UAAU,KAAK,UAAU,cAAc;AAAA,MACvC;AAAA,IACF;AACA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,oCAAoC,gBAAgB,KAAK,CAAC;AAAA,IAC5D;AAAA,EACF;AACF;AAUA,eAAsB,YACpB,UACA,UACkC;AAClC,MAAI,CAAC,cAAc,QAAQ,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,WAAY,SAAmC,QAAQ,UAAU,KACnE;AAEJ,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAEA,MAAI;AACF,UAAM,cAAc,MAAM;AAAA,MACxB,UAAU,KAAK,UAAU,QAAQ;AAAA,MACjC;AAAA,IACF;AACA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,kCAAkC,gBAAgB,KAAK,CAAC,EAAE;AAAA,EAC5E;AACF;AASO,SAAS,iBACd,UACA,UACA;AACA,MAAI,CAAC,cAAc,QAAQ,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,eAAe;AACrB,QAAM,QAAQ,SAAS,YAAY;AAEnC,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAWA,eAAsB,aACpB,UACA,OACA,WAAkC,QACE;AACpC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,MAAM,QAAQ;AAAA,MACnB,MAAM;AAAA,QAAI,OAAO,aACf,gBAAgB,UAAU,KAAK,UAAU,QAAQ,GAAG,QAAQ;AAAA,MAC9D;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,8BAA8B,gBAAgB,KAAK,CAAC,EAAE;AAAA,EACxE;AACF;AASO,SAAS,oBAAoB,UAAsC;AACxE,QAAM,EAAE,YAAY,GAAG,UAAU,IAAI;AAErC,QAAM,OAAO,OAAO;AAAA,IAClB,aAAa,EAAE,GAAG,WAAW,WAAW,IAAI;AAAA,EAC9C;AAEA,QAAM,mBAAmB,KACtB,KAAK,CAAC,GAAG,MAAM,oBAAoB,CAAC,IAAI,oBAAoB,CAAC,CAAC,EAC9D;AAAA,IACC,CAAC,QAAQ,SAAS;AAAA,MAChB,GAAG;AAAA,MACH,CAAC,GAAG,GAAG,SAAS,GAAG;AAAA,IACrB;AAAA,IACA,CAAC;AAAA,EACH;AAEF,SAAO;AACT;AAcA,eAAsB,wBAAwB;AAAA,EAC5C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAc;AACZ,QAAM,kBAAkB,YAAY,OAAO;AAC3C,QAAM,qBAAqB,YAAY,OAAO;AAC9C,QAAM,wBAAwB,YAAY,OAAO;AAEjD,QAAM,sBAAsB,SAAS,OAAO,OAAO,SAAS,IAAI;AAChE,QAAM,yBAAyB,SAAS,OAAO;AAC/C,QAAM,qBAAqB,SAAS,OAAO;AAE3C,MAAI,oBAAoB,qBAAqB;AAC3C,UAAM,IAAI;AAAA,MACR,uCAA6B,wBAAwB,mBAAmB,0DAAsD,oBAAoB,eAAe;AAAA;AAAA,IAEnK;AAAA,EACF;AAEA,MAAI,uBAAuB,wBAAwB;AACjD,UAAM,IAAI;AAAA,MACR,uCAA6B,2BAA2B,sBAAsB,0DAAsD,uBAAuB,kBAAkB;AAAA;AAAA,IAE/K;AAAA,EACF;AAEA;AAAA;AAAA;AAAA,KAGG,yBAAyB,uBAC1B,CAAC,UAAU,uBAAuB,kBAAkB;AAAA,IACpD;AACA,UAAM,IAAI;AAAA,MACR,uCAA6B,4EAAwE;AAAA;AAAA,IAEvG;AAAA,EACF;AAEA,QAAM;AAAA,IACJ,EAAE,UAAU,YAAY,SAAS,gBAAgB,kBAAkB;AAAA,IACnE,uCAA6B;AAAA,EAC/B;AACF;;;ACteO,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA;AAAA,EACA,YAAY;AACd;AAcA,eAAsB,gBACpB,WACA,aACoB;AACpB,sBAAoB,QAAQ,CAAC,QAAQ;AACnC,QAAI,CAAC,UAAU,GAAG,GAAG;AACnB,YAAM,IAAI;AAAA,QACR,GAAG,eAAe,EAAE,iBAAiB,oBAAoB,GAAG,CAAC;AAAA,MAC/D;AAAA,IACF;AAAA,EACF,CAAC;AAGD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,MAAI;AACF,yBAAqB,SAAS,MAAM;AAAA,EACtC,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,GAAG,eAAe,EAAE,GAAG,MAAM,OAAO,EAAE;AAAA,EACxD;AACA,QAAM,oBAAoB;AAE1B,QAAM,EAAE,SAAS,IAAI,kBAAkB,OAAO,OAAO,SAAS;AAC9D,MAAI,YAAY,CAAC,SAAS;AACxB,UAAM,IAAI,MAAM,iBAAiB,QAAQ,IAAI;AAAA,EAC/C;AAEA,MAAI;AACF,+BAA2B,YAAY,MAAM;AAAA,EAC/C,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,GAAG,eAAe,EAAE,GAAG,MAAM,OAAO,EAAE;AAAA,EACxD;AAEA,QAAM,uBAAuB;AAC7B,QAAM,wBAAwB;AAAA,IAC5B,UAAU;AAAA,IACV,aAAa;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,MAAI,SAAS;AACX,QAAI;AACF,uBAAiB,OAAO;AAAA,IAC1B,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,GAAG,eAAe,EAAE,GAAG,MAAM,OAAO,EAAE;AAAA,IACxD;AAAA,EACF;AAEA,MAAI,mBAAmB;AACrB,QAAI;AAGF,oCAA8B,iBAAiB;AAE/C;AAAA,QACE,SAAS;AAAA,QACT,kBAAkB,IAAI,CAAC,SAAS,KAAK,MAAM;AAAA,MAC7C;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,GAAG,eAAe,EAAE,GAAG,MAAM,OAAO,EAAE;AAAA,IACxD;AAAA,EACF;AAEA,SAAO;AAAA,IACL,UAAU;AAAA,IACV,aAAa;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":["manifest"]}