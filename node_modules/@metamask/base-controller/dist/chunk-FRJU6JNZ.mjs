import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-XUI43LEZ.mjs";

// src/BaseControllerV2.ts
import { enablePatches, produceWithPatches, applyPatches, freeze } from "immer";
enablePatches();
var _internalState;
var BaseController = class {
  /**
   * Creates a BaseController instance.
   *
   * @param options - Controller options.
   * @param options.messenger - Controller messaging system.
   * @param options.metadata - ControllerState metadata, describing how to "anonymize" the state, and which
   * parts should be persisted.
   * @param options.name - The name of the controller, used as a namespace for events and actions.
   * @param options.state - Initial controller state.
   */
  constructor({
    messenger,
    metadata,
    name,
    state
  }) {
    __privateAdd(this, _internalState, void 0);
    this.messagingSystem = messenger;
    this.name = name;
    __privateSet(this, _internalState, freeze(state, true));
    this.metadata = metadata;
    this.messagingSystem.registerActionHandler(
      `${name}:getState`,
      () => this.state
    );
    this.messagingSystem.registerInitialEventPayload({
      eventType: `${name}:stateChange`,
      getPayload: () => [this.state, []]
    });
  }
  /**
   * Retrieves current controller state.
   *
   * @returns The current state.
   */
  get state() {
    return __privateGet(this, _internalState);
  }
  set state(_) {
    throw new Error(
      `Controller state cannot be directly mutated; use 'update' method instead.`
    );
  }
  /**
   * Updates controller state. Accepts a callback that is passed a draft copy
   * of the controller state. If a value is returned, it is set as the new
   * state. Otherwise, any changes made within that callback to the draft are
   * applied to the controller state.
   *
   * @param callback - Callback for updating state, passed a draft state
   * object. Return a new state object or mutate the draft to update state.
   * @returns An object that has the next state, patches applied in the update and inverse patches to
   * rollback the update.
   */
  update(callback) {
    const [nextState, patches, inversePatches] = produceWithPatches(__privateGet(this, _internalState), callback);
    __privateSet(this, _internalState, nextState);
    this.messagingSystem.publish(
      `${this.name}:stateChange`,
      nextState,
      patches
    );
    return { nextState, patches, inversePatches };
  }
  /**
   * Applies immer patches to the current state. The patches come from the
   * update function itself and can either be normal or inverse patches.
   *
   * @param patches - An array of immer patches that are to be applied to make
   * or undo changes.
   */
  applyPatches(patches) {
    const nextState = applyPatches(__privateGet(this, _internalState), patches);
    __privateSet(this, _internalState, nextState);
    this.messagingSystem.publish(
      `${this.name}:stateChange`,
      nextState,
      patches
    );
  }
  /**
   * Prepares the controller for garbage collection. This should be extended
   * by any subclasses to clean up any additional connections or events.
   *
   * The only cleanup performed here is to remove listeners. While technically
   * this is not required to ensure this instance is garbage collected, it at
   * least ensures this instance won't be responsible for preventing the
   * listeners from being garbage collected.
   */
  destroy() {
    this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
  }
};
_internalState = new WeakMap();
function getAnonymizedState(state, metadata) {
  return deriveStateFromMetadata(state, metadata, "anonymous");
}
function getPersistentState(state, metadata) {
  return deriveStateFromMetadata(state, metadata, "persist");
}
function deriveStateFromMetadata(state, metadata, metadataProperty) {
  return Object.keys(state).reduce((persistedState, key) => {
    try {
      const stateMetadata = metadata[key];
      if (!stateMetadata) {
        throw new Error(`No metadata found for '${String(key)}'`);
      }
      const propertyMetadata = stateMetadata[metadataProperty];
      const stateProperty = state[key];
      if (typeof propertyMetadata === "function") {
        persistedState[key] = propertyMetadata(stateProperty);
      } else if (propertyMetadata) {
        persistedState[key] = stateProperty;
      }
      return persistedState;
    } catch (error) {
      setTimeout(() => {
        throw error;
      });
      return persistedState;
    }
  }, {});
}

export {
  BaseController,
  getAnonymizedState,
  getPersistentState
};
//# sourceMappingURL=chunk-FRJU6JNZ.mjs.map