{"version":3,"sources":["../src/RestrictedControllerMessenger.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ActionConstraint,\n  ActionHandler,\n  ControllerMessenger,\n  EventConstraint,\n  ExtractActionParameters,\n  ExtractActionResponse,\n  ExtractEventHandler,\n  ExtractEventPayload,\n  NamespacedName,\n  NotNamespacedBy,\n  SelectorEventHandler,\n  SelectorFunction,\n} from './ControllerMessenger';\n\n/**\n * A restricted controller messenger.\n *\n * This acts as a wrapper around the controller messenger instance that restricts access to actions\n * and events.\n *\n * @template Namespace - The namespace for this messenger. Typically this is the name of the controller or\n * module that this messenger has been created for. The authority to publish events and register\n * actions under this namespace is granted to this restricted messenger instance.\n * @template Action - A type union of all Action types.\n * @template Event - A type union of all Event types.\n * @template AllowedAction - A type union of the 'type' string for any allowed actions.\n * This must not include internal actions that are in the messenger's namespace.\n * @template AllowedEvent - A type union of the 'type' string for any allowed events.\n * This must not include internal events that are in the messenger's namespace.\n */\nexport class RestrictedControllerMessenger<\n  Namespace extends string,\n  Action extends ActionConstraint,\n  Event extends EventConstraint,\n  AllowedAction extends string,\n  AllowedEvent extends string,\n> {\n  readonly #controllerMessenger: ControllerMessenger<\n    ActionConstraint,\n    EventConstraint\n  >;\n\n  readonly #controllerName: Namespace;\n\n  readonly #allowedActions: NotNamespacedBy<Namespace, AllowedAction>[];\n\n  readonly #allowedEvents: NotNamespacedBy<Namespace, AllowedEvent>[];\n\n  /**\n   * Constructs a restricted controller messenger\n   *\n   * The provided allowlists grant the ability to call the listed actions and subscribe to the\n   * listed events. The \"name\" provided grants ownership of any actions and events under that\n   * namespace. Ownership allows registering actions and publishing events, as well as\n   * unregistering actions and clearing event subscriptions.\n   *\n   * @param options - The controller options.\n   * @param options.controllerMessenger - The controller messenger instance that is being wrapped.\n   * @param options.name - The name of the thing this messenger will be handed to (e.g. the\n   * controller name). This grants \"ownership\" of actions and events under this namespace to the\n   * restricted controller messenger returned.\n   * @param options.allowedActions - The list of actions that this restricted controller messenger\n   * should be alowed to call.\n   * @param options.allowedEvents - The list of events that this restricted controller messenger\n   * should be allowed to subscribe to.\n   */\n  constructor({\n    controllerMessenger,\n    name,\n    allowedActions,\n    allowedEvents,\n  }: {\n    controllerMessenger: ControllerMessenger<ActionConstraint, EventConstraint>;\n    name: Namespace;\n    allowedActions: NotNamespacedBy<Namespace, AllowedAction>[];\n    allowedEvents: NotNamespacedBy<Namespace, AllowedEvent>[];\n  }) {\n    this.#controllerMessenger = controllerMessenger;\n    this.#controllerName = name;\n    this.#allowedActions = allowedActions;\n    this.#allowedEvents = allowedEvents;\n  }\n\n  /**\n   * Register an action handler.\n   *\n   * This will make the registered function available to call via the `call` method.\n   *\n   * The action type this handler is registered under *must* be in the current namespace.\n   *\n   * @param action - The action type. This is a unqiue identifier for this action.\n   * @param handler - The action handler. This function gets called when the `call` method is\n   * invoked with the given action type.\n   * @throws Will throw if an action handler that is not in the current namespace is being registered.\n   * @template ActionType - A type union of Action type strings that are namespaced by Namespace.\n   */\n  registerActionHandler<\n    ActionType extends Action['type'] & NamespacedName<Namespace>,\n  >(action: ActionType, handler: ActionHandler<Action, ActionType>) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!this.#isInCurrentNamespace(action)) {\n      throw new Error(\n        `Only allowed registering action handlers prefixed by '${\n          this.#controllerName\n        }:'`,\n      );\n    }\n    this.#controllerMessenger.registerActionHandler(action, handler);\n  }\n\n  /**\n   * Unregister an action handler.\n   *\n   * This will prevent this action from being called.\n   *\n   * The action type being unregistered *must* be in the current namespace.\n   *\n   * @param action - The action type. This is a unique identifier for this action.\n   * @throws Will throw if an action handler that is not in the current namespace is being unregistered.\n   * @template ActionType - A type union of Action type strings that are namespaced by Namespace.\n   */\n  unregisterActionHandler<\n    ActionType extends Action['type'] & NamespacedName<Namespace>,\n  >(action: ActionType) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!this.#isInCurrentNamespace(action)) {\n      throw new Error(\n        `Only allowed unregistering action handlers prefixed by '${\n          this.#controllerName\n        }:'`,\n      );\n    }\n    this.#controllerMessenger.unregisterActionHandler(action);\n  }\n\n  /**\n   * Call an action.\n   *\n   * This function will call the action handler corresponding to the given action type, passing\n   * along any parameters given.\n   *\n   * The action type being called must be on the action allowlist.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @param params - The action parameters. These must match the type of the parameters of the\n   * registered action handler.\n   * @throws Will throw when no handler has been registered for the given type.\n   * @template ActionType - A type union of allowed Action type strings.\n   * @returns The action return value.\n   */\n  call<\n    ActionType extends\n      | AllowedAction\n      | (Action['type'] & NamespacedName<Namespace>),\n  >(\n    actionType: ActionType,\n    ...params: ExtractActionParameters<Action, ActionType>\n  ): ExtractActionResponse<Action, ActionType> {\n    if (!this.#isAllowedAction(actionType)) {\n      throw new Error(`Action missing from allow list: ${actionType}`);\n    }\n    const response = this.#controllerMessenger.call<ActionType>(\n      actionType,\n      ...params,\n    );\n\n    return response;\n  }\n\n  /**\n   * Register a function for getting the initial payload for an event.\n   *\n   * This is used for events that represent a state change, where the payload is the state.\n   * Registering a function for getting the payload allows event selectors to have a point of\n   * comparison the first time state changes.\n   *\n   * The event type *must* be in the current namespace\n   *\n   * @param args - The arguments to this function\n   * @param args.eventType - The event type to register a payload for.\n   * @param args.getPayload - A function for retrieving the event payload.\n   */\n  registerInitialEventPayload<\n    EventType extends Event['type'] & NamespacedName<Namespace>,\n  >({\n    eventType,\n    getPayload,\n  }: {\n    eventType: EventType;\n    getPayload: () => ExtractEventPayload<Event, EventType>;\n  }) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!this.#isInCurrentNamespace(eventType)) {\n      throw new Error(\n        `Only allowed publishing events prefixed by '${this.#controllerName}:'`,\n      );\n    }\n    this.#controllerMessenger.registerInitialEventPayload({\n      eventType,\n      getPayload,\n    });\n  }\n\n  /**\n   * Publish an event.\n   *\n   * Publishes the given payload to all subscribers of the given event type.\n   *\n   * The event type being published *must* be in the current namespace.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @param payload - The event payload. The type of the parameters for each event handler must\n   * match the type of this payload.\n   * @throws Will throw if an event that is not in the current namespace is being published.\n   * @template EventType - A type union of Event type strings that are namespaced by Namespace.\n   */\n  publish<EventType extends Event['type'] & NamespacedName<Namespace>>(\n    event: EventType,\n    ...payload: ExtractEventPayload<Event, EventType>\n  ) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!this.#isInCurrentNamespace(event)) {\n      throw new Error(\n        `Only allowed publishing events prefixed by '${this.#controllerName}:'`,\n      );\n    }\n    this.#controllerMessenger.publish(event, ...payload);\n  }\n\n  /**\n   * Subscribe to an event.\n   *\n   * Registers the given function as an event handler for the given event type.\n   *\n   * The event type being subscribed to must be on the event allowlist.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event handler must\n   * match the type of the payload for this event type.\n   * @throws Will throw if the given event is not an allowed event for this controller messenger.\n   * @template EventType - A type union of Event type strings.\n   */\n  subscribe<\n    EventType extends\n      | AllowedEvent\n      | (Event['type'] & NamespacedName<Namespace>),\n  >(eventType: EventType, handler: ExtractEventHandler<Event, EventType>): void;\n\n  /**\n   * Subscribe to an event, with a selector.\n   *\n   * Registers the given handler function as an event handler for the given\n   * event type. When an event is published, its payload is first passed to the\n   * selector. The event handler is only called if the selector's return value\n   * differs from its last known return value.\n   *\n   * The event type being subscribed to must be on the event allowlist.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event\n   * handler must match the return type of the selector.\n   * @param selector - The selector function used to select relevant data from\n   * the event payload. The type of the parameters for this selector must match\n   * the type of the payload for this event type.\n   * @throws Will throw if the given event is not an allowed event for this controller messenger.\n   * @template EventType - A type union of Event type strings.\n   * @template SelectorReturnValue - The selector return value.\n   */\n  subscribe<\n    EventType extends\n      | AllowedEvent\n      | (Event['type'] & NamespacedName<Namespace>),\n    SelectorReturnValue,\n  >(\n    eventType: EventType,\n    handler: SelectorEventHandler<SelectorReturnValue>,\n    selector: SelectorFunction<Event, EventType, SelectorReturnValue>,\n  ): void;\n\n  subscribe<\n    EventType extends\n      | AllowedEvent\n      | (Event['type'] & NamespacedName<Namespace>),\n    SelectorReturnValue,\n  >(\n    event: EventType,\n    handler: ExtractEventHandler<Event, EventType>,\n    selector?: SelectorFunction<Event, EventType, SelectorReturnValue>,\n  ) {\n    if (!this.#isAllowedEvent(event)) {\n      throw new Error(`Event missing from allow list: ${event}`);\n    }\n\n    if (selector) {\n      return this.#controllerMessenger.subscribe(event, handler, selector);\n    }\n    return this.#controllerMessenger.subscribe(event, handler);\n  }\n\n  /**\n   * Unsubscribe from an event.\n   *\n   * Unregisters the given function as an event handler for the given event.\n   *\n   * The event type being unsubscribed to must be on the event allowlist.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler to unregister.\n   * @throws Will throw if the given event is not an allowed event for this controller messenger.\n   * @template EventType - A type union of allowed Event type strings.\n   */\n  unsubscribe<\n    EventType extends\n      | AllowedEvent\n      | (Event['type'] & NamespacedName<Namespace>),\n  >(event: EventType, handler: ExtractEventHandler<Event, EventType>) {\n    if (!this.#isAllowedEvent(event)) {\n      throw new Error(`Event missing from allow list: ${event}`);\n    }\n    this.#controllerMessenger.unsubscribe(event, handler);\n  }\n\n  /**\n   * Clear subscriptions for a specific event.\n   *\n   * This will remove all subscribed handlers for this event.\n   *\n   * The event type being cleared *must* be in the current namespace.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @throws Will throw if a subscription for an event that is not in the current namespace is being cleared.\n   * @template EventType - A type union of Event type strings that are namespaced by Namespace.\n   */\n  clearEventSubscriptions<\n    EventType extends Event['type'] & NamespacedName<Namespace>,\n  >(event: EventType) {\n    if (!this.#isInCurrentNamespace(event)) {\n      throw new Error(\n        `Only allowed clearing events prefixed by '${this.#controllerName}:'`,\n      );\n    }\n    this.#controllerMessenger.clearEventSubscriptions(event);\n  }\n\n  /**\n   * Determine whether the given event type is allowed. Event types are\n   * allowed if they are in the current namespace or on the list of\n   * allowed events.\n   *\n   * @param eventType - The event type to check.\n   * @returns Whether the event type is allowed.\n   */\n  #isAllowedEvent(\n    eventType: Event['type'],\n  ): eventType is\n    | NamespacedName<Namespace>\n    | NotNamespacedBy<Namespace, AllowedEvent> {\n    // Safely upcast to allow runtime check\n    const allowedEvents: string[] | null = this.#allowedEvents;\n    return (\n      this.#isInCurrentNamespace(eventType) ||\n      (allowedEvents !== null && allowedEvents.includes(eventType))\n    );\n  }\n\n  /**\n   * Determine whether the given action type is allowed. Action types\n   * are allowed if they are in the current namespace or on the list of\n   * allowed actions.\n   *\n   * @param actionType - The action type to check.\n   * @returns Whether the action type is allowed.\n   */\n  #isAllowedAction(\n    actionType: Action['type'],\n  ): actionType is\n    | NamespacedName<Namespace>\n    | NotNamespacedBy<Namespace, AllowedAction> {\n    // Safely upcast to allow runtime check\n    const allowedActions: string[] | null = this.#allowedActions;\n    return (\n      this.#isInCurrentNamespace(actionType) ||\n      (allowedActions !== null && allowedActions.includes(actionType))\n    );\n  }\n\n  /**\n   * Determine whether the given name is within the current namespace.\n   *\n   * @param name - The name to check\n   * @returns Whether the name is within the current namespace\n   */\n  #isInCurrentNamespace(name: string): name is NamespacedName<Namespace> {\n    return name.startsWith(`${this.#controllerName}:`);\n  }\n}\n"]}