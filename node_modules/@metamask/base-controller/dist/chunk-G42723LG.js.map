{"version":3,"sources":["../src/ControllerMessenger.ts"],"names":[],"mappings":";;;;;;;;;AAAA;AA6HO,IAAM,sBAAN,MAGL;AAAA,EAHK;AAIL,uBAAS,UAAW,oBAAI,IAA6B;AAErD,uBAAS,SAAU,oBAAI,IAAgD;AAOvE;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAS,6BAA8B,oBAAI,IAGzC;AAKF;AAAA;AAAA;AAAA,uBAAS,oBAAqB,oBAAI,IAGhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaF,sBACE,YACA,SACA;AACA,QAAI,mBAAK,UAAS,IAAI,UAAU,GAAG;AACjC,YAAM,IAAI;AAAA,QACR,iBAAiB,UAAU;AAAA,MAC7B;AAAA,IACF;AACA,uBAAK,UAAS,IAAI,YAAY,OAAO;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,wBACE,YACA;AACA,uBAAK,UAAS,OAAO,UAAU;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe;AACb,uBAAK,UAAS,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,KACE,eACG,QACwC;AAC3C,UAAM,UAAU,mBAAK,UAAS,IAAI,UAAU;AAI5C,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,iBAAiB,UAAU,0BAA0B;AAAA,IACvE;AACA,WAAO,QAAQ,GAAG,MAAM;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,4BAA6D;AAAA,IAC3D;AAAA,IACA;AAAA,EACF,GAGG;AACD,uBAAK,6BAA4B,IAAI,WAAW,UAAU;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,QACE,cACG,SACH;AACA,UAAM,cAAc,mBAAK,SAAQ,IAAI,SAAS;AAE9C,QAAI,aAAa;AACf,iBAAW,CAAC,SAAS,QAAQ,KAAK,YAAY,QAAQ,GAAG;AACvD,YAAI;AACF,cAAI,UAAU;AACZ,kBAAM,gBAAgB,mBAAK,oBAAmB,IAAI,OAAO;AACzD,kBAAM,WAAW,SAAS,GAAG,OAAO;AAEpC,gBAAI,aAAa,eAAe;AAC9B,iCAAK,oBAAmB,IAAI,SAAS,QAAQ;AAC7C,sBAAQ,UAAU,aAAa;AAAA,YACjC;AAAA,UACF,OAAO;AACL,YAAC,QAAgC,GAAG,OAAO;AAAA,UAC7C;AAAA,QACF,SAAS,OAAO;AAGd,qBAAW,MAAM;AACf,kBAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAwCA,UACE,WACA,SACA,UACM;AACN,QAAI,cAAc,mBAAK,SAAQ,IAAI,SAAS;AAC5C,QAAI,CAAC,aAAa;AAChB,oBAAc,oBAAI,IAAI;AACtB,yBAAK,SAAQ,IAAI,WAAW,WAAW;AAAA,IACzC;AAEA,gBAAY,IAAI,SAAS,QAAQ;AAEjC,QAAI,UAAU;AACZ,YAAM,aAAa,mBAAK,6BAA4B,IAAI,SAAS;AACjE,UAAI,YAAY;AACd,cAAM,eAAe,SAAS,GAAG,WAAW,CAAC;AAC7C,2BAAK,oBAAmB,IAAI,SAAS,YAAY;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,YACE,WACA,SACA;AACA,UAAM,cAAc,mBAAK,SAAQ,IAAI,SAAS;AAE9C,QAAI,CAAC,eAAe,CAAC,YAAY,IAAI,OAAO,GAAG;AAC7C,YAAM,IAAI,MAAM,qCAAqC,SAAS,EAAE;AAAA,IAClE;AAEA,UAAM,WAAW,YAAY,IAAI,OAAO;AACxC,QAAI,UAAU;AACZ,yBAAK,oBAAmB,OAAO,OAAO;AAAA,IACxC;AAEA,gBAAY,OAAO,OAAO;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,wBACE,WACA;AACA,uBAAK,SAAQ,OAAO,SAAS;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB;AACnB,uBAAK,SAAQ,MAAM;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4BA,cAIE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAiBE;AACA,WAAO,IAAI,8BAA8B;AAAA,MACvC,qBAAqB;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA1UW;AAEA;AAOA;AAQA","sourcesContent":["import { RestrictedControllerMessenger } from './RestrictedControllerMessenger';\n\nexport type ActionHandler<\n  Action extends ActionConstraint,\n  ActionType = Action['type'],\n> = (\n  ...args: ExtractActionParameters<Action, ActionType>\n) => ExtractActionResponse<Action, ActionType>;\n\nexport type ExtractActionParameters<\n  Action extends ActionConstraint,\n  ActionType = Action['type'],\n> = Action extends {\n  type: ActionType;\n  handler: (...args: infer HandlerArgs) => unknown;\n}\n  ? HandlerArgs\n  : never;\n\nexport type ExtractActionResponse<\n  Action extends ActionConstraint,\n  ActionType = Action['type'],\n> = Action extends {\n  type: ActionType;\n  handler: (...args: infer _) => infer HandlerReturnValue;\n}\n  ? HandlerReturnValue\n  : never;\n\nexport type ExtractEventHandler<\n  Event extends EventConstraint,\n  EventType = Event['type'],\n> = Event extends {\n  type: EventType;\n  payload: infer Payload;\n}\n  ? Payload extends unknown[]\n    ? (...payload: Payload) => void\n    : never\n  : never;\n\nexport type ExtractEventPayload<\n  Event extends EventConstraint,\n  EventType = Event['type'],\n> = Event extends {\n  type: EventType;\n  payload: infer Payload;\n}\n  ? Payload extends unknown[]\n    ? Payload\n    : never\n  : never;\n\nexport type GenericEventHandler = (...args: unknown[]) => void;\n\nexport type SelectorFunction<\n  Event extends EventConstraint,\n  EventType extends Event['type'],\n  ReturnValue,\n> = (...args: ExtractEventPayload<Event, EventType>) => ReturnValue;\nexport type SelectorEventHandler<SelectorReturnValue> = (\n  newValue: SelectorReturnValue,\n  previousValue: SelectorReturnValue | undefined,\n) => void;\n\nexport type ActionConstraint = {\n  type: string;\n  handler: ((...args: never) => unknown) | ((...args: never[]) => unknown);\n};\nexport type EventConstraint = {\n  type: string;\n  payload: unknown[];\n};\n\ntype EventSubscriptionMap<\n  Event extends EventConstraint,\n  ReturnValue = unknown,\n> = Map<\n  GenericEventHandler | SelectorEventHandler<ReturnValue>,\n  SelectorFunction<Event, Event['type'], ReturnValue> | undefined\n>;\n\n/**\n * A namespaced string\n *\n * This type verifies that the string Name is prefixed by the string Name followed by a colon.\n *\n * @template Namespace - The namespace we're checking for.\n * @template Name - The full string, including the namespace.\n */\nexport type NamespacedBy<\n  Namespace extends string,\n  Name extends string,\n> = Name extends `${Namespace}:${string}` ? Name : never;\n\nexport type NotNamespacedBy<\n  Namespace extends string,\n  Name extends string,\n> = Name extends `${Namespace}:${string}` ? never : Name;\n\nexport type NamespacedName<Namespace extends string = string> =\n  `${Namespace}:${string}`;\n\ntype NarrowToNamespace<Name, Namespace extends string> = Name extends {\n  type: `${Namespace}:${string}`;\n}\n  ? Name\n  : never;\n\ntype NarrowToAllowed<Name, Allowed extends string> = Name extends {\n  type: Allowed;\n}\n  ? Name\n  : never;\n\n/**\n * A messaging system for controllers.\n *\n * The controller messenger allows registering functions as 'actions' that can be called elsewhere,\n * and it allows publishing and subscribing to events. Both actions and events are identified by\n * unique strings.\n *\n * @template Action - A type union of all Action types.\n * @template Event - A type union of all Event types.\n */\nexport class ControllerMessenger<\n  Action extends ActionConstraint,\n  Event extends EventConstraint,\n> {\n  readonly #actions = new Map<Action['type'], unknown>();\n\n  readonly #events = new Map<Event['type'], EventSubscriptionMap<Event>>();\n\n  /**\n   * A map of functions for getting the initial event payload.\n   *\n   * Used only for events that represent state changes.\n   */\n  readonly #initialEventPayloadGetters = new Map<\n    Event['type'],\n    () => ExtractEventPayload<Event, Event['type']>\n  >();\n\n  /**\n   * A cache of selector return values for their respective handlers.\n   */\n  readonly #eventPayloadCache = new Map<\n    GenericEventHandler,\n    unknown | undefined\n  >();\n\n  /**\n   * Register an action handler.\n   *\n   * This will make the registered function available to call via the `call` method.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @param handler - The action handler. This function gets called when the `call` method is\n   * invoked with the given action type.\n   * @throws Will throw when a handler has been registered for this action type already.\n   * @template ActionType - A type union of Action type strings.\n   */\n  registerActionHandler<ActionType extends Action['type']>(\n    actionType: ActionType,\n    handler: ActionHandler<Action, ActionType>,\n  ) {\n    if (this.#actions.has(actionType)) {\n      throw new Error(\n        `A handler for ${actionType} has already been registered`,\n      );\n    }\n    this.#actions.set(actionType, handler);\n  }\n\n  /**\n   * Unregister an action handler.\n   *\n   * This will prevent this action from being called.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @template ActionType - A type union of Action type strings.\n   */\n  unregisterActionHandler<ActionType extends Action['type']>(\n    actionType: ActionType,\n  ) {\n    this.#actions.delete(actionType);\n  }\n\n  /**\n   * Unregister all action handlers.\n   *\n   * This prevents all actions from being called.\n   */\n  clearActions() {\n    this.#actions.clear();\n  }\n\n  /**\n   * Call an action.\n   *\n   * This function will call the action handler corresponding to the given action type, passing\n   * along any parameters given.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @param params - The action parameters. These must match the type of the parameters of the\n   * registered action handler.\n   * @throws Will throw when no handler has been registered for the given type.\n   * @template ActionType - A type union of Action type strings.\n   * @returns The action return value.\n   */\n  call<ActionType extends Action['type']>(\n    actionType: ActionType,\n    ...params: ExtractActionParameters<Action, ActionType>\n  ): ExtractActionResponse<Action, ActionType> {\n    const handler = this.#actions.get(actionType) as ActionHandler<\n      Action,\n      ActionType\n    >;\n    if (!handler) {\n      throw new Error(`A handler for ${actionType} has not been registered`);\n    }\n    return handler(...params);\n  }\n\n  /**\n   * Register a function for getting the initial payload for an event.\n   *\n   * This is used for events that represent a state change, where the payload is the state.\n   * Registering a function for getting the payload allows event selectors to have a point of\n   * comparison the first time state changes.\n   *\n   * @param args - The arguments to this function\n   * @param args.eventType - The event type to register a payload for.\n   * @param args.getPayload - A function for retrieving the event payload.\n   */\n  registerInitialEventPayload<EventType extends Event['type']>({\n    eventType,\n    getPayload,\n  }: {\n    eventType: EventType;\n    getPayload: () => ExtractEventPayload<Event, EventType>;\n  }) {\n    this.#initialEventPayloadGetters.set(eventType, getPayload);\n  }\n\n  /**\n   * Publish an event.\n   *\n   * Publishes the given payload to all subscribers of the given event type.\n   *\n   * Note that this method should never throw directly. Any errors from\n   * subscribers are captured and re-thrown in a timeout handler.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param payload - The event payload. The type of the parameters for each event handler must\n   * match the type of this payload.\n   * @template EventType - A type union of Event type strings.\n   */\n  publish<EventType extends Event['type']>(\n    eventType: EventType,\n    ...payload: ExtractEventPayload<Event, EventType>\n  ) {\n    const subscribers = this.#events.get(eventType);\n\n    if (subscribers) {\n      for (const [handler, selector] of subscribers.entries()) {\n        try {\n          if (selector) {\n            const previousValue = this.#eventPayloadCache.get(handler);\n            const newValue = selector(...payload);\n\n            if (newValue !== previousValue) {\n              this.#eventPayloadCache.set(handler, newValue);\n              handler(newValue, previousValue);\n            }\n          } else {\n            (handler as GenericEventHandler)(...payload);\n          }\n        } catch (error) {\n          // Throw error after timeout so that it is capured as a console error\n          // (and by Sentry) without interrupting the event publishing.\n          setTimeout(() => {\n            throw error;\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Subscribe to an event.\n   *\n   * Registers the given function as an event handler for the given event type.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event handler must\n   * match the type of the payload for this event type.\n   * @template EventType - A type union of Event type strings.\n   */\n  subscribe<EventType extends Event['type']>(\n    eventType: EventType,\n    handler: ExtractEventHandler<Event, EventType>,\n  ): void;\n\n  /**\n   * Subscribe to an event, with a selector.\n   *\n   * Registers the given handler function as an event handler for the given\n   * event type. When an event is published, its payload is first passed to the\n   * selector. The event handler is only called if the selector's return value\n   * differs from its last known return value.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event\n   * handler must match the return type of the selector.\n   * @param selector - The selector function used to select relevant data from\n   * the event payload. The type of the parameters for this selector must match\n   * the type of the payload for this event type.\n   * @template EventType - A type union of Event type strings.\n   * @template SelectorReturnValue - The selector return value.\n   */\n  subscribe<EventType extends Event['type'], SelectorReturnValue>(\n    eventType: EventType,\n    handler: SelectorEventHandler<SelectorReturnValue>,\n    selector: SelectorFunction<Event, EventType, SelectorReturnValue>,\n  ): void;\n\n  subscribe<EventType extends Event['type'], SelectorReturnValue>(\n    eventType: EventType,\n    handler: ExtractEventHandler<Event, EventType>,\n    selector?: SelectorFunction<Event, EventType, SelectorReturnValue>,\n  ): void {\n    let subscribers = this.#events.get(eventType);\n    if (!subscribers) {\n      subscribers = new Map();\n      this.#events.set(eventType, subscribers);\n    }\n\n    subscribers.set(handler, selector);\n\n    if (selector) {\n      const getPayload = this.#initialEventPayloadGetters.get(eventType);\n      if (getPayload) {\n        const initialValue = selector(...getPayload());\n        this.#eventPayloadCache.set(handler, initialValue);\n      }\n    }\n  }\n\n  /**\n   * Unsubscribe from an event.\n   *\n   * Unregisters the given function as an event handler for the given event.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler to unregister.\n   * @throws Will throw when the given event handler is not registered for this event.\n   * @template EventType - A type union of Event type strings.\n   */\n  unsubscribe<EventType extends Event['type']>(\n    eventType: EventType,\n    handler: ExtractEventHandler<Event, EventType>,\n  ) {\n    const subscribers = this.#events.get(eventType);\n\n    if (!subscribers || !subscribers.has(handler)) {\n      throw new Error(`Subscription not found for event: ${eventType}`);\n    }\n\n    const selector = subscribers.get(handler);\n    if (selector) {\n      this.#eventPayloadCache.delete(handler);\n    }\n\n    subscribers.delete(handler);\n  }\n\n  /**\n   * Clear subscriptions for a specific event.\n   *\n   * This will remove all subscribed handlers for this event.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @template EventType - A type union of Event type strings.\n   */\n  clearEventSubscriptions<EventType extends Event['type']>(\n    eventType: EventType,\n  ) {\n    this.#events.delete(eventType);\n  }\n\n  /**\n   * Clear all subscriptions.\n   *\n   * This will remove all subscribed handlers for all events.\n   */\n  clearSubscriptions() {\n    this.#events.clear();\n  }\n\n  /**\n   * Get a restricted controller messenger\n   *\n   * Returns a wrapper around the controller messenger instance that restricts access to actions\n   * and events. The provided allowlists grant the ability to call the listed actions and subscribe\n   * to the listed events. The \"name\" provided grants ownership of any actions and events under\n   * that namespace. Ownership allows registering actions and publishing events, as well as\n   * unregistering actions and clearing event subscriptions.\n   *\n   * @param options - Controller messenger options.\n   * @param options.name - The name of the thing this messenger will be handed to (e.g. the\n   * controller name). This grants \"ownership\" of actions and events under this namespace to the\n   * restricted controller messenger returned.\n   * @param options.allowedActions - The list of actions that this restricted controller messenger\n   * should be alowed to call.\n   * @param options.allowedEvents - The list of events that this restricted controller messenger\n   * should be allowed to subscribe to.\n   * @template Namespace - The namespace for this messenger. Typically this is the name of the controller or\n   * module that this messenger has been created for. The authority to publish events and register\n   * actions under this namespace is granted to this restricted messenger instance.\n   * @template AllowedAction - A type union of the 'type' string for any allowed actions.\n   * This must not include internal actions that are in the messenger's namespace.\n   * @template AllowedEvent - A type union of the 'type' string for any allowed events.\n   * This must not include internal events that are in the messenger's namespace.\n   * @returns The restricted controller messenger.\n   */\n  getRestricted<\n    Namespace extends string,\n    AllowedAction extends NotNamespacedBy<Namespace, Action['type']> = never,\n    AllowedEvent extends NotNamespacedBy<Namespace, Event['type']> = never,\n  >({\n    name,\n    allowedActions,\n    allowedEvents,\n  }: {\n    name: Namespace;\n    allowedActions: NotNamespacedBy<\n      Namespace,\n      Extract<Action['type'], AllowedAction>\n    >[];\n    allowedEvents: NotNamespacedBy<\n      Namespace,\n      Extract<Event['type'], AllowedEvent>\n    >[];\n  }): RestrictedControllerMessenger<\n    Namespace,\n    | NarrowToNamespace<Action, Namespace>\n    | NarrowToAllowed<Action, AllowedAction>,\n    NarrowToNamespace<Event, Namespace> | NarrowToAllowed<Event, AllowedEvent>,\n    AllowedAction,\n    AllowedEvent\n  > {\n    return new RestrictedControllerMessenger({\n      controllerMessenger: this,\n      name,\n      allowedActions,\n      allowedEvents,\n    });\n  }\n}\n"]}